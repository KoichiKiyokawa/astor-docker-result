Determine revision date.................................................... OK
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8 -Duser.language=en-US -Duser.country=US -Duser.language=en
[INFO] 04:33:52,374 fr.inria.astor.core.setup.ProjectConfiguration:282 - Version of the JVM used: 1.7.0_181
[INFO] 04:33:52,381 main:381 - Java version of the JDK used to run tests: 1.7.0_181
[INFO] 04:33:52,381 main:382 - The compliance of the JVM is:  7
[INFO] 04:33:52,384 main:660 - command line arguments: [-mode  jgenprog  -location  .  -id  Time-3  -failing  org.joda.time.TestMutableDateTime_Adds  -jvm4testexecution  /usr/lib/jvm/java-1.7.0-openjdk-amd64/bin/  -jvm4evosuitetestexecution  /usr/lib/jvm/java-1.7.0-openjdk-amd64/bin/  -maxgen  1000000  -maxtime  120  -stopfirst  true  -seed  0  -scope  local  -population  1  -javacompliancelevel  5  -srcjavafolder  src/main/java/  -srctestfolder  src/test/java/  -binjavafolder  target/classes/  -bintestfolder  target/test-classes/  -parameters  mode:leven  -dependencies  /script/jGenProg_Defects4J_Time_3/target/classes/:/script/jGenProg_Defects4J_Time_3/target/test-classes/:/defects4j/framework/projects/Time/lib/joda-convert-1.2.jar:/defects4j/framework/projects/Time/lib/junit-3.8.2.jar:/defects4j/framework/projects/Time/lib/junit/junit/3.8.2/junit-3.8.2.jar:/defects4j/framework/projects/Time/lib/org/joda/joda-convert/1.2/joda-convert-1.2.jar]
[INFO] 04:33:52,392 fr.inria.main.evolution.AstorMain:224 - Running Astor on a JDK at /usr/lib/jvm/java-8-openjdk-amd64/jre
[INFO ] fr.inria.main.AbstractMain.determineSourceFolders(AbstractMain.java:975) - Source folders: [/script/jGenProg_Defects4J_Time_3/./src/main/java]
[INFO ] fr.inria.main.AbstractMain.determineSourceFolders(AbstractMain.java:994) - Source Test folders: [/script/jGenProg_Defects4J_Time_3/./src/test/java]
[INFO ] fr.inria.main.evolution.AstorMain.createEngine(AstorMain.java:104) - mode is Leven
[INFO ] fr.inria.astor.core.solutionsearch.AstorCoreEngine.resolveTestsToRun(AstorCoreEngine.java:1311) - Test retrieved from classes: 264
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.calculateSuspicious(GZoltarFaultLocalization.java:74) - -Executing Gzoltar classpath: /script/jGenProg_Defects4J_Time_3/./output_astor/AstorMain-Time-3//bin//default from 264 classes with test cases
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:154) - Gzoltar fault localization: min susp value parameter: 0.1
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:174) - -gz-Adding classpath: [/script/jGenProg_Defects4J_Time_3/./output_astor/AstorMain-Time-3//bin//default, /script/jGenProg_Defects4J_Time_3/target/classes/, /script/jGenProg_Defects4J_Time_3/target/test-classes/, /defects4j/framework/projects/Time/lib/joda-convert-1.2.jar, /defects4j/framework/projects/Time/lib/junit-3.8.2.jar, /defects4j/framework/projects/Time/lib/junit/junit/3.8.2/junit-3.8.2.jar, /defects4j/framework/projects/Time/lib/org/joda/joda-convert/1.2/joda-convert-1.2.jar]
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_cutoverPreZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_plusWeekyears_positiveToNegative_crossCutover
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_plusYears_positiveToZero_crossCutover
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_plusYears_positiveToNegative_crossCutover
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_plusWeekyears_positiveToZero_crossCutover
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedMutableDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedGJChronologyChangedInternals
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testDuration
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedISOChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedBuddhistChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTimeProperty
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedPeriodType
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedJulianChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTimeFieldType
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedYearMonthDay
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedMutableDateTimeProperty
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedGregorianChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedLocalDate
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedLocalTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedUnsupportedDateTimeField
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTimeZone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedCopticChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedLocalDateBuddhist
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateMidnight
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedGJChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTimeZoneUTC
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedInstant
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedLocalDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedTimeOfDay
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateMidnightProperty
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.field.TestFieldUtils#testSafeDivideLongLong
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29_newYork_startOfYear
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatter#testZoneShortNameNearTransition
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29_tokyo_endOfYear
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatter#testZoneNameNearTransition
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestISOChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_months1
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_months2
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_monthsWeeks
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestEthiopicChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGregorianChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29_newYork_startOfYear
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatter#testZoneShortNameNearTransition
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29_tokyo_endOfYear
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatter#testZoneNameNearTransition
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormat#testFormat_zoneText
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormat#testFormat_zoneLongText
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_fullDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_mediumLongDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_fullTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_shortLongDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_longTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_mediumFullDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_shortFullDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_longDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseLongName
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseShortNameWithAutoLookup
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseLongNameWithLookup
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseShortNameWithLookup
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseShortName
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDays#testFactory_daysBetween_RPartial_MonthDay
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMonths#testFactory_monthsBetween_RPartial_MonthDay
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTime_Properties#testPropertyGetCenturyOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTime_Properties#testPropertyGetYearOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAddYears_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAddDays_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAddWeeks_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAdd_DurationFieldType_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAddMonths_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Properties#testPropertyGetCenturyOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Properties#testPropertyGetYearOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateMidnight_Properties#testPropertyGetCenturyOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateMidnight_Properties#testPropertyGetYearOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testDividedBy_long1
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testDividedBy_long2
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testNegated_long1
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testNegated_long2
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testNegated_long3
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testMultipliedBy_long1
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testMultipliedBy_long2
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestInterval_Basics#testIsEqual_RI
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_winter_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_springDST_2Hour40Savings_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_autumnDST_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_springDST_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_summer_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_months1
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_months2
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_monthsWeeks
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMonths#testFactory_monthsBetween_RPartial_MonthDay
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDays#testFactory_daysBetween_RPartial_MonthDay
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestPartial_Basics#testWith3
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testGetName_berlin
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testGetShortName
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testGetName
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testForOffsetHoursMinutes_int_int
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testGetShortName_berlin
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedMutableDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedGJChronologyChangedInternals
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testDuration
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedISOChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedBuddhistChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTimeProperty
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedPeriodType
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedJulianChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTimeFieldType
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedYearMonthDay
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedMutableDateTimeProperty
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedGregorianChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedLocalDate
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedLocalTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedUnsupportedDateTimeField
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTimeZone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedCopticChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedLocalDateBuddhist
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateMidnight
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedGJChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTimeZoneUTC
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedInstant
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedLocalDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedTimeOfDay
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateMidnightProperty
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestBuddhistChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestCopticChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestEthiopicChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGregorianChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestIslamicChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestJulianChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestISOChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_cutoverPreZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_plusWeekyears_positiveToNegative_crossCutover
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_plusYears_positiveToZero_crossCutover
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_plusYears_positiveToNegative_crossCutover
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_plusWeekyears_positiveToZero_crossCutover
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.field.TestFieldUtils#testSafeDivideLongLong
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29_newYork_startOfYear
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatter#testZoneShortNameNearTransition
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29_tokyo_endOfYear
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatter#testZoneNameNearTransition
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormat#testFormat_zoneText
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormat#testFormat_zoneLongText
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_fullDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_mediumLongDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_fullTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_shortLongDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_longTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_mediumFullDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_shortFullDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_longDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseLongName
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseShortNameWithAutoLookup
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseLongNameWithLookup
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseShortNameWithLookup
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseShortName
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.tz.TestCompiler#testDateTimeZoneBuilder
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAddYears_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAddDays_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAddWeeks_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAdd_DurationFieldType_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAddMonths_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.tz.TestCompiler#testDateTimeZoneBuilder
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestInterval_Basics#testIsEqual_RI
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testDividedBy_long1
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testDividedBy_long2
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testNegated_long1
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testNegated_long2
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testNegated_long3
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testMultipliedBy_long1
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testMultipliedBy_long2
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseLongName
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseShortNameWithAutoLookup
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseLongNameWithLookup
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseShortNameWithLookup
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseShortName
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTime_Properties#testPropertyGetCenturyOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTime_Properties#testPropertyGetYearOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAddYears_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAddDays_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAddWeeks_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAdd_DurationFieldType_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Adds#testAddMonths_int_dstOverlapWinter_addZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Properties#testPropertyGetCenturyOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Properties#testPropertyGetYearOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateMidnight_Properties#testPropertyGetCenturyOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateMidnight_Properties#testPropertyGetYearOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testDividedBy_long1
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testDividedBy_long2
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testNegated_long1
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testNegated_long2
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testNegated_long3
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testMultipliedBy_long1
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDuration_Basics#testMultipliedBy_long2
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestInterval_Basics#testIsEqual_RI
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_winter_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_springDST_2Hour40Savings_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_autumnDST_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_springDST_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_summer_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_months1
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_months2
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_monthsWeeks
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMonths#testFactory_monthsBetween_RPartial_MonthDay
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDays#testFactory_daysBetween_RPartial_MonthDay
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestPartial_Basics#testWith3
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testGetName_berlin
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testGetShortName
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testGetName
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testForOffsetHoursMinutes_int_int
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testGetShortName_berlin
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedMutableDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedGJChronologyChangedInternals
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testDuration
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedISOChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedBuddhistChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTimeProperty
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedPeriodType
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedJulianChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTimeFieldType
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedYearMonthDay
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedMutableDateTimeProperty
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedGregorianChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedLocalDate
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedLocalTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedUnsupportedDateTimeField
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTimeZone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedCopticChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedLocalDateBuddhist
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateMidnight
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedGJChronology
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateTimeZoneUTC
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedInstant
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedLocalDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedTimeOfDay
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestSerialization#testSerializedDateMidnightProperty
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_fullDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_mediumLongDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_fullTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_shortLongDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_longTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_mediumFullDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_shortFullDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormatStyle#testForStyle_longDateTime
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Properties#testPropertyGetCenturyOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestMutableDateTime_Properties#testPropertyGetYearOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormat#testFormat_zoneText
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.format.TestDateTimeFormat#testFormat_zoneLongText
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestPartial_Basics#testWith3
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestIslamicChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTime_Properties#testPropertyGetCenturyOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTime_Properties#testPropertyGetYearOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_winter_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_springDST_2Hour40Savings_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_autumnDST_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_springDST_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestLocalDateTime_Basics#testToDate_summer_Zone
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestJulianChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestBuddhistChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateMidnight_Properties#testPropertyGetCenturyOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateMidnight_Properties#testPropertyGetYearOfEra
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestBuddhistChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestCopticChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestEthiopicChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGregorianChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestIslamicChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestJulianChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestISOChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_cutoverPreZero
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_plusWeekyears_positiveToNegative_crossCutover
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_plusYears_positiveToZero_crossCutover
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_plusYears_positiveToNegative_crossCutover
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestGJDate#test_plusWeekyears_positiveToZero_crossCutover
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.tz.TestCompiler#testDateTimeZoneBuilder
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.chrono.TestCopticChronology#testDateFields
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.field.TestFieldUtils#testSafeDivideLongLong
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testGetName_berlin
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testGetShortName
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testGetName
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testForOffsetHoursMinutes_int_int
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:214) - Test failt: org.joda.time.TestDateTimeZone#testGetShortName_berlin
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:226) - Gzoltar Test Result Total:12118, fails: 285, GZoltar suspicious 10336, with positive susp 2799
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:234) - nr test results 12119
[INFO ] fr.inria.astor.core.faultlocalization.gzoltar.GZoltarFaultLocalization.searchSuspicious(GZoltarFaultLocalization.java:289) - Gzoltar found: 487 with susp > 0.1, we consider: 487
[INFO ] fr.inria.astor.core.solutionsearch.AstorCoreEngine.calculateSuspicious(AstorCoreEngine.java:898) - Setting up the max to 372660 milliseconds (372 sec)
[INFO ] fr.inria.astor.core.solutionsearch.AstorCoreEngine.initPopulation(AstorCoreEngine.java:709) - 
---- Creating spoon model
[INFO ] fr.inria.astor.core.manipulation.MutationSupporter.buildSpoonModel(MutationSupporter.java:240) - Creating model,  Code location from working folder: /script/jGenProg_Defects4J_Time_3/./src/main/java
[INFO ] fr.inria.astor.core.manipulation.MutationSupporter.buildModel(MutationSupporter.java:68) - building model: /script/jGenProg_Defects4J_Time_3/./src/main/java, compliance level: 5
[INFO ] fr.inria.astor.core.manipulation.MutationSupporter.buildModel(MutationSupporter.java:82) - Classpath (Dependencies) for building SpoonModel: [/script/jGenProg_Defects4J_Time_3/target/classes/, /script/jGenProg_Defects4J_Time_3/target/test-classes/, /defects4j/framework/projects/Time/lib/joda-convert-1.2.jar, /defects4j/framework/projects/Time/lib/junit-3.8.2.jar, /defects4j/framework/projects/Time/lib/junit/junit/3.8.2/junit-3.8.2.jar, /defects4j/framework/projects/Time/lib/org/joda/joda-convert/1.2/joda-convert-1.2.jar]
[INFO ] fr.inria.astor.core.solutionsearch.AstorCoreEngine.initModel(AstorCoreEngine.java:779) - Number of CtTypes created: 157
[INFO ] fr.inria.astor.core.solutionsearch.AstorCoreEngine.initPopulation(AstorCoreEngine.java:713) - 
---- Initial suspicious size: 487
[INFO ] fr.inria.astor.core.solutionsearch.population.ProgramVariantFactory.createProgramInstance(ProgramVariantFactory.java:134) - Total suspicious from FL: 487,  246
[INFO ] fr.inria.astor.core.solutionsearch.population.ProgramVariantFactory.createProgramInstance(ProgramVariantFactory.java:143) - Total ModPoint created: 246
[INFO ] fr.inria.astor.core.solutionsearch.population.ProgramVariantFactory.createInitialPopulation(ProgramVariantFactory.java:82) - Creating program variant #1, [Variant id: 1, #gens: 246, #ops: 0, parent:-]
[INFO ] fr.inria.astor.core.solutionsearch.AstorCoreEngine.setFitnessOfPopulation(AstorCoreEngine.java:754) - The original fitness is : 18.0
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:66) - ----------------------------
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:67) - ---Configuration properties:---Execution values
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:lastJUnitVersion= ./examples/libs/junit-4.11.jar
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:alternativecompliancelevel= 8
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:ignoredTestCases= 
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:workingDirectory= /script/jGenProg_Defects4J_Time_3/./output_astor
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:manipulatesuper= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:validation= process
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:jvm4testexecution= /usr/lib/jvm/java-1.7.0-openjdk-amd64/bin/
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:operatorspace= irr-statements
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:disablelog= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:binjavafolder= target/classes/
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:synthesis_depth= 3
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:gzoltartestpackagetoexclude= junit.framework
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:skipfitnessinitialpopulation= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:evosuiteresultfolder= evosuite
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:flthreshold= 0.1
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:regressionforfaultlocalization= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:collectonlyusedmethod= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:preservelinenumbers= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:tmax2= 372660
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:tmax1= 10000
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:probagenmutation= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:nomodificationconvergence= 100
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:diff_type= relative
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:targetelementprocessor= statements
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:srctestfolder= src/test/java/
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:forceExecuteRegression= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:clusteringfilename= clustering.csv
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:failing= org.joda.time.TestMutableDateTime_Adds
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:logtestexecution= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:evo_buggy_class= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:numberExecutions= 1
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:maxnumbersolutions= 1000000
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:evo_affected_by_op= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:population= 1
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:considerzerovaluesusp= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:maxCombinationVariableLimit= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:loglevel= INFO
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:savesolution= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:javacompliancelevel= 5
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:uniqueoptogen= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:gzoltarpackagetonotinstrument= junit.framework
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:projectIdentifier= Time-3
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:modificationpointnavigation= weight
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:stopfirst= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:multipointmodification= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:elementsToMutate= 10
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:jsonoutputname= astor_output
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:evoDSE= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:bintestfolder= target/test-classes/
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:testbystep= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:version-location= ./math-version/
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:reintroduce= PARENTS:ORIGINAL
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:executorjar= ./lib/jtestex7.jar
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:maxGeneration= 1000000
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:max_synthesis_step= 10000
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:projectinfocommand= com.github.tdurieux:project-config-maven-plugin:info
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:maxVarCombination= 1000
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:maxtime= 120
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:evosuitejar= ./lib/evosuite-master-1.0.4-SNAPSHOT.jar
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:jvmversion= 1.7.0_181
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:commandTrunk= 50000
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:faultlocalization= gzoltar
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:resetmodel= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:maxsuspcandidates= 1000
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:mode= leven
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:learningdir= 
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:jvm4evosuitetestexecution= /usr/lib/jvm/java-1.7.0-openjdk-amd64/bin/
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:filterfaultlocalization= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:mutationrate= 1 
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:pathToMVNRepository= 
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:resourcesfolder= /src/main/resources:/src/test/resources:
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:timezone= America/Los_Angeles
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:runjava7code= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:evoRunOnBuggyClass= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:compiler= fr.inria.astor.core.manipulation.bytecode.compiler.SpoonClassCompiler
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:limitbysuspicious= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:logsattemps= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:dependenciespath= /script/jGenProg_Defects4J_Time_3/target/classes/:/script/jGenProg_Defects4J_Time_3/target/test-classes/:/defects4j/framework/projects/Time/lib/joda-convert-1.2.jar:/defects4j/framework/projects/Time/lib/junit-3.8.2.jar:/defects4j/framework/projects/Time/lib/junit/junit/3.8.2/junit-3.8.2.jar:/defects4j/framework/projects/Time/lib/org/joda/joda-convert/1.2/joda-convert-1.2.jar
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:logpatternlayout= [%-5p] %l - %m%n
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:packageToInstrument= 
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:skipfaultlocalization= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:scope= local
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:transformingredient= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:fitnessfunction= fr.inria.astor.core.solutionsearch.population.TestCaseFitnessFunction
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:maxnumvariablesperingredient= 10
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:parsesourcefromoriginal= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:pvariantfoldername= variant-
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:savespoonmodelondisk= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:srcjavafolder= src/main/java/
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:populationcontroller= fr.inria.astor.core.solutionsearch.population.TestCaseBasedFitnessPopulationController
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:ignoreflakyinfl= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:cleantemplates= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:applyCrossover= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:maxmodificationpoints= 1000
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:duplicateingredientsinspace= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:metid= 0
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:continuewhenmodelfail= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:saveall= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:seed= 0
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:savecompletepatched= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:resetoperations= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:processoutputinfile= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:location= .
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:probabilistictransformation= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:overridemaxtime= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:outputjsonresult= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:allpoints= false
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:bugId= 280
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:evosuitetimeout= 120
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:maxtimefactor= 10
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:nrPlaceholders= 1
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:69) - p:forcesubprocesskilling= true
[INFO ] fr.inria.astor.core.setup.ConfigurationProperties.print(ConfigurationProperties.java:71) - ----------------------------
[INFO ] fr.inria.astor.core.solutionsearch.EvolutionarySearchEngine.startEvolution(EvolutionarySearchEngine.java:40) - 
----Starting Solution Search
return iOfYear.previous(instant, standardOffset, saveMillis):return iOfYear.previous(instant, standardOffset, saveMillis)
return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear):return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear)
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis)
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)))):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in))))
return rename((iNameKey + appendNameKey).intern()):return rename((iNameKey + appendNameKey).intern())
return iSaveMillis:return iSaveMillis
return iOfYear.next(instant, standardOffset, saveMillis):return iOfYear.next(instant, standardOffset, saveMillis)
return iNameKey:return iNameKey
return iOfYear:return iOfYear
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)))):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in))))
return append0(null, parser):return append0(null, parser)
return appendFraction(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, maxDigits)
return appendDecimal(org.joda.time.DateTimeFieldType.monthOfYear(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.monthOfYear(), minDigits, 2)
return isParser(getFormatter()):return isParser(getFormatter())
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields))
return appendFraction(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, maxDigits)
return appendDecimal(org.joda.time.DateTimeFieldType.millisOfSecond(), minDigits, 3):return appendDecimal(org.joda.time.DateTimeFieldType.millisOfSecond(), minDigits, 3)
return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isPrinter():return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isPrinter()
return true:return true
return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfHalfday(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfHalfday(), minDigits, 2)
return append0(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE, org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE):return append0(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE, org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE)
return appendDecimal(org.joda.time.DateTimeFieldType.millisOfDay(), minDigits, 8):return appendDecimal(org.joda.time.DateTimeFieldType.millisOfDay(), minDigits, 8)
return append0(printer, parser):return append0(printer, parser)
return append0(formatter.getPrinter(), formatter.getParser()):return append0(formatter.getPrinter(), formatter.getParser())
return append0(printer, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(copyOfParsers)):return append0(printer, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(copyOfParsers))
return ((org.joda.time.format.DateTimeParser) (f)):return ((org.joda.time.format.DateTimeParser) (f))
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis)
return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfHour(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfHour(), minDigits, 2)
return appendSignedDecimal(org.joda.time.DateTimeFieldType.centuryOfEra(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.centuryOfEra(), minDigits, maxDigits)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, true, minDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, true, minDigits))
return appendShortText(org.joda.time.DateTimeFieldType.monthOfYear()):return appendShortText(org.joda.time.DateTimeFieldType.monthOfYear())
return append0(null, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(parsers)):return append0(null, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(parsers))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.weekyear(), pivot, lenientParse)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.weekyear(), pivot, lenientParse))
return appendDecimal(org.joda.time.DateTimeFieldType.yearOfCentury(), minDigits, maxDigits):return appendDecimal(org.joda.time.DateTimeFieldType.yearOfCentury(), minDigits, maxDigits)
return new org.joda.time.format.DateTimeFormatter(printer, parser):return new org.joda.time.format.DateTimeFormatter(printer, parser)
return ((org.joda.time.format.DateTimePrinter) (f)):return ((org.joda.time.format.DateTimePrinter) (f))
return appendDecimal(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, 2)
return appendText(org.joda.time.DateTimeFieldType.monthOfYear()):return appendText(org.joda.time.DateTimeFieldType.monthOfYear())
return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfDay(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfDay(), minDigits, 2)
return appendSignedDecimal(org.joda.time.DateTimeFieldType.weekyear(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.weekyear(), minDigits, maxDigits)
return appendText(org.joda.time.DateTimeFieldType.era()):return appendText(org.joda.time.DateTimeFieldType.era())
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfWeek(), minDigits, 1):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfWeek(), minDigits, 1)
return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, 4):return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, 4)
return appendDecimal(org.joda.time.DateTimeFieldType.hourOfHalfday(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.hourOfHalfday(), minDigits, 2)
return appendSignedDecimal(org.joda.time.DateTimeFieldType.year(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.year(), minDigits, maxDigits)
return append0(printer, parsers[0]):return append0(printer, parsers[0])
return f:return f
return append0(new org.joda.time.format.DateTimeFormatterBuilder.Fraction(fieldType, minDigits, maxDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.Fraction(fieldType, minDigits, maxDigits))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, true))
return appendFraction(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, maxDigits)
return iOfYear:return iOfYear
return false:return false
return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear):return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, false))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields))
return appendText(org.joda.time.DateTimeFieldType.dayOfWeek()):return appendText(org.joda.time.DateTimeFieldType.dayOfWeek())
return appendDecimal(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, 5):return appendDecimal(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, 5)
return iSaveMillis:return iSaveMillis
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, 3):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, 3)
return append0(pp, pp):return append0(pp, pp)
return iOfYear.previous(instant, standardOffset, saveMillis):return iOfYear.previous(instant, standardOffset, saveMillis)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, false))
return appendTwoDigitWeekyear(pivot, false):return appendTwoDigitWeekyear(pivot, false)
return isPrinter(getFormatter()):return isPrinter(getFormatter())
return appendText(org.joda.time.DateTimeFieldType.halfdayOfDay()):return appendText(org.joda.time.DateTimeFieldType.halfdayOfDay())
return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, false, minDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, false, minDigits))
return appendDecimal(org.joda.time.DateTimeFieldType.weekOfWeekyear(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.weekOfWeekyear(), minDigits, 2)
return iOfYear.next(instant, standardOffset, saveMillis):return iOfYear.next(instant, standardOffset, saveMillis)
return iNameKey:return iNameKey
return isFormatter(getFormatter()):return isFormatter(getFormatter())
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.SHORT_NAME, null), null):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.SHORT_NAME, null), null)
return appendFraction(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, maxDigits)
return appendDecimal(org.joda.time.DateTimeFieldType.yearOfEra(), minDigits, maxDigits):return appendDecimal(org.joda.time.DateTimeFieldType.yearOfEra(), minDigits, maxDigits)
return append0(printer, null):return append0(printer, null)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral(c)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral(c))
return appendDecimal(org.joda.time.DateTimeFieldType.secondOfMinute(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.secondOfMinute(), minDigits, 2)
return rename((iNameKey + appendNameKey).intern()):return rename((iNameKey + appendNameKey).intern())
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, false))
return isPrinter(f) || isParser(f):return isPrinter(f) || isParser(f)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.year(), pivot, lenientParse)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.year(), pivot, lenientParse))
return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isParser():return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isParser()
return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, true))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.LONG_NAME, null), null):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.LONG_NAME, null), null)
return appendTwoDigitYear(pivot, false):return appendTwoDigitYear(pivot, false)
return appendShortText(org.joda.time.DateTimeFieldType.dayOfWeek()):return appendShortText(org.joda.time.DateTimeFieldType.dayOfWeek())
return this:return this
return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, true))
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfMonth(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfMonth(), minDigits, 2)
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)))):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in))))
return append0(null, parser):return append0(null, parser)
return appendFraction(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, maxDigits)
return appendDecimal(org.joda.time.DateTimeFieldType.monthOfYear(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.monthOfYear(), minDigits, 2)
return isParser(getFormatter()):return isParser(getFormatter())
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields))
return appendFraction(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, maxDigits)
return appendDecimal(org.joda.time.DateTimeFieldType.millisOfSecond(), minDigits, 3):return appendDecimal(org.joda.time.DateTimeFieldType.millisOfSecond(), minDigits, 3)
return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isPrinter():return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isPrinter()
return true:return true
return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfHalfday(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfHalfday(), minDigits, 2)
return append0(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE, org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE):return append0(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE, org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE)
return appendDecimal(org.joda.time.DateTimeFieldType.millisOfDay(), minDigits, 8):return appendDecimal(org.joda.time.DateTimeFieldType.millisOfDay(), minDigits, 8)
return append0(printer, parser):return append0(printer, parser)
return append0(formatter.getPrinter(), formatter.getParser()):return append0(formatter.getPrinter(), formatter.getParser())
return append0(printer, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(copyOfParsers)):return append0(printer, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(copyOfParsers))
return ((org.joda.time.format.DateTimeParser) (f)):return ((org.joda.time.format.DateTimeParser) (f))
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis)
return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfHour(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfHour(), minDigits, 2)
return appendSignedDecimal(org.joda.time.DateTimeFieldType.centuryOfEra(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.centuryOfEra(), minDigits, maxDigits)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, true, minDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, true, minDigits))
return appendShortText(org.joda.time.DateTimeFieldType.monthOfYear()):return appendShortText(org.joda.time.DateTimeFieldType.monthOfYear())
return append0(null, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(parsers)):return append0(null, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(parsers))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.weekyear(), pivot, lenientParse)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.weekyear(), pivot, lenientParse))
return appendDecimal(org.joda.time.DateTimeFieldType.yearOfCentury(), minDigits, maxDigits):return appendDecimal(org.joda.time.DateTimeFieldType.yearOfCentury(), minDigits, maxDigits)
return new org.joda.time.format.DateTimeFormatter(printer, parser):return new org.joda.time.format.DateTimeFormatter(printer, parser)
return ((org.joda.time.format.DateTimePrinter) (f)):return ((org.joda.time.format.DateTimePrinter) (f))
return appendDecimal(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, 2)
return appendText(org.joda.time.DateTimeFieldType.monthOfYear()):return appendText(org.joda.time.DateTimeFieldType.monthOfYear())
return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfDay(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfDay(), minDigits, 2)
return appendSignedDecimal(org.joda.time.DateTimeFieldType.weekyear(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.weekyear(), minDigits, maxDigits)
return appendText(org.joda.time.DateTimeFieldType.era()):return appendText(org.joda.time.DateTimeFieldType.era())
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfWeek(), minDigits, 1):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfWeek(), minDigits, 1)
return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, 4):return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, 4)
return appendDecimal(org.joda.time.DateTimeFieldType.hourOfHalfday(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.hourOfHalfday(), minDigits, 2)
return appendSignedDecimal(org.joda.time.DateTimeFieldType.year(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.year(), minDigits, maxDigits)
return append0(printer, parsers[0]):return append0(printer, parsers[0])
return f:return f
return append0(new org.joda.time.format.DateTimeFormatterBuilder.Fraction(fieldType, minDigits, maxDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.Fraction(fieldType, minDigits, maxDigits))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, true))
return appendFraction(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, maxDigits)
return iOfYear:return iOfYear
return false:return false
return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear):return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, false))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields))
return appendText(org.joda.time.DateTimeFieldType.dayOfWeek()):return appendText(org.joda.time.DateTimeFieldType.dayOfWeek())
return appendDecimal(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, 5):return appendDecimal(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, 5)
return iSaveMillis:return iSaveMillis
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, 3):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, 3)
return append0(pp, pp):return append0(pp, pp)
return iOfYear.previous(instant, standardOffset, saveMillis):return iOfYear.previous(instant, standardOffset, saveMillis)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, false))
return appendTwoDigitWeekyear(pivot, false):return appendTwoDigitWeekyear(pivot, false)
return isPrinter(getFormatter()):return isPrinter(getFormatter())
return appendText(org.joda.time.DateTimeFieldType.halfdayOfDay()):return appendText(org.joda.time.DateTimeFieldType.halfdayOfDay())
return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, false, minDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, false, minDigits))
return appendDecimal(org.joda.time.DateTimeFieldType.weekOfWeekyear(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.weekOfWeekyear(), minDigits, 2)
return iOfYear.next(instant, standardOffset, saveMillis):return iOfYear.next(instant, standardOffset, saveMillis)
return iNameKey:return iNameKey
return isFormatter(getFormatter()):return isFormatter(getFormatter())
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.SHORT_NAME, null), null):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.SHORT_NAME, null), null)
return appendFraction(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, maxDigits)
return appendDecimal(org.joda.time.DateTimeFieldType.yearOfEra(), minDigits, maxDigits):return appendDecimal(org.joda.time.DateTimeFieldType.yearOfEra(), minDigits, maxDigits)
return append0(printer, null):return append0(printer, null)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral(c)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral(c))
return appendDecimal(org.joda.time.DateTimeFieldType.secondOfMinute(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.secondOfMinute(), minDigits, 2)
return rename((iNameKey + appendNameKey).intern()):return rename((iNameKey + appendNameKey).intern())
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, false))
return isPrinter(f) || isParser(f):return isPrinter(f) || isParser(f)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.year(), pivot, lenientParse)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.year(), pivot, lenientParse))
return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isParser():return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isParser()
return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, true))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.LONG_NAME, null), null):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.LONG_NAME, null), null)
return appendTwoDigitYear(pivot, false):return appendTwoDigitYear(pivot, false)
return appendShortText(org.joda.time.DateTimeFieldType.dayOfWeek()):return appendShortText(org.joda.time.DateTimeFieldType.dayOfWeek())
return this:return this
return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, true))
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfMonth(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfMonth(), minDigits, 2)
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)))):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in))))
return appendFraction(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, maxDigits)
return appendDecimal(org.joda.time.DateTimeFieldType.monthOfYear(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.monthOfYear(), minDigits, 2)
switch (c) {
	case 'x' :
		builder.appendTwoDigitWeekyear(
		new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
		break;
	case 'y' :
	case 'Y' :
	default :
		builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
		break;}:switch (c) {
	case 'x' :
		builder.appendTwoDigitWeekyear(
		new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
		break;
	case 'y' :
	case 'Y' :
	default :
		builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
		break;}
return isParser(getFormatter()):return isParser(getFormatter())
org.joda.time.format.DateTimeFormatter formatter = org.joda.time.format.DateTimeFormat.createFormatterForStyle(style):org.joda.time.format.DateTimeFormatter $0 = org.joda.time.format.DateTimeFormat.createFormatterForStyle(style)
if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

		maxDigits = tokenLen;
	}
	indexRef[0]--;
}:if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

		maxDigits = tokenLen;
	}
	indexRef[0]--;
}
org.joda.time.format.DateTimeFormatter formatter = null:org.joda.time.format.DateTimeFormatter $0 = null
int index = ((dateStyle << 2) + dateStyle) + timeStyle:int $0 = ((dateStyle << 2) + dateStyle) + timeStyle
return appendDecimal(org.joda.time.DateTimeFieldType.millisOfSecond(), minDigits, 3):return appendDecimal(org.joda.time.DateTimeFieldType.millisOfSecond(), minDigits, 3)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.SHORT):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.SHORT)
return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isPrinter():return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isPrinter()
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.SHORT):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.SHORT)
return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfHalfday(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfHalfday(), minDigits, 2)
org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern):org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern)
return append0(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE, org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE):return append0(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE, org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE)
return appendDecimal(org.joda.time.DateTimeFieldType.millisOfDay(), minDigits, 8):return appendDecimal(org.joda.time.DateTimeFieldType.millisOfDay(), minDigits, 8)
if (f == null) {
	f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
	org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
}:if (f == null) {
	f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
	org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
}
if (c == '\'') {
	if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

		i++;
		buf.append(c);
	} else {
		inLiteral = !inLiteral;
	}
} else { 	if ((!inLiteral) && 
	(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
		i--;
		break;
	} else {
		buf.append(c);
	}}:if (c == '\'') {
	if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

		i++;
		buf.append(c);
	} else {
		inLiteral = !inLiteral;
	}
} else { 	if ((!inLiteral) && 
	(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
		i--;
		break;
	} else {
		buf.append(c);
	}}
return append0(formatter.getPrinter(), formatter.getParser()):return append0(formatter.getPrinter(), formatter.getParser())
return append0(printer, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(copyOfParsers)):return append0(printer, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(copyOfParsers))
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis)
return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfHour(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfHour(), minDigits, 2)
if (tokenLen >= 4) {
	builder.appendMonthOfYearText();
} else {
	builder.appendMonthOfYearShortText();
}:if (tokenLen >= 4) {
	builder.appendMonthOfYearText();
} else {
	builder.appendMonthOfYearShortText();
}
builder.appendTimeZoneOffset(null, "Z", false, 2, 2):builder.appendTimeZoneOffset(null, "Z", false, 2, 2)
builder.appendTimeZoneOffset(null, "Z", true, 2, 2):builder.appendTimeZoneOffset(null, "Z", true, 2, 2)
return appendSignedDecimal(org.joda.time.DateTimeFieldType.centuryOfEra(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.centuryOfEra(), minDigits, maxDigits)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.MEDIUM):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.MEDIUM)
return append0(null, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(parsers)):return append0(null, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(parsers))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.weekyear(), pivot, lenientParse)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.weekyear(), pivot, lenientParse))
builder.appendMonthOfYearText():builder.appendMonthOfYearText()
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.MEDIUM):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.MEDIUM)
return ((org.joda.time.format.DateTimePrinter) (f)):return ((org.joda.time.format.DateTimePrinter) (f))
return appendDecimal(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, 2)
indexRef[0]--:indexRef[0]--
builder.appendLiteral(new java.lang.String(sub)):builder.appendLiteral(new java.lang.String(sub))
synchronized(org.joda.time.format.DateTimeFormat.PATTERN_CACHE) {
	formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern);
	if (formatter == null) {
		org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder();
		org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern);
		formatter = builder.toFormatter();

		org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
	}
}:synchronized(org.joda.time.format.DateTimeFormat.PATTERN_CACHE) {
	formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern);
	if (formatter == null) {
		org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder();
		org.joda.time.format.DateTimeFormat.parsePatternTo($0, pattern);
		formatter = $0.toFormatter();

		org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
	}
}
return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfDay(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfDay(), minDigits, 2)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.NONE)
if ((pattern == null) || (pattern.length() == 0)) {
	throw new java.lang.IllegalArgumentException("Invalid pattern specification");
}:if ((pattern == null) || (pattern.length() == 0)) {
	throw new java.lang.IllegalArgumentException("Invalid pattern specification");
}
return appendText(org.joda.time.DateTimeFieldType.era()):return appendText(org.joda.time.DateTimeFieldType.era())
formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern):formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern)
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfWeek(), minDigits, 1):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfWeek(), minDigits, 1)
java.lang.String token = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef):java.lang.String $0 = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef)
return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, 4):return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, 4)
char c = pattern.charAt(i):char $0 = pattern.charAt(i)
boolean inLiteral = false:boolean $0 = false
if (peek == c) {
	buf.append(c);
	i++;
} else {
	break;
}:if (peek == c) {
	buf.append(c);
	i++;
} else {
	break;
}
builder.appendLiteral(sub.charAt(0)):builder.appendLiteral(sub.charAt(0))
return appendSignedDecimal(org.joda.time.DateTimeFieldType.year(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.year(), minDigits, maxDigits)
maxDigits = tokenLen:maxDigits = tokenLen
return append0(new org.joda.time.format.DateTimeFormatterBuilder.Fraction(fieldType, minDigits, maxDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.Fraction(fieldType, minDigits, maxDigits))
i = indexRef[0]:i = indexRef[0]
int timeStyle = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(1)):int $0 = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(1))
if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

	maxDigits = tokenLen;
}:if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

	maxDigits = tokenLen;
}
if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



		lenientParse = false;
	}
	indexRef[0]--;
}:if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



		lenientParse = false;
	}
	indexRef[0]--;
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, true))
return appendFraction(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, maxDigits)
return iOfYear:return iOfYear
return false:return false
return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear):return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear)
int maxDigits = 9:int $0 = 9
buf.append(c):buf.append(c)
if (tokenLen > 0) {
	char c = token.charAt(0);
	switch (c) {
		case 'c' :
		case 'C' :
		case 'x' :
		case 'y' :
		case 'Y' :
		case 'd' :
		case 'h' :
		case 'H' :
		case 'm' :
		case 's' :
		case 'S' :
		case 'e' :
		case 'D' :
		case 'F' :
		case 'w' :
		case 'W' :
		case 'k' :
		case 'K' :
			return true;
		case 'M' :
			if (tokenLen <= 2) {
				return true;
			}}

}:if (tokenLen > 0) {
	char $0 = token.charAt(0);
	switch ($0) {
		case 'c' :
		case 'C' :
		case 'x' :
		case 'y' :
		case 'Y' :
		case 'd' :
		case 'h' :
		case 'H' :
		case 'm' :
		case 's' :
		case 'S' :
		case 'e' :
		case 'D' :
		case 'F' :
		case 'w' :
		case 'W' :
		case 'k' :
		case 'K' :
			return true;
		case 'M' :
			if (tokenLen <= 2) {
				return true;
			}}

}
return appendText(org.joda.time.DateTimeFieldType.dayOfWeek()):return appendText(org.joda.time.DateTimeFieldType.dayOfWeek())
return iSaveMillis:return iSaveMillis
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, 3):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, 3)
return append0(pp, pp):return append0(pp, pp)
locale = java.util.Locale.getDefault():locale = java.util.Locale.getDefault()
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.FULL):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.FULL)
return new org.joda.time.format.DateTimeFormatter(llf, llf):return new org.joda.time.format.DateTimeFormatter(llf, llf)
return iOfYear.previous(instant, standardOffset, saveMillis):return iOfYear.previous(instant, standardOffset, saveMillis)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, false))
return isPrinter(getFormatter()):return isPrinter(getFormatter())
return appendText(org.joda.time.DateTimeFieldType.halfdayOfDay()):return appendText(org.joda.time.DateTimeFieldType.halfdayOfDay())
break:break
boolean lenientParse = true:boolean $0 = true
return appendDecimal(org.joda.time.DateTimeFieldType.weekOfWeekyear(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.weekOfWeekyear(), minDigits, 2)
return isFormatter(getFormatter()):return isFormatter(getFormatter())
return append0(printer, null):return append0(printer, null)
return appendDecimal(org.joda.time.DateTimeFieldType.secondOfMinute(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.secondOfMinute(), minDigits, 2)
lenientParse = false:lenientParse = false
switch (c) {
	case 'c' :
	case 'C' :
	case 'x' :
	case 'y' :
	case 'Y' :
	case 'd' :
	case 'h' :
	case 'H' :
	case 'm' :
	case 's' :
	case 'S' :
	case 'e' :
	case 'D' :
	case 'F' :
	case 'w' :
	case 'W' :
	case 'k' :
	case 'K' :
		return true;
	case 'M' :
		if (tokenLen <= 2) {
			return true;
		}}:switch (c) {
	case 'c' :
	case 'C' :
	case 'x' :
	case 'y' :
	case 'Y' :
	case 'd' :
	case 'h' :
	case 'H' :
	case 'm' :
	case 's' :
	case 'S' :
	case 'e' :
	case 'D' :
	case 'F' :
	case 'w' :
	case 'W' :
	case 'k' :
	case 'K' :
		return true;
	case 'M' :
		if (tokenLen <= 2) {
			return true;
		}}
java.lang.StringBuilder buf = new java.lang.StringBuilder():java.lang.StringBuilder $0 = new java.lang.StringBuilder()
if ((dateStyle == org.joda.time.format.DateTimeFormat.NONE) && (timeStyle == org.joda.time.format.DateTimeFormat.NONE)) {
	throw new java.lang.IllegalArgumentException("Style '--' is invalid");
}:if ((dateStyle == org.joda.time.format.DateTimeFormat.NONE) && (timeStyle == org.joda.time.format.DateTimeFormat.NONE)) {
	throw new java.lang.IllegalArgumentException("Style '--' is invalid");
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.year(), pivot, lenientParse)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.year(), pivot, lenientParse))
char c = token.charAt(0):char $0 = token.charAt(0)
return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isParser():return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isParser()
if (formatter == null) {
	org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder();
	org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern);
	formatter = builder.toFormatter();

	org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
}:if (formatter == null) {
	org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder();
	org.joda.time.format.DateTimeFormat.parsePatternTo($0, pattern);
	formatter = $0.toFormatter();

	org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
}
int type = org.joda.time.format.DateTimeFormat.DATETIME:int $0 = org.joda.time.format.DateTimeFormat.DATETIME
return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, true))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.LONG_NAME, null), null):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.LONG_NAME, null), null)
return appendTwoDigitYear(pivot, false):return appendTwoDigitYear(pivot, false)
c = pattern.charAt(i):c = pattern.charAt(i)
for (; i < length; i++) {
	c = pattern.charAt(i);

	if (c == '\'') {
		if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

			i++;
			buf.append(c);
		} else {
			inLiteral = !inLiteral;
		}
	} else { 		if ((!inLiteral) && 
		(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
			i--;
			break;
		} else {
			buf.append(c);
		}}
}:for (; i < length; i++) {
	c = pattern.charAt(i);

	if (c == '\'') {
		if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

			i++;
			buf.append(c);
		} else {
			inLiteral = !inLiteral;
		}
	} else { 		if ((!inLiteral) && 
		(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
			i--;
			break;
		} else {
			buf.append(c);
		}}
}
throw new java.lang.IllegalArgumentException("Invalid style specification: " + style):throw new java.lang.IllegalArgumentException("Invalid style specification: " + style)
return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle):return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle)
return this:return this
f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle):f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle)
builder.appendTimeZoneShortName(null):builder.appendTimeZoneShortName(null)
return append0(null, parser):return append0(null, parser)
indexRef[0] = i:indexRef[0] = i
org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter):org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter)
if (index >= org.joda.time.format.DateTimeFormat.STYLE_CACHE.length) {
	return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
}:if (index >= org.joda.time.format.DateTimeFormat.STYLE_CACHE.length) {
	return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields))
return appendFraction(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, maxDigits)
i++:i++
return true:return true
builder.appendTimeZoneName():builder.appendTimeZoneName()
return ((org.joda.time.format.DateTimeFormat.StyleFormatter) (formatter.getPrinter())).getPattern(locale):return ((org.joda.time.format.DateTimeFormat.StyleFormatter) (formatter.getPrinter())).getPattern(locale)
return org.joda.time.format.DateTimeFormat.createFormatterForStyle(style):return org.joda.time.format.DateTimeFormat.createFormatterForStyle(style)
throw new java.lang.IllegalArgumentException("Invalid pattern specification"):throw new java.lang.IllegalArgumentException("Invalid pattern specification")
return append0(printer, parser):return append0(printer, parser)
if (locale == null) {
	locale = java.util.Locale.getDefault();
}:if (locale == null) {
	locale = java.util.Locale.getDefault();
}
if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



	lenientParse = false;
}:if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



	lenientParse = false;
}
throw new java.lang.IllegalArgumentException("Style '--' is invalid"):throw new java.lang.IllegalArgumentException("Style '--' is invalid")
if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.DATE;
}:if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.DATE;
}
type = org.joda.time.format.DateTimeFormat.DATE:type = org.joda.time.format.DateTimeFormat.DATE
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.NONE)
switch (ch) {
	case 'S' :
		return org.joda.time.format.DateTimeFormat.SHORT;
	case 'M' :
		return org.joda.time.format.DateTimeFormat.MEDIUM;
	case 'L' :
		return org.joda.time.format.DateTimeFormat.LONG;
	case 'F' :
		return org.joda.time.format.DateTimeFormat.FULL;
	case '-' :
		return org.joda.time.format.DateTimeFormat.NONE;
	default :
		throw new java.lang.IllegalArgumentException("Invalid style character: " + ch);}:switch (ch) {
	case 'S' :
		return org.joda.time.format.DateTimeFormat.SHORT;
	case 'M' :
		return org.joda.time.format.DateTimeFormat.MEDIUM;
	case 'L' :
		return org.joda.time.format.DateTimeFormat.LONG;
	case 'F' :
		return org.joda.time.format.DateTimeFormat.FULL;
	case '-' :
		return org.joda.time.format.DateTimeFormat.NONE;
	default :
		throw new java.lang.IllegalArgumentException("Invalid style character: " + ch);}
return ((org.joda.time.format.DateTimeParser) (f)):return ((org.joda.time.format.DateTimeParser) (f))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, true, minDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, true, minDigits))
return appendShortText(org.joda.time.DateTimeFieldType.monthOfYear()):return appendShortText(org.joda.time.DateTimeFieldType.monthOfYear())
return formatter:return formatter
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(dateStyle, timeStyle):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(dateStyle, timeStyle)
org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f:org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f
switch (c) {
	case 'x' :
		builder.appendWeekyear(tokenLen, maxDigits);
		break;
	case 'y' :
		builder.appendYear(tokenLen, maxDigits);
		break;
	case 'Y' :
		builder.appendYearOfEra(tokenLen, maxDigits);
		break;}:switch (c) {
	case 'x' :
		builder.appendWeekyear(tokenLen, maxDigits);
		break;
	case 'y' :
		builder.appendYear(tokenLen, maxDigits);
		break;
	case 'Y' :
		builder.appendYearOfEra(tokenLen, maxDigits);
		break;}
return appendDecimal(org.joda.time.DateTimeFieldType.yearOfCentury(), minDigits, maxDigits):return appendDecimal(org.joda.time.DateTimeFieldType.yearOfCentury(), minDigits, maxDigits)
return new org.joda.time.format.DateTimeFormatter(printer, parser):return new org.joda.time.format.DateTimeFormatter(printer, parser)
return buf.toString():return buf.toString()
return appendText(org.joda.time.DateTimeFieldType.monthOfYear()):return appendText(org.joda.time.DateTimeFieldType.monthOfYear())
type = org.joda.time.format.DateTimeFormat.TIME:type = org.joda.time.format.DateTimeFormat.TIME
if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

	i++;
	buf.append(c);
} else {
	inLiteral = !inLiteral;
}:if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

	i++;
	buf.append(c);
} else {
	inLiteral = !inLiteral;
}
return appendSignedDecimal(org.joda.time.DateTimeFieldType.weekyear(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.weekyear(), minDigits, maxDigits)
builder.appendDayOfWeekText():builder.appendDayOfWeekText()
while ((i + 1) < length) {
	char peek = pattern.charAt(i + 1);
	if (peek == c) {
		buf.append(c);
		i++;
	} else {
		break;
	}
} :while ((i + 1) < length) {
	char $0 = pattern.charAt(i + 1);
	if ($0 == c) {
		buf.append(c);
		i++;
	} else {
		break;
	}
} 
f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index]:f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index]
return appendDecimal(org.joda.time.DateTimeFieldType.hourOfHalfday(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.hourOfHalfday(), minDigits, 2)
return append0(printer, parsers[0]):return append0(printer, parsers[0])
return f:return f
if (dateStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.TIME;
} else { 	if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
		type = org.joda.time.format.DateTimeFormat.DATE;
	}}:if (dateStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.TIME;
} else { 	if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
		type = org.joda.time.format.DateTimeFormat.DATE;
	}}
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.NONE)
i--:i--
formatter = builder.toFormatter():formatter = builder.toFormatter()
builder.appendMonthOfYear(tokenLen):builder.appendMonthOfYear(tokenLen)
return org.joda.time.format.DateTimeFormat.createFormatterForPattern(pattern):return org.joda.time.format.DateTimeFormat.createFormatterForPattern(pattern)
int i = indexRef[0]:int $0 = indexRef[0]
return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, false))
builder.appendTimeZoneId():builder.appendTimeZoneId()
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields))
char peek = pattern.charAt(i + 1):char $0 = pattern.charAt(i + 1)
int[] indexRef = new int[1]:int[] $0 = new int[1]
builder.appendMonthOfYearShortText():builder.appendMonthOfYearShortText()
for (int i = 0; i < length; i++) {
	indexRef[0] = i;
	java.lang.String token = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef);
	i = indexRef[0];

	int tokenLen = token.length();
	if (tokenLen == 0) {
		break;
	}
	char c = token.charAt(0);

	switch (c) {
		case 'G' :
			builder.appendEraText();
			break;
		case 'C' :
			builder.appendCenturyOfEra(tokenLen, tokenLen);
			break;
		case 'x' :
		case 'y' :
		case 'Y' :
			if (tokenLen == 2) {
				boolean lenientParse = true;


				if ((i + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



						lenientParse = false;
					}
					indexRef[0]--;
				}


				switch (c) {
					case 'x' :
						builder.appendTwoDigitWeekyear(
						new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
						break;
					case 'y' :
					case 'Y' :
					default :
						builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
						break;}

			} else {

				int maxDigits = 9;


				if ((i + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

						maxDigits = tokenLen;
					}
					indexRef[0]--;
				}

				switch (c) {
					case 'x' :
						builder.appendWeekyear(tokenLen, maxDigits);
						break;
					case 'y' :
						builder.appendYear(tokenLen, maxDigits);
						break;
					case 'Y' :
						builder.appendYearOfEra(tokenLen, maxDigits);
						break;}

			}
			break;
		case 'M' :
			if (tokenLen >= 3) {
				if (tokenLen >= 4) {
					builder.appendMonthOfYearText();
				} else {
					builder.appendMonthOfYearShortText();
				}
			} else {
				builder.appendMonthOfYear(tokenLen);
			}
			break;
		case 'd' :
			builder.appendDayOfMonth(tokenLen);
			break;
		case 'a' :
			builder.appendHalfdayOfDayText();
			break;
		case 'h' :
			builder.appendClockhourOfHalfday(tokenLen);
			break;
		case 'H' :
			builder.appendHourOfDay(tokenLen);
			break;
		case 'k' :
			builder.appendClockhourOfDay(tokenLen);
			break;
		case 'K' :
			builder.appendHourOfHalfday(tokenLen);
			break;
		case 'm' :
			builder.appendMinuteOfHour(tokenLen);
			break;
		case 's' :
			builder.appendSecondOfMinute(tokenLen);
			break;
		case 'S' :
			builder.appendFractionOfSecond(tokenLen, tokenLen);
			break;
		case 'e' :
			builder.appendDayOfWeek(tokenLen);
			break;
		case 'E' :
			if (tokenLen >= 4) {
				builder.appendDayOfWeekText();
			} else {
				builder.appendDayOfWeekShortText();
			}
			break;
		case 'D' :
			builder.appendDayOfYear(tokenLen);
			break;
		case 'w' :
			builder.appendWeekOfWeekyear(tokenLen);
			break;
		case 'z' :
			if (tokenLen >= 4) {
				builder.appendTimeZoneName();
			} else {
				builder.appendTimeZoneShortName(null);
			}
			break;
		case 'Z' :
			if (tokenLen == 1) {
				builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
			} else { 				if (tokenLen == 2) {
					builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
				} else {
					builder.appendTimeZoneId();
				}}
			break;
		case '\'' :
			java.lang.String sub = token.substring(1);
			if (sub.length() == 1) {
				builder.appendLiteral(sub.charAt(0));
			} else {


				builder.appendLiteral(new java.lang.String(sub));
			}
			break;
		default :
			throw new java.lang.IllegalArgumentException(
			"Illegal pattern component: " + token);}

}:for (int $0 = 0; $0 < length; $0++) {
	indexRef[0] = $0;
	java.lang.String $1 = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef);
	$0 = indexRef[0];

	int $2 = $1.length();
	if ($2 == 0) {
		break;
	}
	char $3 = $1.charAt(0);

	switch ($3) {
		case 'G' :
			builder.appendEraText();
			break;
		case 'C' :
			builder.appendCenturyOfEra($2, $2);
			break;
		case 'x' :
		case 'y' :
		case 'Y' :
			if ($2 == 2) {
				boolean $4 = true;


				if (($0 + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



						$4 = false;
					}
					indexRef[0]--;
				}


				switch ($3) {
					case 'x' :
						builder.appendTwoDigitWeekyear(
						new org.joda.time.DateTime().getWeekyear() - 30, $4);
						break;
					case 'y' :
					case 'Y' :
					default :
						builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, $4);
						break;}

			} else {

				int $5 = 9;


				if (($0 + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

						$5 = $2;
					}
					indexRef[0]--;
				}

				switch ($3) {
					case 'x' :
						builder.appendWeekyear($2, $5);
						break;
					case 'y' :
						builder.appendYear($2, $5);
						break;
					case 'Y' :
						builder.appendYearOfEra($2, $5);
						break;}

			}
			break;
		case 'M' :
			if ($2 >= 3) {
				if ($2 >= 4) {
					builder.appendMonthOfYearText();
				} else {
					builder.appendMonthOfYearShortText();
				}
			} else {
				builder.appendMonthOfYear($2);
			}
			break;
		case 'd' :
			builder.appendDayOfMonth($2);
			break;
		case 'a' :
			builder.appendHalfdayOfDayText();
			break;
		case 'h' :
			builder.appendClockhourOfHalfday($2);
			break;
		case 'H' :
			builder.appendHourOfDay($2);
			break;
		case 'k' :
			builder.appendClockhourOfDay($2);
			break;
		case 'K' :
			builder.appendHourOfHalfday($2);
			break;
		case 'm' :
			builder.appendMinuteOfHour($2);
			break;
		case 's' :
			builder.appendSecondOfMinute($2);
			break;
		case 'S' :
			builder.appendFractionOfSecond($2, $2);
			break;
		case 'e' :
			builder.appendDayOfWeek($2);
			break;
		case 'E' :
			if ($2 >= 4) {
				builder.appendDayOfWeekText();
			} else {
				builder.appendDayOfWeekShortText();
			}
			break;
		case 'D' :
			builder.appendDayOfYear($2);
			break;
		case 'w' :
			builder.appendWeekOfWeekyear($2);
			break;
		case 'z' :
			if ($2 >= 4) {
				builder.appendTimeZoneName();
			} else {
				builder.appendTimeZoneShortName(null);
			}
			break;
		case 'Z' :
			if ($2 == 1) {
				builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
			} else { 				if ($2 == 2) {
					builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
				} else {
					builder.appendTimeZoneId();
				}}
			break;
		case '\'' :
			java.lang.String $6 = $1.substring(1);
			if ($6.length() == 1) {
				builder.appendLiteral($6.charAt(0));
			} else {


				builder.appendLiteral(new java.lang.String($6));
			}
			break;
		default :
			throw new java.lang.IllegalArgumentException(
			"Illegal pattern component: " + $1);}

}
inLiteral = !inLiteral:inLiteral = !inLiteral
return appendDecimal(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, 5):return appendDecimal(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, 5)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.FULL):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.FULL)
if ((style == null) || (style.length() != 2)) {
	throw new java.lang.IllegalArgumentException("Invalid style specification: " + style);
}:if ((style == null) || (style.length() != 2)) {
	throw new java.lang.IllegalArgumentException("Invalid style specification: " + style);
}
org.joda.time.format.DateTimeFormatter f = null:org.joda.time.format.DateTimeFormatter $0 = null
switch (c) {
	case 'G' :
		builder.appendEraText();
		break;
	case 'C' :
		builder.appendCenturyOfEra(tokenLen, tokenLen);
		break;
	case 'x' :
	case 'y' :
	case 'Y' :
		if (tokenLen == 2) {
			boolean lenientParse = true;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



					lenientParse = false;
				}
				indexRef[0]--;
			}


			switch (c) {
				case 'x' :
					builder.appendTwoDigitWeekyear(
					new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
					break;
				case 'y' :
				case 'Y' :
				default :
					builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
					break;}

		} else {

			int maxDigits = 9;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

					maxDigits = tokenLen;
				}
				indexRef[0]--;
			}

			switch (c) {
				case 'x' :
					builder.appendWeekyear(tokenLen, maxDigits);
					break;
				case 'y' :
					builder.appendYear(tokenLen, maxDigits);
					break;
				case 'Y' :
					builder.appendYearOfEra(tokenLen, maxDigits);
					break;}

		}
		break;
	case 'M' :
		if (tokenLen >= 3) {
			if (tokenLen >= 4) {
				builder.appendMonthOfYearText();
			} else {
				builder.appendMonthOfYearShortText();
			}
		} else {
			builder.appendMonthOfYear(tokenLen);
		}
		break;
	case 'd' :
		builder.appendDayOfMonth(tokenLen);
		break;
	case 'a' :
		builder.appendHalfdayOfDayText();
		break;
	case 'h' :
		builder.appendClockhourOfHalfday(tokenLen);
		break;
	case 'H' :
		builder.appendHourOfDay(tokenLen);
		break;
	case 'k' :
		builder.appendClockhourOfDay(tokenLen);
		break;
	case 'K' :
		builder.appendHourOfHalfday(tokenLen);
		break;
	case 'm' :
		builder.appendMinuteOfHour(tokenLen);
		break;
	case 's' :
		builder.appendSecondOfMinute(tokenLen);
		break;
	case 'S' :
		builder.appendFractionOfSecond(tokenLen, tokenLen);
		break;
	case 'e' :
		builder.appendDayOfWeek(tokenLen);
		break;
	case 'E' :
		if (tokenLen >= 4) {
			builder.appendDayOfWeekText();
		} else {
			builder.appendDayOfWeekShortText();
		}
		break;
	case 'D' :
		builder.appendDayOfYear(tokenLen);
		break;
	case 'w' :
		builder.appendWeekOfWeekyear(tokenLen);
		break;
	case 'z' :
		if (tokenLen >= 4) {
			builder.appendTimeZoneName();
		} else {
			builder.appendTimeZoneShortName(null);
		}
		break;
	case 'Z' :
		if (tokenLen == 1) {
			builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
		} else { 			if (tokenLen == 2) {
				builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
			} else {
				builder.appendTimeZoneId();
			}}
		break;
	case '\'' :
		java.lang.String sub = token.substring(1);
		if (sub.length() == 1) {
			builder.appendLiteral(sub.charAt(0));
		} else {


			builder.appendLiteral(new java.lang.String(sub));
		}
		break;
	default :
		throw new java.lang.IllegalArgumentException(
		"Illegal pattern component: " + token);}:switch (c) {
	case 'G' :
		builder.appendEraText();
		break;
	case 'C' :
		builder.appendCenturyOfEra(tokenLen, tokenLen);
		break;
	case 'x' :
	case 'y' :
	case 'Y' :
		if (tokenLen == 2) {
			boolean $0 = true;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



					$0 = false;
				}
				indexRef[0]--;
			}


			switch (c) {
				case 'x' :
					builder.appendTwoDigitWeekyear(
					new org.joda.time.DateTime().getWeekyear() - 30, $0);
					break;
				case 'y' :
				case 'Y' :
				default :
					builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, $0);
					break;}

		} else {

			int $1 = 9;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

					$1 = tokenLen;
				}
				indexRef[0]--;
			}

			switch (c) {
				case 'x' :
					builder.appendWeekyear(tokenLen, $1);
					break;
				case 'y' :
					builder.appendYear(tokenLen, $1);
					break;
				case 'Y' :
					builder.appendYearOfEra(tokenLen, $1);
					break;}

		}
		break;
	case 'M' :
		if (tokenLen >= 3) {
			if (tokenLen >= 4) {
				builder.appendMonthOfYearText();
			} else {
				builder.appendMonthOfYearShortText();
			}
		} else {
			builder.appendMonthOfYear(tokenLen);
		}
		break;
	case 'd' :
		builder.appendDayOfMonth(tokenLen);
		break;
	case 'a' :
		builder.appendHalfdayOfDayText();
		break;
	case 'h' :
		builder.appendClockhourOfHalfday(tokenLen);
		break;
	case 'H' :
		builder.appendHourOfDay(tokenLen);
		break;
	case 'k' :
		builder.appendClockhourOfDay(tokenLen);
		break;
	case 'K' :
		builder.appendHourOfHalfday(tokenLen);
		break;
	case 'm' :
		builder.appendMinuteOfHour(tokenLen);
		break;
	case 's' :
		builder.appendSecondOfMinute(tokenLen);
		break;
	case 'S' :
		builder.appendFractionOfSecond(tokenLen, tokenLen);
		break;
	case 'e' :
		builder.appendDayOfWeek(tokenLen);
		break;
	case 'E' :
		if (tokenLen >= 4) {
			builder.appendDayOfWeekText();
		} else {
			builder.appendDayOfWeekShortText();
		}
		break;
	case 'D' :
		builder.appendDayOfYear(tokenLen);
		break;
	case 'w' :
		builder.appendWeekOfWeekyear(tokenLen);
		break;
	case 'z' :
		if (tokenLen >= 4) {
			builder.appendTimeZoneName();
		} else {
			builder.appendTimeZoneShortName(null);
		}
		break;
	case 'Z' :
		if (tokenLen == 1) {
			builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
		} else { 			if (tokenLen == 2) {
				builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
			} else {
				builder.appendTimeZoneId();
			}}
		break;
	case '\'' :
		java.lang.String $2 = token.substring(1);
		if ($2.length() == 1) {
			builder.appendLiteral($2.charAt(0));
		} else {


			builder.appendLiteral(new java.lang.String($2));
		}
		break;
	default :
		throw new java.lang.IllegalArgumentException(
		"Illegal pattern component: " + token);}
int tokenLen = token.length():int $0 = token.length()
if (((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) {


	buf.append(c);

	while ((i + 1) < length) {
		char peek = pattern.charAt(i + 1);
		if (peek == c) {
			buf.append(c);
			i++;
		} else {
			break;
		}
	} 
} else {

	buf.append('\'');

	boolean inLiteral = false;

	for (; i < length; i++) {
		c = pattern.charAt(i);

		if (c == '\'') {
			if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

				i++;
				buf.append(c);
			} else {
				inLiteral = !inLiteral;
			}
		} else { 			if ((!inLiteral) && 
			(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
				i--;
				break;
			} else {
				buf.append(c);
			}}
	}
}:if (((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) {


	buf.append(c);

	while ((i + 1) < length) {
		char $0 = pattern.charAt(i + 1);
		if ($0 == c) {
			buf.append(c);
			i++;
		} else {
			break;
		}
	} 
} else {

	buf.append('\'');

	boolean $1 = false;

	for (; i < length; i++) {
		c = pattern.charAt(i);

		if (c == '\'') {
			if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

				i++;
				buf.append(c);
			} else {
				$1 = !$1;
			}
		} else { 			if ((!$1) && 
			(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
				i--;
				break;
			} else {
				buf.append(c);
			}}
	}
}
org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder():org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder()
synchronized(org.joda.time.format.DateTimeFormat.STYLE_CACHE) {
	f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index];
	if (f == null) {
		f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
		org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
	}
}:synchronized(org.joda.time.format.DateTimeFormat.STYLE_CACHE) {
	f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index];
	if (f == null) {
		f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
		org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
	}
}
return appendTwoDigitWeekyear(pivot, false):return appendTwoDigitWeekyear(pivot, false)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, false, minDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, false, minDigits))
int length = pattern.length():int $0 = pattern.length()
buf.append('\''):buf.append('\'')
return iOfYear.next(instant, standardOffset, saveMillis):return iOfYear.next(instant, standardOffset, saveMillis)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.NONE)
org.joda.time.format.DateTimeFormat.StyleFormatter llf = new org.joda.time.format.DateTimeFormat.StyleFormatter(dateStyle, timeStyle, type):org.joda.time.format.DateTimeFormat.StyleFormatter $0 = new org.joda.time.format.DateTimeFormat.StyleFormatter(dateStyle, timeStyle, type)
return iNameKey:return iNameKey
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.SHORT_NAME, null), null):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.SHORT_NAME, null), null)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.LONG):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.LONG)
return appendFraction(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, maxDigits)
builder.appendDayOfWeekShortText():builder.appendDayOfWeekShortText()
return appendDecimal(org.joda.time.DateTimeFieldType.yearOfEra(), minDigits, maxDigits):return appendDecimal(org.joda.time.DateTimeFieldType.yearOfEra(), minDigits, maxDigits)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral(c)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral(c))
return rename((iNameKey + appendNameKey).intern()):return rename((iNameKey + appendNameKey).intern())
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, false))
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.LONG):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.LONG)
if (tokenLen == 2) {
	builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
} else {
	builder.appendTimeZoneId();
}:if (tokenLen == 2) {
	builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
} else {
	builder.appendTimeZoneId();
}
if ((!inLiteral) && 
(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
	i--;
	break;
} else {
	buf.append(c);
}:if ((!inLiteral) && 
(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
	i--;
	break;
} else {
	buf.append(c);
}
indexRef[0]++:indexRef[0]++
int dateStyle = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(0)):int $0 = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(0))
return isPrinter(f) || isParser(f):return isPrinter(f) || isParser(f)
if (tokenLen == 0) {
	break;
}:if (tokenLen == 0) {
	break;
}
return appendShortText(org.joda.time.DateTimeFieldType.dayOfWeek()):return appendShortText(org.joda.time.DateTimeFieldType.dayOfWeek())
return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, true))
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfMonth(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfMonth(), minDigits, 2)
if (setEn[2].equals(setEn[4])) {
	byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
} else {
	byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
}:if (setEn[2].equals(setEn[4])) {
	byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
} else {
	byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
}
return appendFraction(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, maxDigits)
return isParser(getFormatter()):return isParser(getFormatter())
org.joda.time.format.DateTimeFormatter formatter = org.joda.time.format.DateTimeFormat.createFormatterForStyle(style):org.joda.time.format.DateTimeFormatter $0 = org.joda.time.format.DateTimeFormat.createFormatterForStyle(style)
if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

		maxDigits = tokenLen;
	}
	indexRef[0]--;
}:if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

		maxDigits = tokenLen;
	}
	indexRef[0]--;
}
org.joda.time.format.DateTimeFormatter formatter = null:org.joda.time.format.DateTimeFormatter $0 = null
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.SHORT):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.SHORT)
org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern):org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern)
return append0(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE, org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE):return append0(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE, org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE)
if (f == null) {
	f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
	org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
}:if (f == null) {
	f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
	org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
}
return append0(formatter.getPrinter(), formatter.getParser()):return append0(formatter.getPrinter(), formatter.getParser())
return append0(printer, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(copyOfParsers)):return append0(printer, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(copyOfParsers))
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis)
return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfHour(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfHour(), minDigits, 2)
if (tokenLen >= 4) {
	builder.appendMonthOfYearText();
} else {
	builder.appendMonthOfYearShortText();
}:if (tokenLen >= 4) {
	builder.appendMonthOfYearText();
} else {
	builder.appendMonthOfYearShortText();
}
builder.appendTimeZoneOffset(null, "Z", true, 2, 2):builder.appendTimeZoneOffset(null, "Z", true, 2, 2)
return appendSignedDecimal(org.joda.time.DateTimeFieldType.centuryOfEra(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.centuryOfEra(), minDigits, maxDigits)
return append0(null, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(parsers)):return append0(null, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(parsers))
builder.appendMonthOfYearText():builder.appendMonthOfYearText()
return ((org.joda.time.format.DateTimePrinter) (f)):return ((org.joda.time.format.DateTimePrinter) (f))
return appendDecimal(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, 2)
builder.appendLiteral(new java.lang.String(sub)):builder.appendLiteral(new java.lang.String(sub))
synchronized(org.joda.time.format.DateTimeFormat.PATTERN_CACHE) {
	formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern);
	if (formatter == null) {
		org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder();
		org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern);
		formatter = builder.toFormatter();

		org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
	}
}:synchronized(org.joda.time.format.DateTimeFormat.PATTERN_CACHE) {
	formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern);
	if (formatter == null) {
		org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder();
		org.joda.time.format.DateTimeFormat.parsePatternTo($0, pattern);
		formatter = $0.toFormatter();

		org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
	}
}
return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfDay(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfDay(), minDigits, 2)
return appendText(org.joda.time.DateTimeFieldType.era()):return appendText(org.joda.time.DateTimeFieldType.era())
java.lang.String token = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef):java.lang.String $0 = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef)
char c = pattern.charAt(i):char $0 = pattern.charAt(i)
boolean inLiteral = false:boolean $0 = false
maxDigits = tokenLen:maxDigits = tokenLen
return append0(new org.joda.time.format.DateTimeFormatterBuilder.Fraction(fieldType, minDigits, maxDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.Fraction(fieldType, minDigits, maxDigits))
if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



		lenientParse = false;
	}
	indexRef[0]--;
}:if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



		lenientParse = false;
	}
	indexRef[0]--;
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, true))
return appendFraction(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, maxDigits)
return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear):return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear)
int maxDigits = 9:int $0 = 9
return appendText(org.joda.time.DateTimeFieldType.dayOfWeek()):return appendText(org.joda.time.DateTimeFieldType.dayOfWeek())
return iSaveMillis:return iSaveMillis
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, 3):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, 3)
if (byIdCache == null) {
	iByLocaleCache.put(locale, byIdCache = createCache());
}:if (byIdCache == null) {
	iByLocaleCache.put(locale, byIdCache = createCache());
}
locale = java.util.Locale.getDefault():locale = java.util.Locale.getDefault()
return new org.joda.time.format.DateTimeFormatter(llf, llf):return new org.joda.time.format.DateTimeFormatter(llf, llf)
return iOfYear.previous(instant, standardOffset, saveMillis):return iOfYear.previous(instant, standardOffset, saveMillis)
return isPrinter(getFormatter()):return isPrinter(getFormatter())
return appendDecimal(org.joda.time.DateTimeFieldType.weekOfWeekyear(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.weekOfWeekyear(), minDigits, 2)
return isFormatter(getFormatter()):return isFormatter(getFormatter())
return append0(printer, null):return append0(printer, null)
lenientParse = false:lenientParse = false
java.lang.StringBuilder buf = new java.lang.StringBuilder():java.lang.StringBuilder $0 = new java.lang.StringBuilder()
char c = token.charAt(0):char $0 = token.charAt(0)
return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isParser():return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isParser()
if (formatter == null) {
	org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder();
	org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern);
	formatter = builder.toFormatter();

	org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
}:if (formatter == null) {
	org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder();
	org.joda.time.format.DateTimeFormat.parsePatternTo($0, pattern);
	formatter = $0.toFormatter();

	org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
}
c = pattern.charAt(i):c = pattern.charAt(i)
for (; i < length; i++) {
	c = pattern.charAt(i);

	if (c == '\'') {
		if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

			i++;
			buf.append(c);
		} else {
			inLiteral = !inLiteral;
		}
	} else { 		if ((!inLiteral) && 
		(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
			i--;
			break;
		} else {
			buf.append(c);
		}}
}:for (; i < length; i++) {
	c = pattern.charAt(i);

	if (c == '\'') {
		if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

			i++;
			buf.append(c);
		} else {
			inLiteral = !inLiteral;
		}
	} else { 		if ((!inLiteral) && 
		(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
			i--;
			break;
		} else {
			buf.append(c);
		}}
}
return this:return this
f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle):f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle)
builder.appendTimeZoneShortName(null):builder.appendTimeZoneShortName(null)
return append0(null, parser):return append0(null, parser)
org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter):org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter)
if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setLoc = strings;
	break;
}:if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setLoc = strings;
	break;
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields))
builder.appendTimeZoneName():builder.appendTimeZoneName()
return append0(printer, parser):return append0(printer, parser)
switch (ch) {
	case 'S' :
		return org.joda.time.format.DateTimeFormat.SHORT;
	case 'M' :
		return org.joda.time.format.DateTimeFormat.MEDIUM;
	case 'L' :
		return org.joda.time.format.DateTimeFormat.LONG;
	case 'F' :
		return org.joda.time.format.DateTimeFormat.FULL;
	case '-' :
		return org.joda.time.format.DateTimeFormat.NONE;
	default :
		throw new java.lang.IllegalArgumentException("Invalid style character: " + ch);}:switch (ch) {
	case 'S' :
		return org.joda.time.format.DateTimeFormat.SHORT;
	case 'M' :
		return org.joda.time.format.DateTimeFormat.MEDIUM;
	case 'L' :
		return org.joda.time.format.DateTimeFormat.LONG;
	case 'F' :
		return org.joda.time.format.DateTimeFormat.FULL;
	case '-' :
		return org.joda.time.format.DateTimeFormat.NONE;
	default :
		throw new java.lang.IllegalArgumentException("Invalid style character: " + ch);}
return appendShortText(org.joda.time.DateTimeFieldType.monthOfYear()):return appendShortText(org.joda.time.DateTimeFieldType.monthOfYear())
return formatter:return formatter
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(dateStyle, timeStyle):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(dateStyle, timeStyle)
org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f:org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f
return buf.toString():return buf.toString()
type = org.joda.time.format.DateTimeFormat.TIME:type = org.joda.time.format.DateTimeFormat.TIME
if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

	i++;
	buf.append(c);
} else {
	inLiteral = !inLiteral;
}:if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

	i++;
	buf.append(c);
} else {
	inLiteral = !inLiteral;
}
return appendSignedDecimal(org.joda.time.DateTimeFieldType.weekyear(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.weekyear(), minDigits, maxDigits)
f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index]:f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index]
return appendDecimal(org.joda.time.DateTimeFieldType.hourOfHalfday(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.hourOfHalfday(), minDigits, 2)
return append0(printer, parsers[0]):return append0(printer, parsers[0])
return f:return f
formatter = builder.toFormatter():formatter = builder.toFormatter()
int i = indexRef[0]:int $0 = indexRef[0]
if (byNameKeyCache == null) {
	byIdCache.put(id, byNameKeyCache = createCache());

	java.lang.String[][] zoneStringsEn = org.joda.time.DateTimeUtils.getDateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings();
	java.lang.String[] setEn = null;
	for (java.lang.String[] strings : zoneStringsEn) {
		if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
			setEn = strings;
			break;
		}
	}
	java.lang.String[][] zoneStringsLoc = org.joda.time.DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
	java.lang.String[] setLoc = null;
	for (java.lang.String[] strings : zoneStringsLoc) {
		if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
			setLoc = strings;
			break;
		}
	}

	if ((setEn != null) && (setLoc != null)) {
		byNameKeyCache.put(setEn[2], new java.lang.String[]{ setLoc[2], setLoc[1] });



		if (setEn[2].equals(setEn[4])) {
			byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
		} else {
			byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
		}
	}
}:if (byNameKeyCache == null) {
	byIdCache.put(id, byNameKeyCache = createCache());

	java.lang.String[][] $0 = org.joda.time.DateTimeUtils.getDateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings();
	java.lang.String[] $1 = null;
	for (java.lang.String[] $2 : $0) {
		if ((($2 != null) && ($2.length == 5)) && id.equals($2[0])) {
			$1 = $2;
			break;
		}
	}
	java.lang.String[][] $3 = org.joda.time.DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
	java.lang.String[] $4 = null;
	for (java.lang.String[] $5 : $3) {
		if ((($5 != null) && ($5.length == 5)) && id.equals($5[0])) {
			$4 = $5;
			break;
		}
	}

	if (($1 != null) && ($4 != null)) {
		byNameKeyCache.put($1[2], new java.lang.String[]{ $4[2], $4[1] });



		if ($1[2].equals($1[4])) {
			byNameKeyCache.put($1[4] + "-Summer", new java.lang.String[]{ $4[4], $4[3] });
		} else {
			byNameKeyCache.put($1[4], new java.lang.String[]{ $4[4], $4[3] });
		}
	}
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, false))
builder.appendTimeZoneId():builder.appendTimeZoneId()
char peek = pattern.charAt(i + 1):char $0 = pattern.charAt(i + 1)
inLiteral = !inLiteral:inLiteral = !inLiteral
org.joda.time.format.DateTimeFormatter f = null:org.joda.time.format.DateTimeFormatter $0 = null
int tokenLen = token.length():int $0 = token.length()
if (((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) {


	buf.append(c);

	while ((i + 1) < length) {
		char peek = pattern.charAt(i + 1);
		if (peek == c) {
			buf.append(c);
			i++;
		} else {
			break;
		}
	} 
} else {

	buf.append('\'');

	boolean inLiteral = false;

	for (; i < length; i++) {
		c = pattern.charAt(i);

		if (c == '\'') {
			if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

				i++;
				buf.append(c);
			} else {
				inLiteral = !inLiteral;
			}
		} else { 			if ((!inLiteral) && 
			(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
				i--;
				break;
			} else {
				buf.append(c);
			}}
	}
}:if (((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) {


	buf.append(c);

	while ((i + 1) < length) {
		char $0 = pattern.charAt(i + 1);
		if ($0 == c) {
			buf.append(c);
			i++;
		} else {
			break;
		}
	} 
} else {

	buf.append('\'');

	boolean $1 = false;

	for (; i < length; i++) {
		c = pattern.charAt(i);

		if (c == '\'') {
			if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

				i++;
				buf.append(c);
			} else {
				$1 = !$1;
			}
		} else { 			if ((!$1) && 
			(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
				i--;
				break;
			} else {
				buf.append(c);
			}}
	}
}
synchronized(org.joda.time.format.DateTimeFormat.STYLE_CACHE) {
	f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index];
	if (f == null) {
		f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
		org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
	}
}:synchronized(org.joda.time.format.DateTimeFormat.STYLE_CACHE) {
	f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index];
	if (f == null) {
		f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
		org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
	}
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, false, minDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, false, minDigits))
int length = pattern.length():int $0 = pattern.length()
return iOfYear.next(instant, standardOffset, saveMillis):return iOfYear.next(instant, standardOffset, saveMillis)
return iNameKey:return iNameKey
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.SHORT_NAME, null), null):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.SHORT_NAME, null), null)
return appendFraction(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, maxDigits)
builder.appendDayOfWeekShortText():builder.appendDayOfWeekShortText()
return append0(new org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral(c)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral(c))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, false))
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.LONG):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.LONG)
if (tokenLen == 2) {
	builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
} else {
	builder.appendTimeZoneId();
}:if (tokenLen == 2) {
	builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
} else {
	builder.appendTimeZoneId();
}
if ((!inLiteral) && 
(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
	i--;
	break;
} else {
	buf.append(c);
}:if ((!inLiteral) && 
(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
	i--;
	break;
} else {
	buf.append(c);
}
int dateStyle = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(0)):int $0 = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(0))
return isPrinter(f) || isParser(f):return isPrinter(f) || isParser(f)
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfMonth(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfMonth(), minDigits, 2)
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)))):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in))))
return appendDecimal(org.joda.time.DateTimeFieldType.monthOfYear(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.monthOfYear(), minDigits, 2)
switch (c) {
	case 'x' :
		builder.appendTwoDigitWeekyear(
		new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
		break;
	case 'y' :
	case 'Y' :
	default :
		builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
		break;}:switch (c) {
	case 'x' :
		builder.appendTwoDigitWeekyear(
		new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
		break;
	case 'y' :
	case 'Y' :
	default :
		builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
		break;}
int index = ((dateStyle << 2) + dateStyle) + timeStyle:int $0 = ((dateStyle << 2) + dateStyle) + timeStyle
return appendDecimal(org.joda.time.DateTimeFieldType.millisOfSecond(), minDigits, 3):return appendDecimal(org.joda.time.DateTimeFieldType.millisOfSecond(), minDigits, 3)
return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isPrinter():return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isPrinter()
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.SHORT):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.SHORT)
return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfHalfday(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfHalfday(), minDigits, 2)
if ((setEn != null) && (setLoc != null)) {
	byNameKeyCache.put(setEn[2], new java.lang.String[]{ setLoc[2], setLoc[1] });



	if (setEn[2].equals(setEn[4])) {
		byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
	} else {
		byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
	}
}:if ((setEn != null) && (setLoc != null)) {
	byNameKeyCache.put(setEn[2], new java.lang.String[]{ setLoc[2], setLoc[1] });



	if (setEn[2].equals(setEn[4])) {
		byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
	} else {
		byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
	}
}
return appendDecimal(org.joda.time.DateTimeFieldType.millisOfDay(), minDigits, 8):return appendDecimal(org.joda.time.DateTimeFieldType.millisOfDay(), minDigits, 8)
if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setEn = strings;
	break;
}:if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setEn = strings;
	break;
}
if (c == '\'') {
	if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

		i++;
		buf.append(c);
	} else {
		inLiteral = !inLiteral;
	}
} else { 	if ((!inLiteral) && 
	(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
		i--;
		break;
	} else {
		buf.append(c);
	}}:if (c == '\'') {
	if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

		i++;
		buf.append(c);
	} else {
		inLiteral = !inLiteral;
	}
} else { 	if ((!inLiteral) && 
	(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
		i--;
		break;
	} else {
		buf.append(c);
	}}
builder.appendTimeZoneOffset(null, "Z", false, 2, 2):builder.appendTimeZoneOffset(null, "Z", false, 2, 2)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.MEDIUM):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.MEDIUM)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.weekyear(), pivot, lenientParse)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.weekyear(), pivot, lenientParse))
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.MEDIUM):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.MEDIUM)
indexRef[0]--:indexRef[0]--
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.NONE)
if ((pattern == null) || (pattern.length() == 0)) {
	throw new java.lang.IllegalArgumentException("Invalid pattern specification");
}:if ((pattern == null) || (pattern.length() == 0)) {
	throw new java.lang.IllegalArgumentException("Invalid pattern specification");
}
formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern):formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern)
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfWeek(), minDigits, 1):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfWeek(), minDigits, 1)
return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, 4):return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, 4)
if (peek == c) {
	buf.append(c);
	i++;
} else {
	break;
}:if (peek == c) {
	buf.append(c);
	i++;
} else {
	break;
}
builder.appendLiteral(sub.charAt(0)):builder.appendLiteral(sub.charAt(0))
return appendSignedDecimal(org.joda.time.DateTimeFieldType.year(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.year(), minDigits, maxDigits)
i = indexRef[0]:i = indexRef[0]
int timeStyle = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(1)):int $0 = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(1))
if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

	maxDigits = tokenLen;
}:if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

	maxDigits = tokenLen;
}
return iOfYear:return iOfYear
return false:return false
buf.append(c):buf.append(c)
if (tokenLen > 0) {
	char c = token.charAt(0);
	switch (c) {
		case 'c' :
		case 'C' :
		case 'x' :
		case 'y' :
		case 'Y' :
		case 'd' :
		case 'h' :
		case 'H' :
		case 'm' :
		case 's' :
		case 'S' :
		case 'e' :
		case 'D' :
		case 'F' :
		case 'w' :
		case 'W' :
		case 'k' :
		case 'K' :
			return true;
		case 'M' :
			if (tokenLen <= 2) {
				return true;
			}}

}:if (tokenLen > 0) {
	char $0 = token.charAt(0);
	switch ($0) {
		case 'c' :
		case 'C' :
		case 'x' :
		case 'y' :
		case 'Y' :
		case 'd' :
		case 'h' :
		case 'H' :
		case 'm' :
		case 's' :
		case 'S' :
		case 'e' :
		case 'D' :
		case 'F' :
		case 'w' :
		case 'W' :
		case 'k' :
		case 'K' :
			return true;
		case 'M' :
			if (tokenLen <= 2) {
				return true;
			}}

}
return append0(pp, pp):return append0(pp, pp)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.FULL):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.FULL)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, false))
return appendText(org.joda.time.DateTimeFieldType.halfdayOfDay()):return appendText(org.joda.time.DateTimeFieldType.halfdayOfDay())
break:break
boolean lenientParse = true:boolean $0 = true
return appendDecimal(org.joda.time.DateTimeFieldType.secondOfMinute(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.secondOfMinute(), minDigits, 2)
switch (c) {
	case 'c' :
	case 'C' :
	case 'x' :
	case 'y' :
	case 'Y' :
	case 'd' :
	case 'h' :
	case 'H' :
	case 'm' :
	case 's' :
	case 'S' :
	case 'e' :
	case 'D' :
	case 'F' :
	case 'w' :
	case 'W' :
	case 'k' :
	case 'K' :
		return true;
	case 'M' :
		if (tokenLen <= 2) {
			return true;
		}}:switch (c) {
	case 'c' :
	case 'C' :
	case 'x' :
	case 'y' :
	case 'Y' :
	case 'd' :
	case 'h' :
	case 'H' :
	case 'm' :
	case 's' :
	case 'S' :
	case 'e' :
	case 'D' :
	case 'F' :
	case 'w' :
	case 'W' :
	case 'k' :
	case 'K' :
		return true;
	case 'M' :
		if (tokenLen <= 2) {
			return true;
		}}
if ((dateStyle == org.joda.time.format.DateTimeFormat.NONE) && (timeStyle == org.joda.time.format.DateTimeFormat.NONE)) {
	throw new java.lang.IllegalArgumentException("Style '--' is invalid");
}:if ((dateStyle == org.joda.time.format.DateTimeFormat.NONE) && (timeStyle == org.joda.time.format.DateTimeFormat.NONE)) {
	throw new java.lang.IllegalArgumentException("Style '--' is invalid");
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.year(), pivot, lenientParse)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.year(), pivot, lenientParse))
int type = org.joda.time.format.DateTimeFormat.DATETIME:int $0 = org.joda.time.format.DateTimeFormat.DATETIME
return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, true))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.LONG_NAME, null), null):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.LONG_NAME, null), null)
return appendTwoDigitYear(pivot, false):return appendTwoDigitYear(pivot, false)
throw new java.lang.IllegalArgumentException("Invalid style specification: " + style):throw new java.lang.IllegalArgumentException("Invalid style specification: " + style)
return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle):return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle)
indexRef[0] = i:indexRef[0] = i
if (index >= org.joda.time.format.DateTimeFormat.STYLE_CACHE.length) {
	return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
}:if (index >= org.joda.time.format.DateTimeFormat.STYLE_CACHE.length) {
	return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
}
return appendFraction(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, maxDigits)
i++:i++
return true:return true
return ((org.joda.time.format.DateTimeFormat.StyleFormatter) (formatter.getPrinter())).getPattern(locale):return ((org.joda.time.format.DateTimeFormat.StyleFormatter) (formatter.getPrinter())).getPattern(locale)
return org.joda.time.format.DateTimeFormat.createFormatterForStyle(style):return org.joda.time.format.DateTimeFormat.createFormatterForStyle(style)
throw new java.lang.IllegalArgumentException("Invalid pattern specification"):throw new java.lang.IllegalArgumentException("Invalid pattern specification")
if (locale == null) {
	locale = java.util.Locale.getDefault();
}:if (locale == null) {
	locale = java.util.Locale.getDefault();
}
if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



	lenientParse = false;
}:if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



	lenientParse = false;
}
throw new java.lang.IllegalArgumentException("Style '--' is invalid"):throw new java.lang.IllegalArgumentException("Style '--' is invalid")
if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.DATE;
}:if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.DATE;
}
type = org.joda.time.format.DateTimeFormat.DATE:type = org.joda.time.format.DateTimeFormat.DATE
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.NONE)
return ((org.joda.time.format.DateTimeParser) (f)):return ((org.joda.time.format.DateTimeParser) (f))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, true, minDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, true, minDigits))
switch (c) {
	case 'x' :
		builder.appendWeekyear(tokenLen, maxDigits);
		break;
	case 'y' :
		builder.appendYear(tokenLen, maxDigits);
		break;
	case 'Y' :
		builder.appendYearOfEra(tokenLen, maxDigits);
		break;}:switch (c) {
	case 'x' :
		builder.appendWeekyear(tokenLen, maxDigits);
		break;
	case 'y' :
		builder.appendYear(tokenLen, maxDigits);
		break;
	case 'Y' :
		builder.appendYearOfEra(tokenLen, maxDigits);
		break;}
return appendDecimal(org.joda.time.DateTimeFieldType.yearOfCentury(), minDigits, maxDigits):return appendDecimal(org.joda.time.DateTimeFieldType.yearOfCentury(), minDigits, maxDigits)
return new org.joda.time.format.DateTimeFormatter(printer, parser):return new org.joda.time.format.DateTimeFormatter(printer, parser)
return appendText(org.joda.time.DateTimeFieldType.monthOfYear()):return appendText(org.joda.time.DateTimeFieldType.monthOfYear())
builder.appendDayOfWeekText():builder.appendDayOfWeekText()
while ((i + 1) < length) {
	char peek = pattern.charAt(i + 1);
	if (peek == c) {
		buf.append(c);
		i++;
	} else {
		break;
	}
} :while ((i + 1) < length) {
	char $0 = pattern.charAt(i + 1);
	if ($0 == c) {
		buf.append(c);
		i++;
	} else {
		break;
	}
} 
if (((locale == null) || (id == null)) || (nameKey == null)) {
	return null;
}:if (((locale == null) || (id == null)) || (nameKey == null)) {
	return null;
}
if (dateStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.TIME;
} else { 	if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
		type = org.joda.time.format.DateTimeFormat.DATE;
	}}:if (dateStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.TIME;
} else { 	if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
		type = org.joda.time.format.DateTimeFormat.DATE;
	}}
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.NONE)
i--:i--
builder.appendMonthOfYear(tokenLen):builder.appendMonthOfYear(tokenLen)
return org.joda.time.format.DateTimeFormat.createFormatterForPattern(pattern):return org.joda.time.format.DateTimeFormat.createFormatterForPattern(pattern)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields))
int[] indexRef = new int[1]:int[] $0 = new int[1]
builder.appendMonthOfYearShortText():builder.appendMonthOfYearShortText()
for (int i = 0; i < length; i++) {
	indexRef[0] = i;
	java.lang.String token = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef);
	i = indexRef[0];

	int tokenLen = token.length();
	if (tokenLen == 0) {
		break;
	}
	char c = token.charAt(0);

	switch (c) {
		case 'G' :
			builder.appendEraText();
			break;
		case 'C' :
			builder.appendCenturyOfEra(tokenLen, tokenLen);
			break;
		case 'x' :
		case 'y' :
		case 'Y' :
			if (tokenLen == 2) {
				boolean lenientParse = true;


				if ((i + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



						lenientParse = false;
					}
					indexRef[0]--;
				}


				switch (c) {
					case 'x' :
						builder.appendTwoDigitWeekyear(
						new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
						break;
					case 'y' :
					case 'Y' :
					default :
						builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
						break;}

			} else {

				int maxDigits = 9;


				if ((i + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

						maxDigits = tokenLen;
					}
					indexRef[0]--;
				}

				switch (c) {
					case 'x' :
						builder.appendWeekyear(tokenLen, maxDigits);
						break;
					case 'y' :
						builder.appendYear(tokenLen, maxDigits);
						break;
					case 'Y' :
						builder.appendYearOfEra(tokenLen, maxDigits);
						break;}

			}
			break;
		case 'M' :
			if (tokenLen >= 3) {
				if (tokenLen >= 4) {
					builder.appendMonthOfYearText();
				} else {
					builder.appendMonthOfYearShortText();
				}
			} else {
				builder.appendMonthOfYear(tokenLen);
			}
			break;
		case 'd' :
			builder.appendDayOfMonth(tokenLen);
			break;
		case 'a' :
			builder.appendHalfdayOfDayText();
			break;
		case 'h' :
			builder.appendClockhourOfHalfday(tokenLen);
			break;
		case 'H' :
			builder.appendHourOfDay(tokenLen);
			break;
		case 'k' :
			builder.appendClockhourOfDay(tokenLen);
			break;
		case 'K' :
			builder.appendHourOfHalfday(tokenLen);
			break;
		case 'm' :
			builder.appendMinuteOfHour(tokenLen);
			break;
		case 's' :
			builder.appendSecondOfMinute(tokenLen);
			break;
		case 'S' :
			builder.appendFractionOfSecond(tokenLen, tokenLen);
			break;
		case 'e' :
			builder.appendDayOfWeek(tokenLen);
			break;
		case 'E' :
			if (tokenLen >= 4) {
				builder.appendDayOfWeekText();
			} else {
				builder.appendDayOfWeekShortText();
			}
			break;
		case 'D' :
			builder.appendDayOfYear(tokenLen);
			break;
		case 'w' :
			builder.appendWeekOfWeekyear(tokenLen);
			break;
		case 'z' :
			if (tokenLen >= 4) {
				builder.appendTimeZoneName();
			} else {
				builder.appendTimeZoneShortName(null);
			}
			break;
		case 'Z' :
			if (tokenLen == 1) {
				builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
			} else { 				if (tokenLen == 2) {
					builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
				} else {
					builder.appendTimeZoneId();
				}}
			break;
		case '\'' :
			java.lang.String sub = token.substring(1);
			if (sub.length() == 1) {
				builder.appendLiteral(sub.charAt(0));
			} else {


				builder.appendLiteral(new java.lang.String(sub));
			}
			break;
		default :
			throw new java.lang.IllegalArgumentException(
			"Illegal pattern component: " + token);}

}:for (int $0 = 0; $0 < length; $0++) {
	indexRef[0] = $0;
	java.lang.String $1 = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef);
	$0 = indexRef[0];

	int $2 = $1.length();
	if ($2 == 0) {
		break;
	}
	char $3 = $1.charAt(0);

	switch ($3) {
		case 'G' :
			builder.appendEraText();
			break;
		case 'C' :
			builder.appendCenturyOfEra($2, $2);
			break;
		case 'x' :
		case 'y' :
		case 'Y' :
			if ($2 == 2) {
				boolean $4 = true;


				if (($0 + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



						$4 = false;
					}
					indexRef[0]--;
				}


				switch ($3) {
					case 'x' :
						builder.appendTwoDigitWeekyear(
						new org.joda.time.DateTime().getWeekyear() - 30, $4);
						break;
					case 'y' :
					case 'Y' :
					default :
						builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, $4);
						break;}

			} else {

				int $5 = 9;


				if (($0 + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

						$5 = $2;
					}
					indexRef[0]--;
				}

				switch ($3) {
					case 'x' :
						builder.appendWeekyear($2, $5);
						break;
					case 'y' :
						builder.appendYear($2, $5);
						break;
					case 'Y' :
						builder.appendYearOfEra($2, $5);
						break;}

			}
			break;
		case 'M' :
			if ($2 >= 3) {
				if ($2 >= 4) {
					builder.appendMonthOfYearText();
				} else {
					builder.appendMonthOfYearShortText();
				}
			} else {
				builder.appendMonthOfYear($2);
			}
			break;
		case 'd' :
			builder.appendDayOfMonth($2);
			break;
		case 'a' :
			builder.appendHalfdayOfDayText();
			break;
		case 'h' :
			builder.appendClockhourOfHalfday($2);
			break;
		case 'H' :
			builder.appendHourOfDay($2);
			break;
		case 'k' :
			builder.appendClockhourOfDay($2);
			break;
		case 'K' :
			builder.appendHourOfHalfday($2);
			break;
		case 'm' :
			builder.appendMinuteOfHour($2);
			break;
		case 's' :
			builder.appendSecondOfMinute($2);
			break;
		case 'S' :
			builder.appendFractionOfSecond($2, $2);
			break;
		case 'e' :
			builder.appendDayOfWeek($2);
			break;
		case 'E' :
			if ($2 >= 4) {
				builder.appendDayOfWeekText();
			} else {
				builder.appendDayOfWeekShortText();
			}
			break;
		case 'D' :
			builder.appendDayOfYear($2);
			break;
		case 'w' :
			builder.appendWeekOfWeekyear($2);
			break;
		case 'z' :
			if ($2 >= 4) {
				builder.appendTimeZoneName();
			} else {
				builder.appendTimeZoneShortName(null);
			}
			break;
		case 'Z' :
			if ($2 == 1) {
				builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
			} else { 				if ($2 == 2) {
					builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
				} else {
					builder.appendTimeZoneId();
				}}
			break;
		case '\'' :
			java.lang.String $6 = $1.substring(1);
			if ($6.length() == 1) {
				builder.appendLiteral($6.charAt(0));
			} else {


				builder.appendLiteral(new java.lang.String($6));
			}
			break;
		default :
			throw new java.lang.IllegalArgumentException(
			"Illegal pattern component: " + $1);}

}
return appendDecimal(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, 5):return appendDecimal(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, 5)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.FULL):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.FULL)
if ((style == null) || (style.length() != 2)) {
	throw new java.lang.IllegalArgumentException("Invalid style specification: " + style);
}:if ((style == null) || (style.length() != 2)) {
	throw new java.lang.IllegalArgumentException("Invalid style specification: " + style);
}
switch (c) {
	case 'G' :
		builder.appendEraText();
		break;
	case 'C' :
		builder.appendCenturyOfEra(tokenLen, tokenLen);
		break;
	case 'x' :
	case 'y' :
	case 'Y' :
		if (tokenLen == 2) {
			boolean lenientParse = true;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



					lenientParse = false;
				}
				indexRef[0]--;
			}


			switch (c) {
				case 'x' :
					builder.appendTwoDigitWeekyear(
					new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
					break;
				case 'y' :
				case 'Y' :
				default :
					builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
					break;}

		} else {

			int maxDigits = 9;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

					maxDigits = tokenLen;
				}
				indexRef[0]--;
			}

			switch (c) {
				case 'x' :
					builder.appendWeekyear(tokenLen, maxDigits);
					break;
				case 'y' :
					builder.appendYear(tokenLen, maxDigits);
					break;
				case 'Y' :
					builder.appendYearOfEra(tokenLen, maxDigits);
					break;}

		}
		break;
	case 'M' :
		if (tokenLen >= 3) {
			if (tokenLen >= 4) {
				builder.appendMonthOfYearText();
			} else {
				builder.appendMonthOfYearShortText();
			}
		} else {
			builder.appendMonthOfYear(tokenLen);
		}
		break;
	case 'd' :
		builder.appendDayOfMonth(tokenLen);
		break;
	case 'a' :
		builder.appendHalfdayOfDayText();
		break;
	case 'h' :
		builder.appendClockhourOfHalfday(tokenLen);
		break;
	case 'H' :
		builder.appendHourOfDay(tokenLen);
		break;
	case 'k' :
		builder.appendClockhourOfDay(tokenLen);
		break;
	case 'K' :
		builder.appendHourOfHalfday(tokenLen);
		break;
	case 'm' :
		builder.appendMinuteOfHour(tokenLen);
		break;
	case 's' :
		builder.appendSecondOfMinute(tokenLen);
		break;
	case 'S' :
		builder.appendFractionOfSecond(tokenLen, tokenLen);
		break;
	case 'e' :
		builder.appendDayOfWeek(tokenLen);
		break;
	case 'E' :
		if (tokenLen >= 4) {
			builder.appendDayOfWeekText();
		} else {
			builder.appendDayOfWeekShortText();
		}
		break;
	case 'D' :
		builder.appendDayOfYear(tokenLen);
		break;
	case 'w' :
		builder.appendWeekOfWeekyear(tokenLen);
		break;
	case 'z' :
		if (tokenLen >= 4) {
			builder.appendTimeZoneName();
		} else {
			builder.appendTimeZoneShortName(null);
		}
		break;
	case 'Z' :
		if (tokenLen == 1) {
			builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
		} else { 			if (tokenLen == 2) {
				builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
			} else {
				builder.appendTimeZoneId();
			}}
		break;
	case '\'' :
		java.lang.String sub = token.substring(1);
		if (sub.length() == 1) {
			builder.appendLiteral(sub.charAt(0));
		} else {


			builder.appendLiteral(new java.lang.String(sub));
		}
		break;
	default :
		throw new java.lang.IllegalArgumentException(
		"Illegal pattern component: " + token);}:switch (c) {
	case 'G' :
		builder.appendEraText();
		break;
	case 'C' :
		builder.appendCenturyOfEra(tokenLen, tokenLen);
		break;
	case 'x' :
	case 'y' :
	case 'Y' :
		if (tokenLen == 2) {
			boolean $0 = true;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



					$0 = false;
				}
				indexRef[0]--;
			}


			switch (c) {
				case 'x' :
					builder.appendTwoDigitWeekyear(
					new org.joda.time.DateTime().getWeekyear() - 30, $0);
					break;
				case 'y' :
				case 'Y' :
				default :
					builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, $0);
					break;}

		} else {

			int $1 = 9;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

					$1 = tokenLen;
				}
				indexRef[0]--;
			}

			switch (c) {
				case 'x' :
					builder.appendWeekyear(tokenLen, $1);
					break;
				case 'y' :
					builder.appendYear(tokenLen, $1);
					break;
				case 'Y' :
					builder.appendYearOfEra(tokenLen, $1);
					break;}

		}
		break;
	case 'M' :
		if (tokenLen >= 3) {
			if (tokenLen >= 4) {
				builder.appendMonthOfYearText();
			} else {
				builder.appendMonthOfYearShortText();
			}
		} else {
			builder.appendMonthOfYear(tokenLen);
		}
		break;
	case 'd' :
		builder.appendDayOfMonth(tokenLen);
		break;
	case 'a' :
		builder.appendHalfdayOfDayText();
		break;
	case 'h' :
		builder.appendClockhourOfHalfday(tokenLen);
		break;
	case 'H' :
		builder.appendHourOfDay(tokenLen);
		break;
	case 'k' :
		builder.appendClockhourOfDay(tokenLen);
		break;
	case 'K' :
		builder.appendHourOfHalfday(tokenLen);
		break;
	case 'm' :
		builder.appendMinuteOfHour(tokenLen);
		break;
	case 's' :
		builder.appendSecondOfMinute(tokenLen);
		break;
	case 'S' :
		builder.appendFractionOfSecond(tokenLen, tokenLen);
		break;
	case 'e' :
		builder.appendDayOfWeek(tokenLen);
		break;
	case 'E' :
		if (tokenLen >= 4) {
			builder.appendDayOfWeekText();
		} else {
			builder.appendDayOfWeekShortText();
		}
		break;
	case 'D' :
		builder.appendDayOfYear(tokenLen);
		break;
	case 'w' :
		builder.appendWeekOfWeekyear(tokenLen);
		break;
	case 'z' :
		if (tokenLen >= 4) {
			builder.appendTimeZoneName();
		} else {
			builder.appendTimeZoneShortName(null);
		}
		break;
	case 'Z' :
		if (tokenLen == 1) {
			builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
		} else { 			if (tokenLen == 2) {
				builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
			} else {
				builder.appendTimeZoneId();
			}}
		break;
	case '\'' :
		java.lang.String $2 = token.substring(1);
		if ($2.length() == 1) {
			builder.appendLiteral($2.charAt(0));
		} else {


			builder.appendLiteral(new java.lang.String($2));
		}
		break;
	default :
		throw new java.lang.IllegalArgumentException(
		"Illegal pattern component: " + token);}
org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder():org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder()
return appendTwoDigitWeekyear(pivot, false):return appendTwoDigitWeekyear(pivot, false)
buf.append('\''):buf.append('\'')
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.NONE)
org.joda.time.format.DateTimeFormat.StyleFormatter llf = new org.joda.time.format.DateTimeFormat.StyleFormatter(dateStyle, timeStyle, type):org.joda.time.format.DateTimeFormat.StyleFormatter $0 = new org.joda.time.format.DateTimeFormat.StyleFormatter(dateStyle, timeStyle, type)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.LONG):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.LONG)
return appendDecimal(org.joda.time.DateTimeFieldType.yearOfEra(), minDigits, maxDigits):return appendDecimal(org.joda.time.DateTimeFieldType.yearOfEra(), minDigits, maxDigits)
return rename((iNameKey + appendNameKey).intern()):return rename((iNameKey + appendNameKey).intern())
indexRef[0]++:indexRef[0]++
if (tokenLen == 0) {
	break;
}:if (tokenLen == 0) {
	break;
}
return appendShortText(org.joda.time.DateTimeFieldType.dayOfWeek()):return appendShortText(org.joda.time.DateTimeFieldType.dayOfWeek())
return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, true))
[ERROR] fr.inria.astor.core.solutionsearch.AstorCoreEngine.validateReversedOriginalVariant(AstorCoreEngine.java:359) - Error variant :8 the model was not the same from the original after this generation (see Diff in debug level)
if (setEn[2].equals(setEn[4])) {
	byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
} else {
	byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
}:if (setEn[2].equals(setEn[4])) {
	byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
} else {
	byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
}
return appendFraction(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, maxDigits)
return isParser(getFormatter()):return isParser(getFormatter())
org.joda.time.format.DateTimeFormatter formatter = org.joda.time.format.DateTimeFormat.createFormatterForStyle(style):org.joda.time.format.DateTimeFormatter $0 = org.joda.time.format.DateTimeFormat.createFormatterForStyle(style)
if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

		maxDigits = tokenLen;
	}
	indexRef[0]--;
}:if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

		maxDigits = tokenLen;
	}
	indexRef[0]--;
}
org.joda.time.format.DateTimeFormatter formatter = null:org.joda.time.format.DateTimeFormatter $0 = null
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.SHORT):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.SHORT)
org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern):org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern)
return append0(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE, org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE):return append0(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE, org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE)
if (f == null) {
	f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
	org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
}:if (f == null) {
	f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
	org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
}
return append0(formatter.getPrinter(), formatter.getParser()):return append0(formatter.getPrinter(), formatter.getParser())
return append0(printer, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(copyOfParsers)):return append0(printer, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(copyOfParsers))
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis)
return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfHour(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfHour(), minDigits, 2)
if (tokenLen >= 4) {
	builder.appendMonthOfYearText();
} else {
	builder.appendMonthOfYearShortText();
}:if (tokenLen >= 4) {
	builder.appendMonthOfYearText();
} else {
	builder.appendMonthOfYearShortText();
}
builder.appendTimeZoneOffset(null, "Z", true, 2, 2):builder.appendTimeZoneOffset(null, "Z", true, 2, 2)
return appendSignedDecimal(org.joda.time.DateTimeFieldType.centuryOfEra(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.centuryOfEra(), minDigits, maxDigits)
return append0(null, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(parsers)):return append0(null, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(parsers))
builder.appendMonthOfYearText():builder.appendMonthOfYearText()
return ((org.joda.time.format.DateTimePrinter) (f)):return ((org.joda.time.format.DateTimePrinter) (f))
return appendDecimal(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, 2)
builder.appendLiteral(new java.lang.String(sub)):builder.appendLiteral(new java.lang.String(sub))
synchronized(org.joda.time.format.DateTimeFormat.PATTERN_CACHE) {
	formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern);
	if (formatter == null) {
		org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder();
		org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern);
		formatter = builder.toFormatter();

		org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
	}
}:synchronized(org.joda.time.format.DateTimeFormat.PATTERN_CACHE) {
	formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern);
	if (formatter == null) {
		org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder();
		org.joda.time.format.DateTimeFormat.parsePatternTo($0, pattern);
		formatter = $0.toFormatter();

		org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
	}
}
return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfDay(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfDay(), minDigits, 2)
return appendText(org.joda.time.DateTimeFieldType.era()):return appendText(org.joda.time.DateTimeFieldType.era())
java.lang.String token = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef):java.lang.String $0 = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef)
char c = pattern.charAt(i):char $0 = pattern.charAt(i)
boolean inLiteral = false:boolean $0 = false
maxDigits = tokenLen:maxDigits = tokenLen
return append0(new org.joda.time.format.DateTimeFormatterBuilder.Fraction(fieldType, minDigits, maxDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.Fraction(fieldType, minDigits, maxDigits))
if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



		lenientParse = false;
	}
	indexRef[0]--;
}:if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



		lenientParse = false;
	}
	indexRef[0]--;
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, true))
return appendFraction(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, maxDigits)
return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear):return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear)
int maxDigits = 9:int $0 = 9
return appendText(org.joda.time.DateTimeFieldType.dayOfWeek()):return appendText(org.joda.time.DateTimeFieldType.dayOfWeek())
return iSaveMillis:return iSaveMillis
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, 3):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, 3)
if (byIdCache == null) {
	iByLocaleCache.put(locale, byIdCache = createCache());
}:if (byIdCache == null) {
	iByLocaleCache.put(locale, byIdCache = createCache());
}
locale = java.util.Locale.getDefault():locale = java.util.Locale.getDefault()
return new org.joda.time.format.DateTimeFormatter(llf, llf):return new org.joda.time.format.DateTimeFormatter(llf, llf)
return iOfYear.previous(instant, standardOffset, saveMillis):return iOfYear.previous(instant, standardOffset, saveMillis)
return isPrinter(getFormatter()):return isPrinter(getFormatter())
return appendDecimal(org.joda.time.DateTimeFieldType.weekOfWeekyear(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.weekOfWeekyear(), minDigits, 2)
return isFormatter(getFormatter()):return isFormatter(getFormatter())
return append0(printer, null):return append0(printer, null)
lenientParse = false:lenientParse = false
java.lang.StringBuilder buf = new java.lang.StringBuilder():java.lang.StringBuilder $0 = new java.lang.StringBuilder()
char c = token.charAt(0):char $0 = token.charAt(0)
return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isParser():return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isParser()
if (formatter == null) {
	org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder();
	org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern);
	formatter = builder.toFormatter();

	org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
}:if (formatter == null) {
	org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder();
	org.joda.time.format.DateTimeFormat.parsePatternTo($0, pattern);
	formatter = $0.toFormatter();

	org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
}
c = pattern.charAt(i):c = pattern.charAt(i)
for (; i < length; i++) {
	c = pattern.charAt(i);

	if (c == '\'') {
		if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

			i++;
			buf.append(c);
		} else {
			inLiteral = !inLiteral;
		}
	} else { 		if ((!inLiteral) && 
		(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
			i--;
			break;
		} else {
			buf.append(c);
		}}
}:for (; i < length; i++) {
	c = pattern.charAt(i);

	if (c == '\'') {
		if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

			i++;
			buf.append(c);
		} else {
			inLiteral = !inLiteral;
		}
	} else { 		if ((!inLiteral) && 
		(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
			i--;
			break;
		} else {
			buf.append(c);
		}}
}
return this:return this
f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle):f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle)
builder.appendTimeZoneShortName(null):builder.appendTimeZoneShortName(null)
return append0(null, parser):return append0(null, parser)
org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter):org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter)
if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setLoc = strings;
	break;
}:if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setLoc = strings;
	break;
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields))
if (byNameKeyCache == null) {
	byIdCache.put(id, byNameKeyCache = createCache());

	java.lang.String[][] $0 = org.joda.time.DateTimeUtils.getDateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings();
	java.lang.String[] $1 = null;
	for (java.lang.String[] $2 : $0) {
		if ((($2 != null) && ($2.length == 5)) && id.equals($2[0])) {
			$1 = $2;
			break;
		}
	}
	java.lang.String[][] $3 = org.joda.time.DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
	java.lang.String[] $4 = null;
	for (java.lang.String[] $5 : $3) {
		if ((($5 != null) && ($5.length == 5)) && id.equals($5[0])) {
			$4 = $5;
			break;
		}
	}

	if (($1 != null) && ($4 != null)) {
		byNameKeyCache.put($1[2], new java.lang.String[]{ $4[2], $4[1] });



		if ($1[2].equals($1[4])) {
			byNameKeyCache.put($1[4] + "-Summer", new java.lang.String[]{ $4[4], $4[3] });
		} else {
			byNameKeyCache.put($1[4], new java.lang.String[]{ $4[4], $4[3] });
		}
	}
}:if (byNameKeyCache == null) {
	byIdCache.put(id, byNameKeyCache = createCache());

	java.lang.String[][] $0 = org.joda.time.DateTimeUtils.getDateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings();
	java.lang.String[] $1 = null;
	for (java.lang.String[] $2 : $0) {
		if ((($2 != null) && ($2.length == 5)) && id.equals($2[0])) {
			$1 = $2;
			break;
		}
	}
	java.lang.String[][] $3 = org.joda.time.DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
	java.lang.String[] $4 = null;
	for (java.lang.String[] $5 : $3) {
		if ((($5 != null) && ($5.length == 5)) && id.equals($5[0])) {
			$4 = $5;
			break;
		}
	}

	if (($1 != null) && ($4 != null)) {
		byNameKeyCache.put($1[2], new java.lang.String[]{ $4[2], $4[1] });



		if ($1[2].equals($1[4])) {
			byNameKeyCache.put($1[4] + "-Summer", new java.lang.String[]{ $4[4], $4[3] });
		} else {
			byNameKeyCache.put($1[4], new java.lang.String[]{ $4[4], $4[3] });
		}
	}
}
builder.appendTimeZoneName():builder.appendTimeZoneName()
return append0(printer, parser):return append0(printer, parser)
switch (ch) {
	case 'S' :
		return org.joda.time.format.DateTimeFormat.SHORT;
	case 'M' :
		return org.joda.time.format.DateTimeFormat.MEDIUM;
	case 'L' :
		return org.joda.time.format.DateTimeFormat.LONG;
	case 'F' :
		return org.joda.time.format.DateTimeFormat.FULL;
	case '-' :
		return org.joda.time.format.DateTimeFormat.NONE;
	default :
		throw new java.lang.IllegalArgumentException("Invalid style character: " + ch);}:switch (ch) {
	case 'S' :
		return org.joda.time.format.DateTimeFormat.SHORT;
	case 'M' :
		return org.joda.time.format.DateTimeFormat.MEDIUM;
	case 'L' :
		return org.joda.time.format.DateTimeFormat.LONG;
	case 'F' :
		return org.joda.time.format.DateTimeFormat.FULL;
	case '-' :
		return org.joda.time.format.DateTimeFormat.NONE;
	default :
		throw new java.lang.IllegalArgumentException("Invalid style character: " + ch);}
return appendShortText(org.joda.time.DateTimeFieldType.monthOfYear()):return appendShortText(org.joda.time.DateTimeFieldType.monthOfYear())
return formatter:return formatter
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(dateStyle, timeStyle):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(dateStyle, timeStyle)
org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f:org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f
return buf.toString():return buf.toString()
type = org.joda.time.format.DateTimeFormat.TIME:type = org.joda.time.format.DateTimeFormat.TIME
if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

	i++;
	buf.append(c);
} else {
	inLiteral = !inLiteral;
}:if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

	i++;
	buf.append(c);
} else {
	inLiteral = !inLiteral;
}
return appendSignedDecimal(org.joda.time.DateTimeFieldType.weekyear(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.weekyear(), minDigits, maxDigits)
f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index]:f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index]
return appendDecimal(org.joda.time.DateTimeFieldType.hourOfHalfday(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.hourOfHalfday(), minDigits, 2)
return append0(printer, parsers[0]):return append0(printer, parsers[0])
return f:return f
formatter = builder.toFormatter():formatter = builder.toFormatter()
int i = indexRef[0]:int $0 = indexRef[0]
if (byNameKeyCache == null) {
	byIdCache.put(id, byNameKeyCache = createCache());

	java.lang.String[][] zoneStringsEn = org.joda.time.DateTimeUtils.getDateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings();
	java.lang.String[] setEn = null;
	for (java.lang.String[] strings : zoneStringsEn) {
		if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
			setEn = strings;
			break;
		}
	}
	java.lang.String[][] zoneStringsLoc = org.joda.time.DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
	java.lang.String[] setLoc = null;
	for (java.lang.String[] strings : zoneStringsLoc) {
		if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
			setLoc = strings;
			break;
		}
	}

	if ((setEn != null) && (setLoc != null)) {
		byNameKeyCache.put(setEn[2], new java.lang.String[]{ setLoc[2], setLoc[1] });



		if (setEn[2].equals(setEn[4])) {
			byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
		} else {
			byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
		}
	}
}:if (byNameKeyCache == null) {
	byIdCache.put(id, byNameKeyCache = createCache());

	java.lang.String[][] $0 = org.joda.time.DateTimeUtils.getDateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings();
	java.lang.String[] $1 = null;
	for (java.lang.String[] $2 : $0) {
		if ((($2 != null) && ($2.length == 5)) && id.equals($2[0])) {
			$1 = $2;
			break;
		}
	}
	java.lang.String[][] $3 = org.joda.time.DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
	java.lang.String[] $4 = null;
	for (java.lang.String[] $5 : $3) {
		if ((($5 != null) && ($5.length == 5)) && id.equals($5[0])) {
			$4 = $5;
			break;
		}
	}

	if (($1 != null) && ($4 != null)) {
		byNameKeyCache.put($1[2], new java.lang.String[]{ $4[2], $4[1] });



		if ($1[2].equals($1[4])) {
			byNameKeyCache.put($1[4] + "-Summer", new java.lang.String[]{ $4[4], $4[3] });
		} else {
			byNameKeyCache.put($1[4], new java.lang.String[]{ $4[4], $4[3] });
		}
	}
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, false))
builder.appendTimeZoneId():builder.appendTimeZoneId()
char peek = pattern.charAt(i + 1):char $0 = pattern.charAt(i + 1)
inLiteral = !inLiteral:inLiteral = !inLiteral
org.joda.time.format.DateTimeFormatter f = null:org.joda.time.format.DateTimeFormatter $0 = null
int tokenLen = token.length():int $0 = token.length()
if (((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) {


	buf.append(c);

	while ((i + 1) < length) {
		char peek = pattern.charAt(i + 1);
		if (peek == c) {
			buf.append(c);
			i++;
		} else {
			break;
		}
	} 
} else {

	buf.append('\'');

	boolean inLiteral = false;

	for (; i < length; i++) {
		c = pattern.charAt(i);

		if (c == '\'') {
			if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

				i++;
				buf.append(c);
			} else {
				inLiteral = !inLiteral;
			}
		} else { 			if ((!inLiteral) && 
			(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
				i--;
				break;
			} else {
				buf.append(c);
			}}
	}
}:if (((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) {


	buf.append(c);

	while ((i + 1) < length) {
		char $0 = pattern.charAt(i + 1);
		if ($0 == c) {
			buf.append(c);
			i++;
		} else {
			break;
		}
	} 
} else {

	buf.append('\'');

	boolean $1 = false;

	for (; i < length; i++) {
		c = pattern.charAt(i);

		if (c == '\'') {
			if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

				i++;
				buf.append(c);
			} else {
				$1 = !$1;
			}
		} else { 			if ((!$1) && 
			(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
				i--;
				break;
			} else {
				buf.append(c);
			}}
	}
}
synchronized(org.joda.time.format.DateTimeFormat.STYLE_CACHE) {
	f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index];
	if (f == null) {
		f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
		org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
	}
}:synchronized(org.joda.time.format.DateTimeFormat.STYLE_CACHE) {
	f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index];
	if (f == null) {
		f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
		org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
	}
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, false, minDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, false, minDigits))
int length = pattern.length():int $0 = pattern.length()
return iOfYear.next(instant, standardOffset, saveMillis):return iOfYear.next(instant, standardOffset, saveMillis)
return iNameKey:return iNameKey
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.SHORT_NAME, null), null):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.SHORT_NAME, null), null)
return appendFraction(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, maxDigits)
builder.appendDayOfWeekShortText():builder.appendDayOfWeekShortText()
return append0(new org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral(c)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral(c))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, false))
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.LONG):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.LONG)
if (tokenLen == 2) {
	builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
} else {
	builder.appendTimeZoneId();
}:if (tokenLen == 2) {
	builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
} else {
	builder.appendTimeZoneId();
}
if ((!inLiteral) && 
(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
	i--;
	break;
} else {
	buf.append(c);
}:if ((!inLiteral) && 
(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
	i--;
	break;
} else {
	buf.append(c);
}
int dateStyle = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(0)):int $0 = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(0))
return isPrinter(f) || isParser(f):return isPrinter(f) || isParser(f)
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfMonth(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfMonth(), minDigits, 2)
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)))):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in))))
return appendDecimal(org.joda.time.DateTimeFieldType.monthOfYear(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.monthOfYear(), minDigits, 2)
switch (c) {
	case 'x' :
		builder.appendTwoDigitWeekyear(
		new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
		break;
	case 'y' :
	case 'Y' :
	default :
		builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
		break;}:switch (c) {
	case 'x' :
		builder.appendTwoDigitWeekyear(
		new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
		break;
	case 'y' :
	case 'Y' :
	default :
		builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
		break;}
int index = ((dateStyle << 2) + dateStyle) + timeStyle:int $0 = ((dateStyle << 2) + dateStyle) + timeStyle
return appendDecimal(org.joda.time.DateTimeFieldType.millisOfSecond(), minDigits, 3):return appendDecimal(org.joda.time.DateTimeFieldType.millisOfSecond(), minDigits, 3)
return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isPrinter():return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isPrinter()
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.SHORT):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.SHORT)
return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfHalfday(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfHalfday(), minDigits, 2)
if ((setEn != null) && (setLoc != null)) {
	byNameKeyCache.put(setEn[2], new java.lang.String[]{ setLoc[2], setLoc[1] });



	if (setEn[2].equals(setEn[4])) {
		byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
	} else {
		byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
	}
}:if ((setEn != null) && (setLoc != null)) {
	byNameKeyCache.put(setEn[2], new java.lang.String[]{ setLoc[2], setLoc[1] });



	if (setEn[2].equals(setEn[4])) {
		byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
	} else {
		byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
	}
}
return appendDecimal(org.joda.time.DateTimeFieldType.millisOfDay(), minDigits, 8):return appendDecimal(org.joda.time.DateTimeFieldType.millisOfDay(), minDigits, 8)
if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setEn = strings;
	break;
}:if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setEn = strings;
	break;
}
if (c == '\'') {
	if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

		i++;
		buf.append(c);
	} else {
		inLiteral = !inLiteral;
	}
} else { 	if ((!inLiteral) && 
	(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
		i--;
		break;
	} else {
		buf.append(c);
	}}:if (c == '\'') {
	if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

		i++;
		buf.append(c);
	} else {
		inLiteral = !inLiteral;
	}
} else { 	if ((!inLiteral) && 
	(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
		i--;
		break;
	} else {
		buf.append(c);
	}}
builder.appendTimeZoneOffset(null, "Z", false, 2, 2):builder.appendTimeZoneOffset(null, "Z", false, 2, 2)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.MEDIUM):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.MEDIUM)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.weekyear(), pivot, lenientParse)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.weekyear(), pivot, lenientParse))
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.MEDIUM):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.MEDIUM)
indexRef[0]--:indexRef[0]--
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.NONE)
if ((pattern == null) || (pattern.length() == 0)) {
	throw new java.lang.IllegalArgumentException("Invalid pattern specification");
}:if ((pattern == null) || (pattern.length() == 0)) {
	throw new java.lang.IllegalArgumentException("Invalid pattern specification");
}
formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern):formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern)
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfWeek(), minDigits, 1):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfWeek(), minDigits, 1)
return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, 4):return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, 4)
if (peek == c) {
	buf.append(c);
	i++;
} else {
	break;
}:if (peek == c) {
	buf.append(c);
	i++;
} else {
	break;
}
builder.appendLiteral(sub.charAt(0)):builder.appendLiteral(sub.charAt(0))
return appendSignedDecimal(org.joda.time.DateTimeFieldType.year(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.year(), minDigits, maxDigits)
i = indexRef[0]:i = indexRef[0]
int timeStyle = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(1)):int $0 = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(1))
if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

	maxDigits = tokenLen;
}:if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

	maxDigits = tokenLen;
}
return iOfYear:return iOfYear
return false:return false
buf.append(c):buf.append(c)
if (tokenLen > 0) {
	char c = token.charAt(0);
	switch (c) {
		case 'c' :
		case 'C' :
		case 'x' :
		case 'y' :
		case 'Y' :
		case 'd' :
		case 'h' :
		case 'H' :
		case 'm' :
		case 's' :
		case 'S' :
		case 'e' :
		case 'D' :
		case 'F' :
		case 'w' :
		case 'W' :
		case 'k' :
		case 'K' :
			return true;
		case 'M' :
			if (tokenLen <= 2) {
				return true;
			}}

}:if (tokenLen > 0) {
	char $0 = token.charAt(0);
	switch ($0) {
		case 'c' :
		case 'C' :
		case 'x' :
		case 'y' :
		case 'Y' :
		case 'd' :
		case 'h' :
		case 'H' :
		case 'm' :
		case 's' :
		case 'S' :
		case 'e' :
		case 'D' :
		case 'F' :
		case 'w' :
		case 'W' :
		case 'k' :
		case 'K' :
			return true;
		case 'M' :
			if (tokenLen <= 2) {
				return true;
			}}

}
return append0(pp, pp):return append0(pp, pp)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.FULL):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.FULL)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, false))
return appendText(org.joda.time.DateTimeFieldType.halfdayOfDay()):return appendText(org.joda.time.DateTimeFieldType.halfdayOfDay())
break:break
boolean lenientParse = true:boolean $0 = true
return appendDecimal(org.joda.time.DateTimeFieldType.secondOfMinute(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.secondOfMinute(), minDigits, 2)
switch (c) {
	case 'c' :
	case 'C' :
	case 'x' :
	case 'y' :
	case 'Y' :
	case 'd' :
	case 'h' :
	case 'H' :
	case 'm' :
	case 's' :
	case 'S' :
	case 'e' :
	case 'D' :
	case 'F' :
	case 'w' :
	case 'W' :
	case 'k' :
	case 'K' :
		return true;
	case 'M' :
		if (tokenLen <= 2) {
			return true;
		}}:switch (c) {
	case 'c' :
	case 'C' :
	case 'x' :
	case 'y' :
	case 'Y' :
	case 'd' :
	case 'h' :
	case 'H' :
	case 'm' :
	case 's' :
	case 'S' :
	case 'e' :
	case 'D' :
	case 'F' :
	case 'w' :
	case 'W' :
	case 'k' :
	case 'K' :
		return true;
	case 'M' :
		if (tokenLen <= 2) {
			return true;
		}}
if ((dateStyle == org.joda.time.format.DateTimeFormat.NONE) && (timeStyle == org.joda.time.format.DateTimeFormat.NONE)) {
	throw new java.lang.IllegalArgumentException("Style '--' is invalid");
}:if ((dateStyle == org.joda.time.format.DateTimeFormat.NONE) && (timeStyle == org.joda.time.format.DateTimeFormat.NONE)) {
	throw new java.lang.IllegalArgumentException("Style '--' is invalid");
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.year(), pivot, lenientParse)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.year(), pivot, lenientParse))
int type = org.joda.time.format.DateTimeFormat.DATETIME:int $0 = org.joda.time.format.DateTimeFormat.DATETIME
return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, true))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.LONG_NAME, null), null):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.LONG_NAME, null), null)
return appendTwoDigitYear(pivot, false):return appendTwoDigitYear(pivot, false)
throw new java.lang.IllegalArgumentException("Invalid style specification: " + style):throw new java.lang.IllegalArgumentException("Invalid style specification: " + style)
return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle):return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle)
indexRef[0] = i:indexRef[0] = i
if (index >= org.joda.time.format.DateTimeFormat.STYLE_CACHE.length) {
	return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
}:if (index >= org.joda.time.format.DateTimeFormat.STYLE_CACHE.length) {
	return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
}
return appendFraction(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, maxDigits)
i++:i++
return true:return true
return ((org.joda.time.format.DateTimeFormat.StyleFormatter) (formatter.getPrinter())).getPattern(locale):return ((org.joda.time.format.DateTimeFormat.StyleFormatter) (formatter.getPrinter())).getPattern(locale)
return org.joda.time.format.DateTimeFormat.createFormatterForStyle(style):return org.joda.time.format.DateTimeFormat.createFormatterForStyle(style)
throw new java.lang.IllegalArgumentException("Invalid pattern specification"):throw new java.lang.IllegalArgumentException("Invalid pattern specification")
if (locale == null) {
	locale = java.util.Locale.getDefault();
}:if (locale == null) {
	locale = java.util.Locale.getDefault();
}
if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



	lenientParse = false;
}:if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



	lenientParse = false;
}
throw new java.lang.IllegalArgumentException("Style '--' is invalid"):throw new java.lang.IllegalArgumentException("Style '--' is invalid")
if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.DATE;
}:if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.DATE;
}
type = org.joda.time.format.DateTimeFormat.DATE:type = org.joda.time.format.DateTimeFormat.DATE
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.NONE)
return ((org.joda.time.format.DateTimeParser) (f)):return ((org.joda.time.format.DateTimeParser) (f))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, true, minDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, true, minDigits))
switch (c) {
	case 'x' :
		builder.appendWeekyear(tokenLen, maxDigits);
		break;
	case 'y' :
		builder.appendYear(tokenLen, maxDigits);
		break;
	case 'Y' :
		builder.appendYearOfEra(tokenLen, maxDigits);
		break;}:switch (c) {
	case 'x' :
		builder.appendWeekyear(tokenLen, maxDigits);
		break;
	case 'y' :
		builder.appendYear(tokenLen, maxDigits);
		break;
	case 'Y' :
		builder.appendYearOfEra(tokenLen, maxDigits);
		break;}
return appendDecimal(org.joda.time.DateTimeFieldType.yearOfCentury(), minDigits, maxDigits):return appendDecimal(org.joda.time.DateTimeFieldType.yearOfCentury(), minDigits, maxDigits)
return new org.joda.time.format.DateTimeFormatter(printer, parser):return new org.joda.time.format.DateTimeFormatter(printer, parser)
return appendText(org.joda.time.DateTimeFieldType.monthOfYear()):return appendText(org.joda.time.DateTimeFieldType.monthOfYear())
builder.appendDayOfWeekText():builder.appendDayOfWeekText()
while ((i + 1) < length) {
	char peek = pattern.charAt(i + 1);
	if (peek == c) {
		buf.append(c);
		i++;
	} else {
		break;
	}
} :while ((i + 1) < length) {
	char $0 = pattern.charAt(i + 1);
	if ($0 == c) {
		buf.append(c);
		i++;
	} else {
		break;
	}
} 
if (((locale == null) || (id == null)) || (nameKey == null)) {
	return null;
}:if (((locale == null) || (id == null)) || (nameKey == null)) {
	return null;
}
if (dateStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.TIME;
} else { 	if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
		type = org.joda.time.format.DateTimeFormat.DATE;
	}}:if (dateStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.TIME;
} else { 	if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
		type = org.joda.time.format.DateTimeFormat.DATE;
	}}
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.NONE)
i--:i--
builder.appendMonthOfYear(tokenLen):builder.appendMonthOfYear(tokenLen)
return org.joda.time.format.DateTimeFormat.createFormatterForPattern(pattern):return org.joda.time.format.DateTimeFormat.createFormatterForPattern(pattern)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields))
int[] indexRef = new int[1]:int[] $0 = new int[1]
builder.appendMonthOfYearShortText():builder.appendMonthOfYearShortText()
for (int i = 0; i < length; i++) {
	indexRef[0] = i;
	java.lang.String token = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef);
	i = indexRef[0];

	int tokenLen = token.length();
	if (tokenLen == 0) {
		break;
	}
	char c = token.charAt(0);

	switch (c) {
		case 'G' :
			builder.appendEraText();
			break;
		case 'C' :
			builder.appendCenturyOfEra(tokenLen, tokenLen);
			break;
		case 'x' :
		case 'y' :
		case 'Y' :
			if (tokenLen == 2) {
				boolean lenientParse = true;


				if ((i + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



						lenientParse = false;
					}
					indexRef[0]--;
				}


				switch (c) {
					case 'x' :
						builder.appendTwoDigitWeekyear(
						new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
						break;
					case 'y' :
					case 'Y' :
					default :
						builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
						break;}

			} else {

				int maxDigits = 9;


				if ((i + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

						maxDigits = tokenLen;
					}
					indexRef[0]--;
				}

				switch (c) {
					case 'x' :
						builder.appendWeekyear(tokenLen, maxDigits);
						break;
					case 'y' :
						builder.appendYear(tokenLen, maxDigits);
						break;
					case 'Y' :
						builder.appendYearOfEra(tokenLen, maxDigits);
						break;}

			}
			break;
		case 'M' :
			if (tokenLen >= 3) {
				if (tokenLen >= 4) {
					builder.appendMonthOfYearText();
				} else {
					builder.appendMonthOfYearShortText();
				}
			} else {
				builder.appendMonthOfYear(tokenLen);
			}
			break;
		case 'd' :
			builder.appendDayOfMonth(tokenLen);
			break;
		case 'a' :
			builder.appendHalfdayOfDayText();
			break;
		case 'h' :
			builder.appendClockhourOfHalfday(tokenLen);
			break;
		case 'H' :
			builder.appendHourOfDay(tokenLen);
			break;
		case 'k' :
			builder.appendClockhourOfDay(tokenLen);
			break;
		case 'K' :
			builder.appendHourOfHalfday(tokenLen);
			break;
		case 'm' :
			builder.appendMinuteOfHour(tokenLen);
			break;
		case 's' :
			builder.appendSecondOfMinute(tokenLen);
			break;
		case 'S' :
			builder.appendFractionOfSecond(tokenLen, tokenLen);
			break;
		case 'e' :
			builder.appendDayOfWeek(tokenLen);
			break;
		case 'E' :
			if (tokenLen >= 4) {
				builder.appendDayOfWeekText();
			} else {
				builder.appendDayOfWeekShortText();
			}
			break;
		case 'D' :
			builder.appendDayOfYear(tokenLen);
			break;
		case 'w' :
			builder.appendWeekOfWeekyear(tokenLen);
			break;
		case 'z' :
			if (tokenLen >= 4) {
				builder.appendTimeZoneName();
			} else {
				builder.appendTimeZoneShortName(null);
			}
			break;
		case 'Z' :
			if (tokenLen == 1) {
				builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
			} else { 				if (tokenLen == 2) {
					builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
				} else {
					builder.appendTimeZoneId();
				}}
			break;
		case '\'' :
			java.lang.String sub = token.substring(1);
			if (sub.length() == 1) {
				builder.appendLiteral(sub.charAt(0));
			} else {


				builder.appendLiteral(new java.lang.String(sub));
			}
			break;
		default :
			throw new java.lang.IllegalArgumentException(
			"Illegal pattern component: " + token);}

}:for (int $0 = 0; $0 < length; $0++) {
	indexRef[0] = $0;
	java.lang.String $1 = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef);
	$0 = indexRef[0];

	int $2 = $1.length();
	if ($2 == 0) {
		break;
	}
	char $3 = $1.charAt(0);

	switch ($3) {
		case 'G' :
			builder.appendEraText();
			break;
		case 'C' :
			builder.appendCenturyOfEra($2, $2);
			break;
		case 'x' :
		case 'y' :
		case 'Y' :
			if ($2 == 2) {
				boolean $4 = true;


				if (($0 + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



						$4 = false;
					}
					indexRef[0]--;
				}


				switch ($3) {
					case 'x' :
						builder.appendTwoDigitWeekyear(
						new org.joda.time.DateTime().getWeekyear() - 30, $4);
						break;
					case 'y' :
					case 'Y' :
					default :
						builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, $4);
						break;}

			} else {

				int $5 = 9;


				if (($0 + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

						$5 = $2;
					}
					indexRef[0]--;
				}

				switch ($3) {
					case 'x' :
						builder.appendWeekyear($2, $5);
						break;
					case 'y' :
						builder.appendYear($2, $5);
						break;
					case 'Y' :
						builder.appendYearOfEra($2, $5);
						break;}

			}
			break;
		case 'M' :
			if ($2 >= 3) {
				if ($2 >= 4) {
					builder.appendMonthOfYearText();
				} else {
					builder.appendMonthOfYearShortText();
				}
			} else {
				builder.appendMonthOfYear($2);
			}
			break;
		case 'd' :
			builder.appendDayOfMonth($2);
			break;
		case 'a' :
			builder.appendHalfdayOfDayText();
			break;
		case 'h' :
			builder.appendClockhourOfHalfday($2);
			break;
		case 'H' :
			builder.appendHourOfDay($2);
			break;
		case 'k' :
			builder.appendClockhourOfDay($2);
			break;
		case 'K' :
			builder.appendHourOfHalfday($2);
			break;
		case 'm' :
			builder.appendMinuteOfHour($2);
			break;
		case 's' :
			builder.appendSecondOfMinute($2);
			break;
		case 'S' :
			builder.appendFractionOfSecond($2, $2);
			break;
		case 'e' :
			builder.appendDayOfWeek($2);
			break;
		case 'E' :
			if ($2 >= 4) {
				builder.appendDayOfWeekText();
			} else {
				builder.appendDayOfWeekShortText();
			}
			break;
		case 'D' :
			builder.appendDayOfYear($2);
			break;
		case 'w' :
			builder.appendWeekOfWeekyear($2);
			break;
		case 'z' :
			if ($2 >= 4) {
				builder.appendTimeZoneName();
			} else {
				builder.appendTimeZoneShortName(null);
			}
			break;
		case 'Z' :
			if ($2 == 1) {
				builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
			} else { 				if ($2 == 2) {
					builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
				} else {
					builder.appendTimeZoneId();
				}}
			break;
		case '\'' :
			java.lang.String $6 = $1.substring(1);
			if ($6.length() == 1) {
				builder.appendLiteral($6.charAt(0));
			} else {


				builder.appendLiteral(new java.lang.String($6));
			}
			break;
		default :
			throw new java.lang.IllegalArgumentException(
			"Illegal pattern component: " + $1);}

}
return appendDecimal(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, 5):return appendDecimal(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, 5)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.FULL):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.FULL)
if ((style == null) || (style.length() != 2)) {
	throw new java.lang.IllegalArgumentException("Invalid style specification: " + style);
}:if ((style == null) || (style.length() != 2)) {
	throw new java.lang.IllegalArgumentException("Invalid style specification: " + style);
}
switch (c) {
	case 'G' :
		builder.appendEraText();
		break;
	case 'C' :
		builder.appendCenturyOfEra(tokenLen, tokenLen);
		break;
	case 'x' :
	case 'y' :
	case 'Y' :
		if (tokenLen == 2) {
			boolean lenientParse = true;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



					lenientParse = false;
				}
				indexRef[0]--;
			}


			switch (c) {
				case 'x' :
					builder.appendTwoDigitWeekyear(
					new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
					break;
				case 'y' :
				case 'Y' :
				default :
					builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
					break;}

		} else {

			int maxDigits = 9;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

					maxDigits = tokenLen;
				}
				indexRef[0]--;
			}

			switch (c) {
				case 'x' :
					builder.appendWeekyear(tokenLen, maxDigits);
					break;
				case 'y' :
					builder.appendYear(tokenLen, maxDigits);
					break;
				case 'Y' :
					builder.appendYearOfEra(tokenLen, maxDigits);
					break;}

		}
		break;
	case 'M' :
		if (tokenLen >= 3) {
			if (tokenLen >= 4) {
				builder.appendMonthOfYearText();
			} else {
				builder.appendMonthOfYearShortText();
			}
		} else {
			builder.appendMonthOfYear(tokenLen);
		}
		break;
	case 'd' :
		builder.appendDayOfMonth(tokenLen);
		break;
	case 'a' :
		builder.appendHalfdayOfDayText();
		break;
	case 'h' :
		builder.appendClockhourOfHalfday(tokenLen);
		break;
	case 'H' :
		builder.appendHourOfDay(tokenLen);
		break;
	case 'k' :
		builder.appendClockhourOfDay(tokenLen);
		break;
	case 'K' :
		builder.appendHourOfHalfday(tokenLen);
		break;
	case 'm' :
		builder.appendMinuteOfHour(tokenLen);
		break;
	case 's' :
		builder.appendSecondOfMinute(tokenLen);
		break;
	case 'S' :
		builder.appendFractionOfSecond(tokenLen, tokenLen);
		break;
	case 'e' :
		builder.appendDayOfWeek(tokenLen);
		break;
	case 'E' :
		if (tokenLen >= 4) {
			builder.appendDayOfWeekText();
		} else {
			builder.appendDayOfWeekShortText();
		}
		break;
	case 'D' :
		builder.appendDayOfYear(tokenLen);
		break;
	case 'w' :
		builder.appendWeekOfWeekyear(tokenLen);
		break;
	case 'z' :
		if (tokenLen >= 4) {
			builder.appendTimeZoneName();
		} else {
			builder.appendTimeZoneShortName(null);
		}
		break;
	case 'Z' :
		if (tokenLen == 1) {
			builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
		} else { 			if (tokenLen == 2) {
				builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
			} else {
				builder.appendTimeZoneId();
			}}
		break;
	case '\'' :
		java.lang.String sub = token.substring(1);
		if (sub.length() == 1) {
			builder.appendLiteral(sub.charAt(0));
		} else {


			builder.appendLiteral(new java.lang.String(sub));
		}
		break;
	default :
		throw new java.lang.IllegalArgumentException(
		"Illegal pattern component: " + token);}:switch (c) {
	case 'G' :
		builder.appendEraText();
		break;
	case 'C' :
		builder.appendCenturyOfEra(tokenLen, tokenLen);
		break;
	case 'x' :
	case 'y' :
	case 'Y' :
		if (tokenLen == 2) {
			boolean $0 = true;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



					$0 = false;
				}
				indexRef[0]--;
			}


			switch (c) {
				case 'x' :
					builder.appendTwoDigitWeekyear(
					new org.joda.time.DateTime().getWeekyear() - 30, $0);
					break;
				case 'y' :
				case 'Y' :
				default :
					builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, $0);
					break;}

		} else {

			int $1 = 9;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

					$1 = tokenLen;
				}
				indexRef[0]--;
			}

			switch (c) {
				case 'x' :
					builder.appendWeekyear(tokenLen, $1);
					break;
				case 'y' :
					builder.appendYear(tokenLen, $1);
					break;
				case 'Y' :
					builder.appendYearOfEra(tokenLen, $1);
					break;}

		}
		break;
	case 'M' :
		if (tokenLen >= 3) {
			if (tokenLen >= 4) {
				builder.appendMonthOfYearText();
			} else {
				builder.appendMonthOfYearShortText();
			}
		} else {
			builder.appendMonthOfYear(tokenLen);
		}
		break;
	case 'd' :
		builder.appendDayOfMonth(tokenLen);
		break;
	case 'a' :
		builder.appendHalfdayOfDayText();
		break;
	case 'h' :
		builder.appendClockhourOfHalfday(tokenLen);
		break;
	case 'H' :
		builder.appendHourOfDay(tokenLen);
		break;
	case 'k' :
		builder.appendClockhourOfDay(tokenLen);
		break;
	case 'K' :
		builder.appendHourOfHalfday(tokenLen);
		break;
	case 'm' :
		builder.appendMinuteOfHour(tokenLen);
		break;
	case 's' :
		builder.appendSecondOfMinute(tokenLen);
		break;
	case 'S' :
		builder.appendFractionOfSecond(tokenLen, tokenLen);
		break;
	case 'e' :
		builder.appendDayOfWeek(tokenLen);
		break;
	case 'E' :
		if (tokenLen >= 4) {
			builder.appendDayOfWeekText();
		} else {
			builder.appendDayOfWeekShortText();
		}
		break;
	case 'D' :
		builder.appendDayOfYear(tokenLen);
		break;
	case 'w' :
		builder.appendWeekOfWeekyear(tokenLen);
		break;
	case 'z' :
		if (tokenLen >= 4) {
			builder.appendTimeZoneName();
		} else {
			builder.appendTimeZoneShortName(null);
		}
		break;
	case 'Z' :
		if (tokenLen == 1) {
			builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
		} else { 			if (tokenLen == 2) {
				builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
			} else {
				builder.appendTimeZoneId();
			}}
		break;
	case '\'' :
		java.lang.String $2 = token.substring(1);
		if ($2.length() == 1) {
			builder.appendLiteral($2.charAt(0));
		} else {


			builder.appendLiteral(new java.lang.String($2));
		}
		break;
	default :
		throw new java.lang.IllegalArgumentException(
		"Illegal pattern component: " + token);}
org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder():org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder()
return appendTwoDigitWeekyear(pivot, false):return appendTwoDigitWeekyear(pivot, false)
buf.append('\''):buf.append('\'')
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.NONE)
org.joda.time.format.DateTimeFormat.StyleFormatter llf = new org.joda.time.format.DateTimeFormat.StyleFormatter(dateStyle, timeStyle, type):org.joda.time.format.DateTimeFormat.StyleFormatter $0 = new org.joda.time.format.DateTimeFormat.StyleFormatter(dateStyle, timeStyle, type)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.LONG):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.LONG)
return appendDecimal(org.joda.time.DateTimeFieldType.yearOfEra(), minDigits, maxDigits):return appendDecimal(org.joda.time.DateTimeFieldType.yearOfEra(), minDigits, maxDigits)
return rename((iNameKey + appendNameKey).intern()):return rename((iNameKey + appendNameKey).intern())
indexRef[0]++:indexRef[0]++
if (tokenLen == 0) {
	break;
}:if (tokenLen == 0) {
	break;
}
return appendShortText(org.joda.time.DateTimeFieldType.dayOfWeek()):return appendShortText(org.joda.time.DateTimeFieldType.dayOfWeek())
return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, true))
if (setEn[2].equals(setEn[4])) {
	byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
} else {
	byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
}:if (setEn[2].equals(setEn[4])) {
	byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
} else {
	byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
}
return appendFraction(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, maxDigits)
long nextOffset = wallOffsets[i + 1]:long $0 = wallOffsets[i + 1]
return isParser(getFormatter()):return isParser(getFormatter())
org.joda.time.format.DateTimeFormatter formatter = org.joda.time.format.DateTimeFormat.createFormatterForStyle(style):org.joda.time.format.DateTimeFormatter $0 = org.joda.time.format.DateTimeFormat.createFormatterForStyle(style)
if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

		maxDigits = tokenLen;
	}
	indexRef[0]--;
}:if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

		maxDigits = tokenLen;
	}
	indexRef[0]--;
}
org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone other = ((org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone) (obj)):org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone $0 = ((org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone) (obj))
org.joda.time.format.DateTimeFormatter formatter = null:org.joda.time.format.DateTimeFormatter $0 = null
long[] transitions = iTransitions:long[] $0 = iTransitions
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.SHORT):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.SHORT)
java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
tailZone.iStartRecurrence.getNameKey()):java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
tailZone.iStartRecurrence.getNameKey())
return iNameKeys[i - 1]:return iNameKeys[i - 1]
java.lang.String nameKey = iNameKeys[i]:java.lang.String $0 = iNameKeys[i]
org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern):org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern)
return append0(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE, org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE):return append0(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE, org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE)
if (f == null) {
	f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
	org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
}:if (f == null) {
	f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
	org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
}
return transitions[i]:return transitions[i]
return append0(formatter.getPrinter(), formatter.getParser()):return append0(formatter.getPrinter(), formatter.getParser())
return append0(printer, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(copyOfParsers)):return append0(printer, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(copyOfParsers))
for (int i = 0; i < size; i++) {
	org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iTransitions[i]);
	org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iWallOffsets[i]);
	org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iStandardOffsets[i]);


	java.lang.String nameKey = iNameKeys[i];
	for (int j = 0; j < poolSize; j++) {
		if (pool[j].equals(nameKey)) {
			if (poolSize < 256) {
				out.writeByte(j);
			} else {
				out.writeShort(j);
			}
			break;
		}
	}
}:for (int $0 = 0; $0 < size; $0++) {
	org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iTransitions[$0]);
	org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iWallOffsets[$0]);
	org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iStandardOffsets[$0]);


	java.lang.String $1 = iNameKeys[$0];
	for (int $2 = 0; $2 < poolSize; $2++) {
		if (pool[$2].equals($1)) {
			if (poolSize < 256) {
				out.writeByte($2);
			} else {
				out.writeShort($2);
			}
			break;
		}
	}
}
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis)
return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfHour(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfHour(), minDigits, 2)
if (tokenLen >= 4) {
	builder.appendMonthOfYearText();
} else {
	builder.appendMonthOfYearShortText();
}:if (tokenLen >= 4) {
	builder.appendMonthOfYearText();
} else {
	builder.appendMonthOfYearShortText();
}
if (poolSize < 256) {
	out.writeByte(j);
} else {
	out.writeShort(j);
}:if (poolSize < 256) {
	out.writeByte(j);
} else {
	out.writeShort(j);
}
builder.appendTimeZoneOffset(null, "Z", true, 2, 2):builder.appendTimeZoneOffset(null, "Z", true, 2, 2)
return appendSignedDecimal(org.joda.time.DateTimeFieldType.centuryOfEra(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.centuryOfEra(), minDigits, maxDigits)
if (poolSize > 65535) {
	throw new java.lang.UnsupportedOperationException("String pool is too large");
}:if (poolSize > 65535) {
	throw new java.lang.UnsupportedOperationException("String pool is too large");
}
iTailZone.writeTo(out):iTailZone.writeTo(out)
return append0(null, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(parsers)):return append0(null, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(parsers))
return iTailZone.getNameKey(instant):return iTailZone.getNameKey(instant)
long diff = transitions[i] - transitions[i - 1]:long $0 = transitions[i] - transitions[i - 1]
builder.appendMonthOfYearText():builder.appendMonthOfYearText()
if (diff < (((((366L + 365) * 24) * 60) * 60) * 1000)) {
	distances += ((double) (diff));
	count++;
}:if (diff < (((((366L + 365) * 24) * 60) * 60) * 1000)) {
	distances += ((double) (diff));
	count++;
}
return ((org.joda.time.format.DateTimePrinter) (f)):return ((org.joda.time.format.DateTimePrinter) (f))
return appendDecimal(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, 2)
builder.appendLiteral(new java.lang.String(sub)):builder.appendLiteral(new java.lang.String(sub))
synchronized(org.joda.time.format.DateTimeFormat.PATTERN_CACHE) {
	formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern);
	if (formatter == null) {
		org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder();
		org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern);
		formatter = builder.toFormatter();

		org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
	}
}:synchronized(org.joda.time.format.DateTimeFormat.PATTERN_CACHE) {
	formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern);
	if (formatter == null) {
		org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder();
		org.joda.time.format.DateTimeFormat.parsePatternTo($0, pattern);
		formatter = $0.toFormatter();

		org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
	}
}
return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfDay(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfDay(), minDigits, 2)
return appendText(org.joda.time.DateTimeFieldType.era()):return appendText(org.joda.time.DateTimeFieldType.era())
java.lang.String token = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef):java.lang.String $0 = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef)
char c = pattern.charAt(i):char $0 = pattern.charAt(i)
boolean inLiteral = false:boolean $0 = false
if (prev < instant) {
	return prev;
}:if (prev < instant) {
	return prev;
}
for (int i = 0; i < poolSize; i++) {
	out.writeUTF(pool[i]);
}:for (int $0 = 0; $0 < poolSize; $0++) {
	out.writeUTF(pool[$0]);
}
int[] standardOffsets = new int[size]:int[] $0 = new int[size]
return 
((((getID().equals(other.getID()) && 
java.util.Arrays.equals(iTransitions, other.iTransitions)) && 
java.util.Arrays.equals(iNameKeys, other.iNameKeys)) && 
java.util.Arrays.equals(iWallOffsets, other.iWallOffsets)) && 
java.util.Arrays.equals(iStandardOffsets, other.iStandardOffsets)) && 
(iTailZone == null ? 
null == other.iTailZone : 
iTailZone.equals(other.iTailZone)):return 
((((getID().equals(other.getID()) && 
java.util.Arrays.equals(iTransitions, other.iTransitions)) && 
java.util.Arrays.equals(iNameKeys, other.iNameKeys)) && 
java.util.Arrays.equals(iWallOffsets, other.iWallOffsets)) && 
java.util.Arrays.equals(iStandardOffsets, other.iStandardOffsets)) && 
(iTailZone == null ? 
null == other.iTailZone : 
iTailZone.equals(other.iTailZone))
if (i < transitions.length) {
	if (i > 0) {
		return iWallOffsets[i - 1];
	}
	return 0;
}:if (i < transitions.length) {
	if (i > 0) {
		return iWallOffsets[i - 1];
	}
	return 0;
}
maxDigits = tokenLen:maxDigits = tokenLen
return append0(new org.joda.time.format.DateTimeFormatterBuilder.Fraction(fieldType, minDigits, maxDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.Fraction(fieldType, minDigits, maxDigits))
if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



		lenientParse = false;
	}
	indexRef[0]--;
}:if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



		lenientParse = false;
	}
	indexRef[0]--;
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, true))
if (curOffset < nextOffset) {
	nameKeys[i + 1] = (nextNameKey + "-Summer").intern();
	i++;
}:if (curOffset < nextOffset) {
	nameKeys[i + 1] = (nextNameKey + "-Summer").intern();
	i++;
}
return appendFraction(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, maxDigits)
if (poolSize < 256) {
	index = in.readUnsignedByte();
} else {
	index = in.readUnsignedShort();
}:if (poolSize < 256) {
	index = in.readUnsignedByte();
} else {
	index = in.readUnsignedShort();
}
int[] wallOffsets = new int[size]:int[] $0 = new int[size]
iNameKeys = nameKeys:iNameKeys = nameKeys
return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear):return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear)
int maxDigits = 9:int $0 = 9
return appendText(org.joda.time.DateTimeFieldType.dayOfWeek()):return appendText(org.joda.time.DateTimeFieldType.dayOfWeek())
tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
tailZone.getID(), 
tailZone.iStandardOffset, 
tailZone.iStartRecurrence, 
tailZone.iEndRecurrence.renameAppend("-Summer")):tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
tailZone.getID(), 
tailZone.iStandardOffset, 
tailZone.iStartRecurrence, 
tailZone.iEndRecurrence.renameAppend("-Summer"))
if (iTailZone != null) {
	return true;
}:if (iTailZone != null) {
	return true;
}
return iSaveMillis:return iSaveMillis
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, 3):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, 3)
if (byIdCache == null) {
	iByLocaleCache.put(locale, byIdCache = createCache());
}:if (byIdCache == null) {
	iByLocaleCache.put(locale, byIdCache = createCache());
}
locale = java.util.Locale.getDefault():locale = java.util.Locale.getDefault()
index = in.readUnsignedShort():index = in.readUnsignedShort()
iTransitions = transitions:iTransitions = transitions
return new org.joda.time.format.DateTimeFormatter(llf, llf):return new org.joda.time.format.DateTimeFormatter(llf, llf)
return iOfYear.previous(instant, standardOffset, saveMillis):return iOfYear.previous(instant, standardOffset, saveMillis)
tailZone = org.joda.time.tz.DateTimeZoneBuilder.DSTZone.readFrom(in, id):tailZone = org.joda.time.tz.DateTimeZoneBuilder.DSTZone.readFrom(in, id)
return isPrinter(getFormatter()):return isPrinter(getFormatter())
if (obj instanceof org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone) {
	org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone other = ((org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone) (obj));
	return 
	((((getID().equals(other.getID()) && 
	java.util.Arrays.equals(iTransitions, other.iTransitions)) && 
	java.util.Arrays.equals(iNameKeys, other.iNameKeys)) && 
	java.util.Arrays.equals(iWallOffsets, other.iWallOffsets)) && 
	java.util.Arrays.equals(iStandardOffsets, other.iStandardOffsets)) && 
	(iTailZone == null ? 
	null == other.iTailZone : 
	iTailZone.equals(other.iTailZone));
}:if (obj instanceof org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone) {
	org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone $0 = ((org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone) (obj));
	return 
	((((getID().equals($0.getID()) && 
	java.util.Arrays.equals(iTransitions, $0.iTransitions)) && 
	java.util.Arrays.equals(iNameKeys, $0.iNameKeys)) && 
	java.util.Arrays.equals(iWallOffsets, $0.iWallOffsets)) && 
	java.util.Arrays.equals(iStandardOffsets, $0.iStandardOffsets)) && 
	(iTailZone == null ? 
	null == $0.iTailZone : 
	iTailZone.equals($0.iTailZone));
}
instant = end:instant = end
return appendDecimal(org.joda.time.DateTimeFieldType.weekOfWeekyear(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.weekOfWeekyear(), minDigits, 2)
return isFormatter(getFormatter()):return isFormatter(getFormatter())
long prev = iTailZone.previousTransition(instant):long $0 = iTailZone.previousTransition(instant)
return append0(printer, null):return append0(printer, null)
lenientParse = false:lenientParse = false
if (iTailZone != null) {
	iTailZone.writeTo(out);
}:if (iTailZone != null) {
	iTailZone.writeTo(out);
}
avg /= ((24 * 60) * 60) * 1000:avg /= ((24 * 60) * 60) * 1000
java.lang.StringBuilder buf = new java.lang.StringBuilder():java.lang.StringBuilder $0 = new java.lang.StringBuilder()
tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
tailZone.getID(), 
tailZone.iStandardOffset, 
tailZone.iStartRecurrence.renameAppend("-Summer"), 
tailZone.iEndRecurrence):tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
tailZone.getID(), 
tailZone.iStandardOffset, 
tailZone.iStartRecurrence.renameAppend("-Summer"), 
tailZone.iEndRecurrence)
char c = token.charAt(0):char $0 = token.charAt(0)
return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isParser():return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isParser()
if (formatter == null) {
	org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder();
	org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern);
	formatter = builder.toFormatter();

	org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
}:if (formatter == null) {
	org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder();
	org.joda.time.format.DateTimeFormat.parsePatternTo($0, pattern);
	formatter = $0.toFormatter();

	org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
}
int size = iTransitions.length:int $0 = iTransitions.length
c = pattern.charAt(i):c = pattern.charAt(i)
for (; i < length; i++) {
	c = pattern.charAt(i);

	if (c == '\'') {
		if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

			i++;
			buf.append(c);
		} else {
			inLiteral = !inLiteral;
		}
	} else { 		if ((!inLiteral) && 
		(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
			i--;
			break;
		} else {
			buf.append(c);
		}}
}:for (; i < length; i++) {
	c = pattern.charAt(i);

	if (c == '\'') {
		if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

			i++;
			buf.append(c);
		} else {
			inLiteral = !inLiteral;
		}
	} else { 		if ((!inLiteral) && 
		(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
			i--;
			break;
		} else {
			buf.append(c);
		}}
}
pool[i] = in.readUTF():pool[i] = in.readUTF()
return this:return this
int i = java.util.Arrays.binarySearch(transitions, instant):int $0 = java.util.Arrays.binarySearch(transitions, instant)
f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle):f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle)
builder.appendTimeZoneShortName(null):builder.appendTimeZoneShortName(null)
nameKeys[i] = tr.getNameKey():nameKeys[i] = tr.getNameKey()
return append0(null, parser):return append0(null, parser)
java.lang.String[] pool = new java.lang.String[poolSize]:java.lang.String[] $0 = new java.lang.String[poolSize]
org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter):org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter)
if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setLoc = strings;
	break;
}:if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setLoc = strings;
	break;
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields))
return new org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone(
id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone):return new org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone(
id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone)
return new org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone(
outputID ? id : "", trans, wallOffsets, standardOffsets, nameKeys, tailZone):return new org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone(
outputID ? id : "", trans, wallOffsets, standardOffsets, nameKeys, tailZone)
if (i > 0) {
	return iNameKeys[i - 1];
}:if (i > 0) {
	return iNameKeys[i - 1];
}
if (byNameKeyCache == null) {
	byIdCache.put(id, byNameKeyCache = createCache());

	java.lang.String[][] $0 = org.joda.time.DateTimeUtils.getDateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings();
	java.lang.String[] $1 = null;
	for (java.lang.String[] $2 : $0) {
		if ((($2 != null) && ($2.length == 5)) && id.equals($2[0])) {
			$1 = $2;
			break;
		}
	}
	java.lang.String[][] $3 = org.joda.time.DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
	java.lang.String[] $4 = null;
	for (java.lang.String[] $5 : $3) {
		if ((($5 != null) && ($5.length == 5)) && id.equals($5[0])) {
			$4 = $5;
			break;
		}
	}

	if (($1 != null) && ($4 != null)) {
		byNameKeyCache.put($1[2], new java.lang.String[]{ $4[2], $4[1] });



		if ($1[2].equals($1[4])) {
			byNameKeyCache.put($1[4] + "-Summer", new java.lang.String[]{ $4[4], $4[3] });
		} else {
			byNameKeyCache.put($1[4], new java.lang.String[]{ $4[4], $4[3] });
		}
	}
}:if (byNameKeyCache == null) {
	byIdCache.put(id, byNameKeyCache = createCache());

	java.lang.String[][] $0 = org.joda.time.DateTimeUtils.getDateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings();
	java.lang.String[] $1 = null;
	for (java.lang.String[] $2 : $0) {
		if ((($2 != null) && ($2.length == 5)) && id.equals($2[0])) {
			$1 = $2;
			break;
		}
	}
	java.lang.String[][] $3 = org.joda.time.DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
	java.lang.String[] $4 = null;
	for (java.lang.String[] $5 : $3) {
		if ((($5 != null) && ($5.length == 5)) && id.equals($5[0])) {
			$4 = $5;
			break;
		}
	}

	if (($1 != null) && ($4 != null)) {
		byNameKeyCache.put($1[2], new java.lang.String[]{ $4[2], $4[1] });



		if ($1[2].equals($1[4])) {
			byNameKeyCache.put($1[4] + "-Summer", new java.lang.String[]{ $4[4], $4[3] });
		} else {
			byNameKeyCache.put($1[4], new java.lang.String[]{ $4[4], $4[3] });
		}
	}
}
throw new java.io.IOException("Invalid encoding"):throw new java.io.IOException("Invalid encoding")
builder.appendTimeZoneName():builder.appendTimeZoneName()
return append0(printer, parser):return append0(printer, parser)
int size = in.readInt():int $0 = in.readInt()
switch (ch) {
	case 'S' :
		return org.joda.time.format.DateTimeFormat.SHORT;
	case 'M' :
		return org.joda.time.format.DateTimeFormat.MEDIUM;
	case 'L' :
		return org.joda.time.format.DateTimeFormat.LONG;
	case 'F' :
		return org.joda.time.format.DateTimeFormat.FULL;
	case '-' :
		return org.joda.time.format.DateTimeFormat.NONE;
	default :
		throw new java.lang.IllegalArgumentException("Invalid style character: " + ch);}:switch (ch) {
	case 'S' :
		return org.joda.time.format.DateTimeFormat.SHORT;
	case 'M' :
		return org.joda.time.format.DateTimeFormat.MEDIUM;
	case 'L' :
		return org.joda.time.format.DateTimeFormat.LONG;
	case 'F' :
		return org.joda.time.format.DateTimeFormat.FULL;
	case '-' :
		return org.joda.time.format.DateTimeFormat.NONE;
	default :
		throw new java.lang.IllegalArgumentException("Invalid style character: " + ch);}
java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[i], chrono)) + 
" - ") + new org.joda.time.DateTime(trans[i + 1], chrono)):java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[i], chrono)) + 
" - ") + new org.joda.time.DateTime(trans[i + 1], chrono))
return iTailZone.getOffset(instant):return iTailZone.getOffset(instant)
return appendShortText(org.joda.time.DateTimeFieldType.monthOfYear()):return appendShortText(org.joda.time.DateTimeFieldType.monthOfYear())
java.util.Set<java.lang.String> poolSet = new java.util.HashSet<java.lang.String>():java.util.Set<java.lang.String> $0 = new java.util.HashSet<java.lang.String>()
return formatter:return formatter
double avg = distances / count:double $0 = distances / count
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(dateStyle, timeStyle):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(dateStyle, timeStyle)
org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f:org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f
poolSet.add(iNameKeys[i]):poolSet.add(iNameKeys[i])
return buf.toString():return buf.toString()
trans[i] = tr.getMillis():trans[i] = tr.getMillis()
type = org.joda.time.format.DateTimeFormat.TIME:type = org.joda.time.format.DateTimeFormat.TIME
if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

	i++;
	buf.append(c);
} else {
	inLiteral = !inLiteral;
}:if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

	i++;
	buf.append(c);
} else {
	inLiteral = !inLiteral;
}
return appendSignedDecimal(org.joda.time.DateTimeFieldType.weekyear(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.weekyear(), minDigits, maxDigits)
for (int i = 0; i < size; i++) {
	transitions[i] = org.joda.time.tz.DateTimeZoneBuilder.readMillis(in);
	wallOffsets[i] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)));
	standardOffsets[i] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)));
	try {
		int index;
		if (poolSize < 256) {
			index = in.readUnsignedByte();
		} else {
			index = in.readUnsignedShort();
		}
		nameKeys[i] = pool[index];
	} catch (java.lang.ArrayIndexOutOfBoundsException e) {
		throw new java.io.IOException("Invalid encoding");
	}
}:for (int $0 = 0; $0 < size; $0++) {
	transitions[$0] = org.joda.time.tz.DateTimeZoneBuilder.readMillis(in);
	wallOffsets[$0] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)));
	standardOffsets[$0] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)));
	try {
		int $1;
		if (poolSize < 256) {
			$1 = in.readUnsignedByte();
		} else {
			$1 = in.readUnsignedShort();
		}
		nameKeys[$0] = pool[$1];
	} catch (java.lang.ArrayIndexOutOfBoundsException e) {
		throw new java.io.IOException("Invalid encoding");
	}
}
if (instant < end) {
	instant = end;
}:if (instant < end) {
	instant = end;
}
f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index]:f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index]
out.writeByte(j):out.writeByte(j)
if (i < transitions.length) {
	if (i > 0) {
		return iStandardOffsets[i - 1];
	}
	return 0;
}:if (i < transitions.length) {
	if (i > 0) {
		return iStandardOffsets[i - 1];
	}
	return 0;
}
return appendDecimal(org.joda.time.DateTimeFieldType.hourOfHalfday(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.hourOfHalfday(), minDigits, 2)
if (i >= 0) {
	return iNameKeys[i];
}:if (i >= 0) {
	return iNameKeys[i];
}
return append0(printer, parsers[0]):return append0(printer, parsers[0])
return f:return f
org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iStandardOffsets[i]):org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iStandardOffsets[i])
java.lang.String[] nameKeys = new java.lang.String[size]:java.lang.String[] $0 = new java.lang.String[size]
formatter = builder.toFormatter():formatter = builder.toFormatter()
i = ~i:i = ~i
int i = indexRef[0]:int $0 = indexRef[0]
if (byNameKeyCache == null) {
	byIdCache.put(id, byNameKeyCache = createCache());

	java.lang.String[][] zoneStringsEn = org.joda.time.DateTimeUtils.getDateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings();
	java.lang.String[] setEn = null;
	for (java.lang.String[] strings : zoneStringsEn) {
		if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
			setEn = strings;
			break;
		}
	}
	java.lang.String[][] zoneStringsLoc = org.joda.time.DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
	java.lang.String[] setLoc = null;
	for (java.lang.String[] strings : zoneStringsLoc) {
		if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
			setLoc = strings;
			break;
		}
	}

	if ((setEn != null) && (setLoc != null)) {
		byNameKeyCache.put(setEn[2], new java.lang.String[]{ setLoc[2], setLoc[1] });



		if (setEn[2].equals(setEn[4])) {
			byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
		} else {
			byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
		}
	}
}:if (byNameKeyCache == null) {
	byIdCache.put(id, byNameKeyCache = createCache());

	java.lang.String[][] $0 = org.joda.time.DateTimeUtils.getDateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings();
	java.lang.String[] $1 = null;
	for (java.lang.String[] $2 : $0) {
		if ((($2 != null) && ($2.length == 5)) && id.equals($2[0])) {
			$1 = $2;
			break;
		}
	}
	java.lang.String[][] $3 = org.joda.time.DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
	java.lang.String[] $4 = null;
	for (java.lang.String[] $5 : $3) {
		if ((($5 != null) && ($5.length == 5)) && id.equals($5[0])) {
			$4 = $5;
			break;
		}
	}

	if (($1 != null) && ($4 != null)) {
		byNameKeyCache.put($1[2], new java.lang.String[]{ $4[2], $4[1] });



		if ($1[2].equals($1[4])) {
			byNameKeyCache.put($1[4] + "-Summer", new java.lang.String[]{ $4[4], $4[3] });
		} else {
			byNameKeyCache.put($1[4], new java.lang.String[]{ $4[4], $4[3] });
		}
	}
}
if (i < transitions.length) {
	if (i > 0) {
		return iNameKeys[i - 1];
	}
	return "UTC";
}:if (i < transitions.length) {
	if (i > 0) {
		return iNameKeys[i - 1];
	}
	return "UTC";
}
int count = 0:int $0 = 0
return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, false))
standardOffsets[i] = tr.getStandardOffset():standardOffsets[i] = tr.getStandardOffset()
builder.appendTimeZoneId():builder.appendTimeZoneId()
if (iTailZone == null) {
	return instant;
}:if (iTailZone == null) {
	return instant;
}
char peek = pattern.charAt(i + 1):char $0 = pattern.charAt(i + 1)
inLiteral = !inLiteral:inLiteral = !inLiteral
org.joda.time.format.DateTimeFormatter f = null:org.joda.time.format.DateTimeFormatter $0 = null
if (tailZone.iStartRecurrence.getSaveMillis() > 0) {
	tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
	tailZone.getID(), 
	tailZone.iStandardOffset, 
	tailZone.iStartRecurrence.renameAppend("-Summer"), 
	tailZone.iEndRecurrence);
} else {
	tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
	tailZone.getID(), 
	tailZone.iStandardOffset, 
	tailZone.iStartRecurrence, 
	tailZone.iEndRecurrence.renameAppend("-Summer"));
}:if (tailZone.iStartRecurrence.getSaveMillis() > 0) {
	tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
	tailZone.getID(), 
	tailZone.iStandardOffset, 
	tailZone.iStartRecurrence.renameAppend("-Summer"), 
	tailZone.iEndRecurrence);
} else {
	tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
	tailZone.getID(), 
	tailZone.iStandardOffset, 
	tailZone.iStartRecurrence, 
	tailZone.iEndRecurrence.renameAppend("-Summer"));
}
int index:int $0
org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iTransitions[i]):org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iTransitions[i])
double distances = 0:double $0 = 0
int tokenLen = token.length():int $0 = token.length()
if (((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) {


	buf.append(c);

	while ((i + 1) < length) {
		char peek = pattern.charAt(i + 1);
		if (peek == c) {
			buf.append(c);
			i++;
		} else {
			break;
		}
	} 
} else {

	buf.append('\'');

	boolean inLiteral = false;

	for (; i < length; i++) {
		c = pattern.charAt(i);

		if (c == '\'') {
			if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

				i++;
				buf.append(c);
			} else {
				inLiteral = !inLiteral;
			}
		} else { 			if ((!inLiteral) && 
			(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
				i--;
				break;
			} else {
				buf.append(c);
			}}
	}
}:if (((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) {


	buf.append(c);

	while ((i + 1) < length) {
		char $0 = pattern.charAt(i + 1);
		if ($0 == c) {
			buf.append(c);
			i++;
		} else {
			break;
		}
	} 
} else {

	buf.append('\'');

	boolean $1 = false;

	for (; i < length; i++) {
		c = pattern.charAt(i);

		if (c == '\'') {
			if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

				i++;
				buf.append(c);
			} else {
				$1 = !$1;
			}
		} else { 			if ((!$1) && 
			(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
				i--;
				break;
			} else {
				buf.append(c);
			}}
	}
}
synchronized(org.joda.time.format.DateTimeFormat.STYLE_CACHE) {
	f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index];
	if (f == null) {
		f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
		org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
	}
}:synchronized(org.joda.time.format.DateTimeFormat.STYLE_CACHE) {
	f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index];
	if (f == null) {
		f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
		org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
	}
}
last = tr:last = tr
return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, false, minDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, false, minDigits))
int length = pattern.length():int $0 = pattern.length()
for (int i = 1; i < transitions.length; i++) {
	long diff = transitions[i] - transitions[i - 1];
	if (diff < (((((366L + 365) * 24) * 60) * 60) * 1000)) {
		distances += ((double) (diff));
		count++;
	}
}:for (int $0 = 1; $0 < transitions.length; $0++) {
	long $1 = transitions[$0] - transitions[$0 - 1];
	if ($1 < (((((366L + 365) * 24) * 60) * 60) * 1000)) {
		distances += ((double) ($1));
		count++;
	}
}
return iOfYear.next(instant, standardOffset, saveMillis):return iOfYear.next(instant, standardOffset, saveMillis)
java.lang.String curNameKey = nameKeys[i]:java.lang.String $0 = nameKeys[i]
return "UTC":return "UTC"
return iNameKey:return iNameKey
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.SHORT_NAME, null), null):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.SHORT_NAME, null), null)
return appendFraction(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, maxDigits)
builder.appendDayOfWeekShortText():builder.appendDayOfWeekShortText()
return append0(new org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral(c)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral(c))
java.lang.String nextNameKey = nameKeys[i + 1]:java.lang.String $0 = nameKeys[i + 1]
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, false))
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.LONG):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.LONG)
if (tokenLen == 2) {
	builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
} else {
	builder.appendTimeZoneId();
}:if (tokenLen == 2) {
	builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
} else {
	builder.appendTimeZoneId();
}
if ((!inLiteral) && 
(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
	i--;
	break;
} else {
	buf.append(c);
}:if ((!inLiteral) && 
(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
	i--;
	break;
} else {
	buf.append(c);
}
return 0:return 0
int dateStyle = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(0)):int $0 = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(0))
for (int j = 0; j < zoneStrings.length; j++) {
	java.lang.String[] set = zoneStrings[j];
	if (((set != null) && (set.length == 5)) && id.equals(set[0])) {
		zoneNameData = set;
	}
}:for (int $0 = 0; $0 < zoneStrings.length; $0++) {
	java.lang.String[] $1 = zoneStrings[$0];
	if ((($1 != null) && ($1.length == 5)) && id.equals($1[0])) {
		zoneNameData = $1;
	}
}
return isPrinter(f) || isParser(f):return isPrinter(f) || isParser(f)
index = in.readUnsignedByte():index = in.readUnsignedByte()
int poolSize = in.readUnsignedShort():int $0 = in.readUnsignedShort()
standardOffsets[i] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in))):standardOffsets[i] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)))
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfMonth(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfMonth(), minDigits, 2)
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)))):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in))))
return appendDecimal(org.joda.time.DateTimeFieldType.monthOfYear(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.monthOfYear(), minDigits, 2)
switch (c) {
	case 'x' :
		builder.appendTwoDigitWeekyear(
		new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
		break;
	case 'y' :
	case 'Y' :
	default :
		builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
		break;}:switch (c) {
	case 'x' :
		builder.appendTwoDigitWeekyear(
		new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
		break;
	case 'y' :
	case 'Y' :
	default :
		builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
		break;}
int index = ((dateStyle << 2) + dateStyle) + timeStyle:int $0 = ((dateStyle << 2) + dateStyle) + timeStyle
return appendDecimal(org.joda.time.DateTimeFieldType.millisOfSecond(), minDigits, 3):return appendDecimal(org.joda.time.DateTimeFieldType.millisOfSecond(), minDigits, 3)
long[] transitions = new long[size]:long[] $0 = new long[size]
return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isPrinter():return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isPrinter()
if (iTailZone == null) {
	return iNameKeys[i - 1];
}:if (iTailZone == null) {
	return iNameKeys[i - 1];
}
return iWallOffsets[i]:return iWallOffsets[i]
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.SHORT):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.SHORT)
return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfHalfday(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfHalfday(), minDigits, 2)
if (size == 0) {
	throw new java.lang.IllegalArgumentException();
}:if (size == 0) {
	throw new java.lang.IllegalArgumentException();
}
if ((setEn != null) && (setLoc != null)) {
	byNameKeyCache.put(setEn[2], new java.lang.String[]{ setLoc[2], setLoc[1] });



	if (setEn[2].equals(setEn[4])) {
		byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
	} else {
		byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
	}
}:if ((setEn != null) && (setLoc != null)) {
	byNameKeyCache.put(setEn[2], new java.lang.String[]{ setLoc[2], setLoc[1] });



	if (setEn[2].equals(setEn[4])) {
		byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
	} else {
		byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
	}
}
return appendDecimal(org.joda.time.DateTimeFieldType.millisOfDay(), minDigits, 8):return appendDecimal(org.joda.time.DateTimeFieldType.millisOfDay(), minDigits, 8)
if (count > 0) {
	double avg = distances / count;
	avg /= ((24 * 60) * 60) * 1000;
	if (avg >= 25) {






		return true;
	}
}:if (count > 0) {
	double $0 = distances / count;
	$0 /= ((24 * 60) * 60) * 1000;
	if ($0 >= 25) {






		return true;
	}
}
if (i > 0) {
	return iStandardOffsets[i - 1];
}:if (i > 0) {
	return iStandardOffsets[i - 1];
}
if (instant > java.lang.Long.MIN_VALUE) {
	return instant - 1;
}:if (instant > java.lang.Long.MIN_VALUE) {
	return instant - 1;
}
if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setEn = strings;
	break;
}:if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setEn = strings;
	break;
}
if (c == '\'') {
	if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

		i++;
		buf.append(c);
	} else {
		inLiteral = !inLiteral;
	}
} else { 	if ((!inLiteral) && 
	(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
		i--;
		break;
	} else {
		buf.append(c);
	}}:if (c == '\'') {
	if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

		i++;
		buf.append(c);
	} else {
		inLiteral = !inLiteral;
	}
} else { 	if ((!inLiteral) && 
	(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
		i--;
		break;
	} else {
		buf.append(c);
	}}
if (tailZone.iStartRecurrence.getNameKey().equals(
tailZone.iEndRecurrence.getNameKey())) {
	if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
		java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
		tailZone.iStartRecurrence.getNameKey());
	}
	if (tailZone.iStartRecurrence.getSaveMillis() > 0) {
		tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
		tailZone.getID(), 
		tailZone.iStandardOffset, 
		tailZone.iStartRecurrence.renameAppend("-Summer"), 
		tailZone.iEndRecurrence);
	} else {
		tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
		tailZone.getID(), 
		tailZone.iStandardOffset, 
		tailZone.iStartRecurrence, 
		tailZone.iEndRecurrence.renameAppend("-Summer"));
	}
}:if (tailZone.iStartRecurrence.getNameKey().equals(
tailZone.iEndRecurrence.getNameKey())) {
	if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
		java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
		tailZone.iStartRecurrence.getNameKey());
	}
	if (tailZone.iStartRecurrence.getSaveMillis() > 0) {
		tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
		tailZone.getID(), 
		tailZone.iStandardOffset, 
		tailZone.iStartRecurrence.renameAppend("-Summer"), 
		tailZone.iEndRecurrence);
	} else {
		tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
		tailZone.getID(), 
		tailZone.iStandardOffset, 
		tailZone.iStartRecurrence, 
		tailZone.iEndRecurrence.renameAppend("-Summer"));
	}
}
org.joda.time.tz.DateTimeZoneBuilder.Transition tr = transitions.get(i):org.joda.time.tz.DateTimeZoneBuilder.Transition $0 = transitions.get(i)
nameKeys[i] = pool[index]:nameKeys[i] = pool[index]
builder.appendTimeZoneOffset(null, "Z", false, 2, 2):builder.appendTimeZoneOffset(null, "Z", false, 2, 2)
java.lang.String[][] zoneStrings = new java.text.DateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings():java.lang.String[][] $0 = new java.text.DateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings()
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.MEDIUM):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.MEDIUM)
return prev - 1:return prev - 1
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.weekyear(), pivot, lenientParse)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.weekyear(), pivot, lenientParse))
transitions[i] = org.joda.time.tz.DateTimeZoneBuilder.readMillis(in):transitions[i] = org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)
long end = transitions[transitions.length - 1]:long $0 = transitions[transitions.length - 1]
wallOffsets[i] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in))):wallOffsets[i] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)))
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.MEDIUM):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.MEDIUM)
indexRef[0]--:indexRef[0]--
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.NONE)
if ((pattern == null) || (pattern.length() == 0)) {
	throw new java.lang.IllegalArgumentException("Invalid pattern specification");
}:if ((pattern == null) || (pattern.length() == 0)) {
	throw new java.lang.IllegalArgumentException("Invalid pattern specification");
}
formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern):formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern)
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfWeek(), minDigits, 1):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfWeek(), minDigits, 1)
return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, 4):return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, 4)
out.writeShort(poolSize):out.writeShort(poolSize)
if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
	java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
	tailZone.iStartRecurrence.getNameKey());
}:if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
	java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
	tailZone.iStartRecurrence.getNameKey());
}
for (int i = 0; i < size; i++) {
	poolSet.add(iNameKeys[i]);
}:for (int $0 = 0; $0 < size; $0++) {
	poolSet.add(iNameKeys[$0]);
}
if (peek == c) {
	buf.append(c);
	i++;
} else {
	break;
}:if (peek == c) {
	buf.append(c);
	i++;
} else {
	break;
}
builder.appendLiteral(sub.charAt(0)):builder.appendLiteral(sub.charAt(0))
return appendSignedDecimal(org.joda.time.DateTimeFieldType.year(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.year(), minDigits, maxDigits)
i = indexRef[0]:i = indexRef[0]
int timeStyle = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(1)):int $0 = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(1))
if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

	maxDigits = tokenLen;
}:if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

	maxDigits = tokenLen;
}
if (i > 0) {
	return iWallOffsets[i - 1];
}:if (i > 0) {
	return iWallOffsets[i - 1];
}
if (iTailZone == null) {
	return iStandardOffsets[i - 1];
}:if (iTailZone == null) {
	return iStandardOffsets[i - 1];
}
return iOfYear:return iOfYear
return iStandardOffsets[i]:return iStandardOffsets[i]
return false:return false
long curOffset = wallOffsets[i]:long $0 = wallOffsets[i]
buf.append(c):buf.append(c)
iTailZone = tailZone:iTailZone = tailZone
if (tokenLen > 0) {
	char c = token.charAt(0);
	switch (c) {
		case 'c' :
		case 'C' :
		case 'x' :
		case 'y' :
		case 'Y' :
		case 'd' :
		case 'h' :
		case 'H' :
		case 'm' :
		case 's' :
		case 'S' :
		case 'e' :
		case 'D' :
		case 'F' :
		case 'w' :
		case 'W' :
		case 'k' :
		case 'K' :
			return true;
		case 'M' :
			if (tokenLen <= 2) {
				return true;
			}}

}:if (tokenLen > 0) {
	char $0 = token.charAt(0);
	switch ($0) {
		case 'c' :
		case 'C' :
		case 'x' :
		case 'y' :
		case 'Y' :
		case 'd' :
		case 'h' :
		case 'H' :
		case 'm' :
		case 's' :
		case 'S' :
		case 'e' :
		case 'D' :
		case 'F' :
		case 'w' :
		case 'W' :
		case 'k' :
		case 'K' :
			return true;
		case 'M' :
			if (tokenLen <= 2) {
				return true;
			}}

}
nameKeys[i + 1] = (nextNameKey + "-Summer").intern():nameKeys[i + 1] = (nextNameKey + "-Summer").intern()
if (transitions.length <= 1) {
	return false;
}:if (transitions.length <= 1) {
	return false;
}
java.util.Iterator<java.lang.String> it = poolSet.iterator():java.util.Iterator<java.lang.String> $0 = poolSet.iterator()
return append0(pp, pp):return append0(pp, pp)
if (pool[j].equals(nameKey)) {
	if (poolSize < 256) {
		out.writeByte(j);
	} else {
		out.writeShort(j);
	}
	break;
}:if (pool[j].equals(nameKey)) {
	if (poolSize < 256) {
		out.writeByte(j);
	} else {
		out.writeShort(j);
	}
	break;
}
i = (i >= 0) ? i + 1 : ~i:i = (i >= 0) ? i + 1 : ~i
if (i >= 0) {
	return iStandardOffsets[i];
}:if (i >= 0) {
	return iStandardOffsets[i];
}
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.FULL):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.FULL)
org.joda.time.Period p = new org.joda.time.Period(trans[i], trans[i + 1], org.joda.time.PeriodType.yearMonthDay(), chrono):org.joda.time.Period $0 = new org.joda.time.Period(trans[i], trans[i + 1], org.joda.time.PeriodType.yearMonthDay(), chrono)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, false))
return appendText(org.joda.time.DateTimeFieldType.halfdayOfDay()):return appendText(org.joda.time.DateTimeFieldType.halfdayOfDay())
if (in.readBoolean()) {
	tailZone = org.joda.time.tz.DateTimeZoneBuilder.DSTZone.readFrom(in, id);
}:if (in.readBoolean()) {
	tailZone = org.joda.time.tz.DateTimeZoneBuilder.DSTZone.readFrom(in, id);
}
break:break
boolean lenientParse = true:boolean $0 = true
return iTailZone.nextTransition(instant):return iTailZone.nextTransition(instant)
return instant - 1:return instant - 1
distances += ((double) (diff)):distances += ((double) (diff))
if (i >= 0) {
	if (instant > java.lang.Long.MIN_VALUE) {
		return instant - 1;
	}
	return instant;
}:if (i >= 0) {
	if (instant > java.lang.Long.MIN_VALUE) {
		return instant - 1;
	}
	return instant;
}
return appendDecimal(org.joda.time.DateTimeFieldType.secondOfMinute(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.secondOfMinute(), minDigits, 2)
switch (c) {
	case 'c' :
	case 'C' :
	case 'x' :
	case 'y' :
	case 'Y' :
	case 'd' :
	case 'h' :
	case 'H' :
	case 'm' :
	case 's' :
	case 'S' :
	case 'e' :
	case 'D' :
	case 'F' :
	case 'w' :
	case 'W' :
	case 'k' :
	case 'K' :
		return true;
	case 'M' :
		if (tokenLen <= 2) {
			return true;
		}}:switch (c) {
	case 'c' :
	case 'C' :
	case 'x' :
	case 'y' :
	case 'Y' :
	case 'd' :
	case 'h' :
	case 'H' :
	case 'm' :
	case 's' :
	case 'S' :
	case 'e' :
	case 'D' :
	case 'F' :
	case 'w' :
	case 'W' :
	case 'k' :
	case 'K' :
		return true;
	case 'M' :
		if (tokenLen <= 2) {
			return true;
		}}
if ((dateStyle == org.joda.time.format.DateTimeFormat.NONE) && (timeStyle == org.joda.time.format.DateTimeFormat.NONE)) {
	throw new java.lang.IllegalArgumentException("Style '--' is invalid");
}:if ((dateStyle == org.joda.time.format.DateTimeFormat.NONE) && (timeStyle == org.joda.time.format.DateTimeFormat.NONE)) {
	throw new java.lang.IllegalArgumentException("Style '--' is invalid");
}
if (i > 0) {
	long prev = transitions[i - 1];
	if (prev > java.lang.Long.MIN_VALUE) {
		return prev - 1;
	}
}:if (i > 0) {
	long $0 = transitions[i - 1];
	if ($0 > java.lang.Long.MIN_VALUE) {
		return $0 - 1;
	}
}
if ((((((((curOffset != nextOffset) && 
(curStdOffset == nextStdOffset)) && 
curNameKey.equals(nextNameKey)) && 
(p.getYears() == 0)) && (p.getMonths() > 4)) && (p.getMonths() < 8)) && 
curNameKey.equals(zoneNameData[2])) && 
curNameKey.equals(zoneNameData[4])) {

	if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
		java.lang.System.out.println("Fixing duplicate name key - " + nextNameKey);
		java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[i], chrono)) + 
		" - ") + new org.joda.time.DateTime(trans[i + 1], chrono));
	}
	if (curOffset > nextOffset) {
		nameKeys[i] = (curNameKey + "-Summer").intern();
	} else { 		if (curOffset < nextOffset) {
			nameKeys[i + 1] = (nextNameKey + "-Summer").intern();
			i++;
		}}
}:if ((((((((curOffset != nextOffset) && 
(curStdOffset == nextStdOffset)) && 
curNameKey.equals(nextNameKey)) && 
(p.getYears() == 0)) && (p.getMonths() > 4)) && (p.getMonths() < 8)) && 
curNameKey.equals(zoneNameData[2])) && 
curNameKey.equals(zoneNameData[4])) {

	if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
		java.lang.System.out.println("Fixing duplicate name key - " + nextNameKey);
		java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[i], chrono)) + 
		" - ") + new org.joda.time.DateTime(trans[i + 1], chrono));
	}
	if (curOffset > nextOffset) {
		nameKeys[i] = (curNameKey + "-Summer").intern();
	} else { 		if (curOffset < nextOffset) {
			nameKeys[i + 1] = (nextNameKey + "-Summer").intern();
			i++;
		}}
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.year(), pivot, lenientParse)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.year(), pivot, lenientParse))
int type = org.joda.time.format.DateTimeFormat.DATETIME:int $0 = org.joda.time.format.DateTimeFormat.DATETIME
return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, true))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.LONG_NAME, null), null):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.LONG_NAME, null), null)
return appendTwoDigitYear(pivot, false):return appendTwoDigitYear(pivot, false)
if (curOffset > nextOffset) {
	nameKeys[i] = (curNameKey + "-Summer").intern();
} else { 	if (curOffset < nextOffset) {
		nameKeys[i + 1] = (nextNameKey + "-Summer").intern();
		i++;
	}}:if (curOffset > nextOffset) {
	nameKeys[i] = (curNameKey + "-Summer").intern();
} else { 	if (curOffset < nextOffset) {
		nameKeys[i + 1] = (nextNameKey + "-Summer").intern();
		i++;
	}}
throw new java.lang.IllegalArgumentException("Invalid style specification: " + style):throw new java.lang.IllegalArgumentException("Invalid style specification: " + style)
return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle):return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle)
indexRef[0] = i:indexRef[0] = i
wallOffsets[i] = tr.getWallOffset():wallOffsets[i] = tr.getWallOffset()
if (iTailZone == null) {
	return iWallOffsets[i - 1];
}:if (iTailZone == null) {
	return iWallOffsets[i - 1];
}
if (index >= org.joda.time.format.DateTimeFormat.STYLE_CACHE.length) {
	return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
}:if (index >= org.joda.time.format.DateTimeFormat.STYLE_CACHE.length) {
	return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
}
long[] trans = new long[size]:long[] $0 = new long[size]
return appendFraction(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, maxDigits)
if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
	java.lang.System.out.println("Fixing duplicate name key - " + nextNameKey);
	java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[i], chrono)) + 
	" - ") + new org.joda.time.DateTime(trans[i + 1], chrono));
}:if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
	java.lang.System.out.println("Fixing duplicate name key - " + nextNameKey);
	java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[i], chrono)) + 
	" - ") + new org.joda.time.DateTime(trans[i + 1], chrono));
}
i++:i++
return true:return true
return iNameKeys[i]:return iNameKeys[i]
if (iTailZone != null) {
	long prev = iTailZone.previousTransition(instant);
	if (prev < instant) {
		return prev;
	}
}:if (iTailZone != null) {
	long $0 = iTailZone.previousTransition(instant);
	if ($0 < instant) {
		return $0;
	}
}
return ((org.joda.time.format.DateTimeFormat.StyleFormatter) (formatter.getPrinter())).getPattern(locale):return ((org.joda.time.format.DateTimeFormat.StyleFormatter) (formatter.getPrinter())).getPattern(locale)
return org.joda.time.format.DateTimeFormat.createFormatterForStyle(style):return org.joda.time.format.DateTimeFormat.createFormatterForStyle(style)
throw new java.lang.IllegalArgumentException("Invalid pattern specification"):throw new java.lang.IllegalArgumentException("Invalid pattern specification")
out.writeShort(j):out.writeShort(j)
if (locale == null) {
	locale = java.util.Locale.getDefault();
}:if (locale == null) {
	locale = java.util.Locale.getDefault();
}
if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



	lenientParse = false;
}:if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



	lenientParse = false;
}
throw new java.lang.IllegalArgumentException("Style '--' is invalid"):throw new java.lang.IllegalArgumentException("Style '--' is invalid")
if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.DATE;
}:if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.DATE;
}
iWallOffsets = wallOffsets:iWallOffsets = wallOffsets
type = org.joda.time.format.DateTimeFormat.DATE:type = org.joda.time.format.DateTimeFormat.DATE
throw new java.lang.UnsupportedOperationException("String pool is too large"):throw new java.lang.UnsupportedOperationException("String pool is too large")
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.NONE)
org.joda.time.tz.DateTimeZoneBuilder.Transition last = null:org.joda.time.tz.DateTimeZoneBuilder.Transition $0 = null
return ((org.joda.time.format.DateTimeParser) (f)):return ((org.joda.time.format.DateTimeParser) (f))
java.lang.String[] set = zoneStrings[j]:java.lang.String[] $0 = zoneStrings[j]
out.writeBoolean(iTailZone != null):out.writeBoolean(iTailZone != null)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, true, minDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, true, minDigits))
long prev = transitions[i - 1]:long $0 = transitions[i - 1]
for (int i = 0; i < (nameKeys.length - 1); i++) {
	java.lang.String curNameKey = nameKeys[i];
	java.lang.String nextNameKey = nameKeys[i + 1];
	long curOffset = wallOffsets[i];
	long nextOffset = wallOffsets[i + 1];
	long curStdOffset = standardOffsets[i];
	long nextStdOffset = standardOffsets[i + 1];
	org.joda.time.Period p = new org.joda.time.Period(trans[i], trans[i + 1], org.joda.time.PeriodType.yearMonthDay(), chrono);
	if ((((((((curOffset != nextOffset) && 
	(curStdOffset == nextStdOffset)) && 
	curNameKey.equals(nextNameKey)) && 
	(p.getYears() == 0)) && (p.getMonths() > 4)) && (p.getMonths() < 8)) && 
	curNameKey.equals(zoneNameData[2])) && 
	curNameKey.equals(zoneNameData[4])) {

		if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
			java.lang.System.out.println("Fixing duplicate name key - " + nextNameKey);
			java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[i], chrono)) + 
			" - ") + new org.joda.time.DateTime(trans[i + 1], chrono));
		}
		if (curOffset > nextOffset) {
			nameKeys[i] = (curNameKey + "-Summer").intern();
		} else { 			if (curOffset < nextOffset) {
				nameKeys[i + 1] = (nextNameKey + "-Summer").intern();
				i++;
			}}
	}
}:for (int $0 = 0; $0 < (nameKeys.length - 1); $0++) {
	java.lang.String $1 = nameKeys[$0];
	java.lang.String $2 = nameKeys[$0 + 1];
	long $3 = wallOffsets[$0];
	long $4 = wallOffsets[$0 + 1];
	long $5 = standardOffsets[$0];
	long $6 = standardOffsets[$0 + 1];
	org.joda.time.Period $7 = new org.joda.time.Period(trans[$0], trans[$0 + 1], org.joda.time.PeriodType.yearMonthDay(), chrono);
	if (((((((($3 != $4) && 
	($5 == $6)) && 
	$1.equals($2)) && 
	($7.getYears() == 0)) && ($7.getMonths() > 4)) && ($7.getMonths() < 8)) && 
	$1.equals(zoneNameData[2])) && 
	$1.equals(zoneNameData[4])) {

		if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
			java.lang.System.out.println("Fixing duplicate name key - " + $2);
			java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[$0], chrono)) + 
			" - ") + new org.joda.time.DateTime(trans[$0 + 1], chrono));
		}
		if ($3 > $4) {
			nameKeys[$0] = ($1 + "-Summer").intern();
		} else { 			if ($3 < $4) {
				nameKeys[$0 + 1] = ($2 + "-Summer").intern();
				$0++;
			}}
	}
}
switch (c) {
	case 'x' :
		builder.appendWeekyear(tokenLen, maxDigits);
		break;
	case 'y' :
		builder.appendYear(tokenLen, maxDigits);
		break;
	case 'Y' :
		builder.appendYearOfEra(tokenLen, maxDigits);
		break;}:switch (c) {
	case 'x' :
		builder.appendWeekyear(tokenLen, maxDigits);
		break;
	case 'y' :
		builder.appendYear(tokenLen, maxDigits);
		break;
	case 'Y' :
		builder.appendYearOfEra(tokenLen, maxDigits);
		break;}
if (((set != null) && (set.length == 5)) && id.equals(set[0])) {
	zoneNameData = set;
}:if (((set != null) && (set.length == 5)) && id.equals(set[0])) {
	zoneNameData = set;
}
return appendDecimal(org.joda.time.DateTimeFieldType.yearOfCentury(), minDigits, maxDigits):return appendDecimal(org.joda.time.DateTimeFieldType.yearOfCentury(), minDigits, maxDigits)
return new org.joda.time.format.DateTimeFormatter(printer, parser):return new org.joda.time.format.DateTimeFormatter(printer, parser)
java.lang.String[] zoneNameData = new java.lang.String[5]:java.lang.String[] $0 = new java.lang.String[5]
return appendText(org.joda.time.DateTimeFieldType.monthOfYear()):return appendText(org.joda.time.DateTimeFieldType.monthOfYear())
if (i < transitions.length) {
	return transitions[i];
}:if (i < transitions.length) {
	return transitions[i];
}
builder.appendDayOfWeekText():builder.appendDayOfWeekText()
count++:count++
while ((i + 1) < length) {
	char peek = pattern.charAt(i + 1);
	if (peek == c) {
		buf.append(c);
		i++;
	} else {
		break;
	}
} :while ((i + 1) < length) {
	char $0 = pattern.charAt(i + 1);
	if ($0 == c) {
		buf.append(c);
		i++;
	} else {
		break;
	}
} 
long curStdOffset = standardOffsets[i]:long $0 = standardOffsets[i]
long nextStdOffset = standardOffsets[i + 1]:long $0 = standardOffsets[i + 1]
if (i < transitions.length) {
	if (i > 0) {
		long prev = transitions[i - 1];
		if (prev > java.lang.Long.MIN_VALUE) {
			return prev - 1;
		}
	}
	return instant;
}:if (i < transitions.length) {
	if (i > 0) {
		long $0 = transitions[i - 1];
		if ($0 > java.lang.Long.MIN_VALUE) {
			return $0 - 1;
		}
	}
	return instant;
}
if (((locale == null) || (id == null)) || (nameKey == null)) {
	return null;
}:if (((locale == null) || (id == null)) || (nameKey == null)) {
	return null;
}
if (prev > java.lang.Long.MIN_VALUE) {
	return prev - 1;
}:if (prev > java.lang.Long.MIN_VALUE) {
	return prev - 1;
}
for (int j = 0; j < poolSize; j++) {
	if (pool[j].equals(nameKey)) {
		if (poolSize < 256) {
			out.writeByte(j);
		} else {
			out.writeShort(j);
		}
		break;
	}
}:for (int $0 = 0; $0 < poolSize; $0++) {
	if (pool[$0].equals(nameKey)) {
		if (poolSize < 256) {
			out.writeByte($0);
		} else {
			out.writeShort($0);
		}
		break;
	}
}
if (!tr.isTransitionFrom(last)) {
	throw new java.lang.IllegalArgumentException(id);
}:if (!tr.isTransitionFrom(last)) {
	throw new java.lang.IllegalArgumentException(id);
}
pool[i] = it.next():pool[i] = it.next()
if (dateStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.TIME;
} else { 	if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
		type = org.joda.time.format.DateTimeFormat.DATE;
	}}:if (dateStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.TIME;
} else { 	if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
		type = org.joda.time.format.DateTimeFormat.DATE;
	}}
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.NONE)
for (int i = 0; it.hasNext(); i++) {
	pool[i] = it.next();
}:for (int $0 = 0; it.hasNext(); $0++) {
	pool[$0] = it.next();
}
i--:i--
builder.appendMonthOfYear(tokenLen):builder.appendMonthOfYear(tokenLen)
if (tailZone != null) {
	if (tailZone.iStartRecurrence.getNameKey().equals(
	tailZone.iEndRecurrence.getNameKey())) {
		if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
			java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
			tailZone.iStartRecurrence.getNameKey());
		}
		if (tailZone.iStartRecurrence.getSaveMillis() > 0) {
			tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
			tailZone.getID(), 
			tailZone.iStandardOffset, 
			tailZone.iStartRecurrence.renameAppend("-Summer"), 
			tailZone.iEndRecurrence);
		} else {
			tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
			tailZone.getID(), 
			tailZone.iStandardOffset, 
			tailZone.iStartRecurrence, 
			tailZone.iEndRecurrence.renameAppend("-Summer"));
		}
	}
}:if (tailZone != null) {
	if (tailZone.iStartRecurrence.getNameKey().equals(
	tailZone.iEndRecurrence.getNameKey())) {
		if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
			java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
			tailZone.iStartRecurrence.getNameKey());
		}
		if (tailZone.iStartRecurrence.getSaveMillis() > 0) {
			tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
			tailZone.getID(), 
			tailZone.iStandardOffset, 
			tailZone.iStartRecurrence.renameAppend("-Summer"), 
			tailZone.iEndRecurrence);
		} else {
			tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
			tailZone.getID(), 
			tailZone.iStandardOffset, 
			tailZone.iStartRecurrence, 
			tailZone.iEndRecurrence.renameAppend("-Summer"));
		}
	}
}
return org.joda.time.format.DateTimeFormat.createFormatterForPattern(pattern):return org.joda.time.format.DateTimeFormat.createFormatterForPattern(pattern)
org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iWallOffsets[i]):org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iWallOffsets[i])
out.writeUTF(pool[i]):out.writeUTF(pool[i])
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields))
int[] indexRef = new int[1]:int[] $0 = new int[1]
builder.appendMonthOfYearShortText():builder.appendMonthOfYearShortText()
for (int i = 0; i < length; i++) {
	indexRef[0] = i;
	java.lang.String token = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef);
	i = indexRef[0];

	int tokenLen = token.length();
	if (tokenLen == 0) {
		break;
	}
	char c = token.charAt(0);

	switch (c) {
		case 'G' :
			builder.appendEraText();
			break;
		case 'C' :
			builder.appendCenturyOfEra(tokenLen, tokenLen);
			break;
		case 'x' :
		case 'y' :
		case 'Y' :
			if (tokenLen == 2) {
				boolean lenientParse = true;


				if ((i + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



						lenientParse = false;
					}
					indexRef[0]--;
				}


				switch (c) {
					case 'x' :
						builder.appendTwoDigitWeekyear(
						new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
						break;
					case 'y' :
					case 'Y' :
					default :
						builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
						break;}

			} else {

				int maxDigits = 9;


				if ((i + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

						maxDigits = tokenLen;
					}
					indexRef[0]--;
				}

				switch (c) {
					case 'x' :
						builder.appendWeekyear(tokenLen, maxDigits);
						break;
					case 'y' :
						builder.appendYear(tokenLen, maxDigits);
						break;
					case 'Y' :
						builder.appendYearOfEra(tokenLen, maxDigits);
						break;}

			}
			break;
		case 'M' :
			if (tokenLen >= 3) {
				if (tokenLen >= 4) {
					builder.appendMonthOfYearText();
				} else {
					builder.appendMonthOfYearShortText();
				}
			} else {
				builder.appendMonthOfYear(tokenLen);
			}
			break;
		case 'd' :
			builder.appendDayOfMonth(tokenLen);
			break;
		case 'a' :
			builder.appendHalfdayOfDayText();
			break;
		case 'h' :
			builder.appendClockhourOfHalfday(tokenLen);
			break;
		case 'H' :
			builder.appendHourOfDay(tokenLen);
			break;
		case 'k' :
			builder.appendClockhourOfDay(tokenLen);
			break;
		case 'K' :
			builder.appendHourOfHalfday(tokenLen);
			break;
		case 'm' :
			builder.appendMinuteOfHour(tokenLen);
			break;
		case 's' :
			builder.appendSecondOfMinute(tokenLen);
			break;
		case 'S' :
			builder.appendFractionOfSecond(tokenLen, tokenLen);
			break;
		case 'e' :
			builder.appendDayOfWeek(tokenLen);
			break;
		case 'E' :
			if (tokenLen >= 4) {
				builder.appendDayOfWeekText();
			} else {
				builder.appendDayOfWeekShortText();
			}
			break;
		case 'D' :
			builder.appendDayOfYear(tokenLen);
			break;
		case 'w' :
			builder.appendWeekOfWeekyear(tokenLen);
			break;
		case 'z' :
			if (tokenLen >= 4) {
				builder.appendTimeZoneName();
			} else {
				builder.appendTimeZoneShortName(null);
			}
			break;
		case 'Z' :
			if (tokenLen == 1) {
				builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
			} else { 				if (tokenLen == 2) {
					builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
				} else {
					builder.appendTimeZoneId();
				}}
			break;
		case '\'' :
			java.lang.String sub = token.substring(1);
			if (sub.length() == 1) {
				builder.appendLiteral(sub.charAt(0));
			} else {


				builder.appendLiteral(new java.lang.String(sub));
			}
			break;
		default :
			throw new java.lang.IllegalArgumentException(
			"Illegal pattern component: " + token);}

}:for (int $0 = 0; $0 < length; $0++) {
	indexRef[0] = $0;
	java.lang.String $1 = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef);
	$0 = indexRef[0];

	int $2 = $1.length();
	if ($2 == 0) {
		break;
	}
	char $3 = $1.charAt(0);

	switch ($3) {
		case 'G' :
			builder.appendEraText();
			break;
		case 'C' :
			builder.appendCenturyOfEra($2, $2);
			break;
		case 'x' :
		case 'y' :
		case 'Y' :
			if ($2 == 2) {
				boolean $4 = true;


				if (($0 + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



						$4 = false;
					}
					indexRef[0]--;
				}


				switch ($3) {
					case 'x' :
						builder.appendTwoDigitWeekyear(
						new org.joda.time.DateTime().getWeekyear() - 30, $4);
						break;
					case 'y' :
					case 'Y' :
					default :
						builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, $4);
						break;}

			} else {

				int $5 = 9;


				if (($0 + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

						$5 = $2;
					}
					indexRef[0]--;
				}

				switch ($3) {
					case 'x' :
						builder.appendWeekyear($2, $5);
						break;
					case 'y' :
						builder.appendYear($2, $5);
						break;
					case 'Y' :
						builder.appendYearOfEra($2, $5);
						break;}

			}
			break;
		case 'M' :
			if ($2 >= 3) {
				if ($2 >= 4) {
					builder.appendMonthOfYearText();
				} else {
					builder.appendMonthOfYearShortText();
				}
			} else {
				builder.appendMonthOfYear($2);
			}
			break;
		case 'd' :
			builder.appendDayOfMonth($2);
			break;
		case 'a' :
			builder.appendHalfdayOfDayText();
			break;
		case 'h' :
			builder.appendClockhourOfHalfday($2);
			break;
		case 'H' :
			builder.appendHourOfDay($2);
			break;
		case 'k' :
			builder.appendClockhourOfDay($2);
			break;
		case 'K' :
			builder.appendHourOfHalfday($2);
			break;
		case 'm' :
			builder.appendMinuteOfHour($2);
			break;
		case 's' :
			builder.appendSecondOfMinute($2);
			break;
		case 'S' :
			builder.appendFractionOfSecond($2, $2);
			break;
		case 'e' :
			builder.appendDayOfWeek($2);
			break;
		case 'E' :
			if ($2 >= 4) {
				builder.appendDayOfWeekText();
			} else {
				builder.appendDayOfWeekShortText();
			}
			break;
		case 'D' :
			builder.appendDayOfYear($2);
			break;
		case 'w' :
			builder.appendWeekOfWeekyear($2);
			break;
		case 'z' :
			if ($2 >= 4) {
				builder.appendTimeZoneName();
			} else {
				builder.appendTimeZoneShortName(null);
			}
			break;
		case 'Z' :
			if ($2 == 1) {
				builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
			} else { 				if ($2 == 2) {
					builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
				} else {
					builder.appendTimeZoneId();
				}}
			break;
		case '\'' :
			java.lang.String $6 = $1.substring(1);
			if ($6.length() == 1) {
				builder.appendLiteral($6.charAt(0));
			} else {


				builder.appendLiteral(new java.lang.String($6));
			}
			break;
		default :
			throw new java.lang.IllegalArgumentException(
			"Illegal pattern component: " + $1);}

}
if (avg >= 25) {






	return true;
}:if (avg >= 25) {






	return true;
}
return appendDecimal(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, 5):return appendDecimal(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, 5)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.FULL):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.FULL)
if ((style == null) || (style.length() != 2)) {
	throw new java.lang.IllegalArgumentException("Invalid style specification: " + style);
}:if ((style == null) || (style.length() != 2)) {
	throw new java.lang.IllegalArgumentException("Invalid style specification: " + style);
}
switch (c) {
	case 'G' :
		builder.appendEraText();
		break;
	case 'C' :
		builder.appendCenturyOfEra(tokenLen, tokenLen);
		break;
	case 'x' :
	case 'y' :
	case 'Y' :
		if (tokenLen == 2) {
			boolean lenientParse = true;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



					lenientParse = false;
				}
				indexRef[0]--;
			}


			switch (c) {
				case 'x' :
					builder.appendTwoDigitWeekyear(
					new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
					break;
				case 'y' :
				case 'Y' :
				default :
					builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
					break;}

		} else {

			int maxDigits = 9;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

					maxDigits = tokenLen;
				}
				indexRef[0]--;
			}

			switch (c) {
				case 'x' :
					builder.appendWeekyear(tokenLen, maxDigits);
					break;
				case 'y' :
					builder.appendYear(tokenLen, maxDigits);
					break;
				case 'Y' :
					builder.appendYearOfEra(tokenLen, maxDigits);
					break;}

		}
		break;
	case 'M' :
		if (tokenLen >= 3) {
			if (tokenLen >= 4) {
				builder.appendMonthOfYearText();
			} else {
				builder.appendMonthOfYearShortText();
			}
		} else {
			builder.appendMonthOfYear(tokenLen);
		}
		break;
	case 'd' :
		builder.appendDayOfMonth(tokenLen);
		break;
	case 'a' :
		builder.appendHalfdayOfDayText();
		break;
	case 'h' :
		builder.appendClockhourOfHalfday(tokenLen);
		break;
	case 'H' :
		builder.appendHourOfDay(tokenLen);
		break;
	case 'k' :
		builder.appendClockhourOfDay(tokenLen);
		break;
	case 'K' :
		builder.appendHourOfHalfday(tokenLen);
		break;
	case 'm' :
		builder.appendMinuteOfHour(tokenLen);
		break;
	case 's' :
		builder.appendSecondOfMinute(tokenLen);
		break;
	case 'S' :
		builder.appendFractionOfSecond(tokenLen, tokenLen);
		break;
	case 'e' :
		builder.appendDayOfWeek(tokenLen);
		break;
	case 'E' :
		if (tokenLen >= 4) {
			builder.appendDayOfWeekText();
		} else {
			builder.appendDayOfWeekShortText();
		}
		break;
	case 'D' :
		builder.appendDayOfYear(tokenLen);
		break;
	case 'w' :
		builder.appendWeekOfWeekyear(tokenLen);
		break;
	case 'z' :
		if (tokenLen >= 4) {
			builder.appendTimeZoneName();
		} else {
			builder.appendTimeZoneShortName(null);
		}
		break;
	case 'Z' :
		if (tokenLen == 1) {
			builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
		} else { 			if (tokenLen == 2) {
				builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
			} else {
				builder.appendTimeZoneId();
			}}
		break;
	case '\'' :
		java.lang.String sub = token.substring(1);
		if (sub.length() == 1) {
			builder.appendLiteral(sub.charAt(0));
		} else {


			builder.appendLiteral(new java.lang.String(sub));
		}
		break;
	default :
		throw new java.lang.IllegalArgumentException(
		"Illegal pattern component: " + token);}:switch (c) {
	case 'G' :
		builder.appendEraText();
		break;
	case 'C' :
		builder.appendCenturyOfEra(tokenLen, tokenLen);
		break;
	case 'x' :
	case 'y' :
	case 'Y' :
		if (tokenLen == 2) {
			boolean $0 = true;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



					$0 = false;
				}
				indexRef[0]--;
			}


			switch (c) {
				case 'x' :
					builder.appendTwoDigitWeekyear(
					new org.joda.time.DateTime().getWeekyear() - 30, $0);
					break;
				case 'y' :
				case 'Y' :
				default :
					builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, $0);
					break;}

		} else {

			int $1 = 9;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

					$1 = tokenLen;
				}
				indexRef[0]--;
			}

			switch (c) {
				case 'x' :
					builder.appendWeekyear(tokenLen, $1);
					break;
				case 'y' :
					builder.appendYear(tokenLen, $1);
					break;
				case 'Y' :
					builder.appendYearOfEra(tokenLen, $1);
					break;}

		}
		break;
	case 'M' :
		if (tokenLen >= 3) {
			if (tokenLen >= 4) {
				builder.appendMonthOfYearText();
			} else {
				builder.appendMonthOfYearShortText();
			}
		} else {
			builder.appendMonthOfYear(tokenLen);
		}
		break;
	case 'd' :
		builder.appendDayOfMonth(tokenLen);
		break;
	case 'a' :
		builder.appendHalfdayOfDayText();
		break;
	case 'h' :
		builder.appendClockhourOfHalfday(tokenLen);
		break;
	case 'H' :
		builder.appendHourOfDay(tokenLen);
		break;
	case 'k' :
		builder.appendClockhourOfDay(tokenLen);
		break;
	case 'K' :
		builder.appendHourOfHalfday(tokenLen);
		break;
	case 'm' :
		builder.appendMinuteOfHour(tokenLen);
		break;
	case 's' :
		builder.appendSecondOfMinute(tokenLen);
		break;
	case 'S' :
		builder.appendFractionOfSecond(tokenLen, tokenLen);
		break;
	case 'e' :
		builder.appendDayOfWeek(tokenLen);
		break;
	case 'E' :
		if (tokenLen >= 4) {
			builder.appendDayOfWeekText();
		} else {
			builder.appendDayOfWeekShortText();
		}
		break;
	case 'D' :
		builder.appendDayOfYear(tokenLen);
		break;
	case 'w' :
		builder.appendWeekOfWeekyear(tokenLen);
		break;
	case 'z' :
		if (tokenLen >= 4) {
			builder.appendTimeZoneName();
		} else {
			builder.appendTimeZoneShortName(null);
		}
		break;
	case 'Z' :
		if (tokenLen == 1) {
			builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
		} else { 			if (tokenLen == 2) {
				builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
			} else {
				builder.appendTimeZoneId();
			}}
		break;
	case '\'' :
		java.lang.String $2 = token.substring(1);
		if ($2.length() == 1) {
			builder.appendLiteral($2.charAt(0));
		} else {


			builder.appendLiteral(new java.lang.String($2));
		}
		break;
	default :
		throw new java.lang.IllegalArgumentException(
		"Illegal pattern component: " + token);}
return iWallOffsets[i - 1]:return iWallOffsets[i - 1]
return iStandardOffsets[i - 1]:return iStandardOffsets[i - 1]
iStandardOffsets = standardOffsets:iStandardOffsets = standardOffsets
out.writeInt(size):out.writeInt(size)
org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder():org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder()
return appendTwoDigitWeekyear(pivot, false):return appendTwoDigitWeekyear(pivot, false)
throw new java.lang.IllegalArgumentException(id):throw new java.lang.IllegalArgumentException(id)
buf.append('\''):buf.append('\'')
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.NONE)
org.joda.time.format.DateTimeFormat.StyleFormatter llf = new org.joda.time.format.DateTimeFormat.StyleFormatter(dateStyle, timeStyle, type):org.joda.time.format.DateTimeFormat.StyleFormatter $0 = new org.joda.time.format.DateTimeFormat.StyleFormatter(dateStyle, timeStyle, type)
for (int i = 0; i < poolSize; i++) {
	pool[i] = in.readUTF();
}:for (int $0 = 0; $0 < poolSize; $0++) {
	pool[$0] = in.readUTF();
}
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.LONG):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.LONG)
nameKeys[i] = (curNameKey + "-Summer").intern():nameKeys[i] = (curNameKey + "-Summer").intern()
return iTailZone.getStandardOffset(instant):return iTailZone.getStandardOffset(instant)
return appendDecimal(org.joda.time.DateTimeFieldType.yearOfEra(), minDigits, maxDigits):return appendDecimal(org.joda.time.DateTimeFieldType.yearOfEra(), minDigits, maxDigits)
if (i >= 0) {
	return iWallOffsets[i];
}:if (i >= 0) {
	return iWallOffsets[i];
}
return rename((iNameKey + appendNameKey).intern()):return rename((iNameKey + appendNameKey).intern())
indexRef[0]++:indexRef[0]++
int poolSize = poolSet.size():int $0 = poolSet.size()
if (tokenLen == 0) {
	break;
}:if (tokenLen == 0) {
	break;
}
for (int i = 0; i < size; i++) {
	org.joda.time.tz.DateTimeZoneBuilder.Transition tr = transitions.get(i);

	if (!tr.isTransitionFrom(last)) {
		throw new java.lang.IllegalArgumentException(id);
	}

	trans[i] = tr.getMillis();
	wallOffsets[i] = tr.getWallOffset();
	standardOffsets[i] = tr.getStandardOffset();
	nameKeys[i] = tr.getNameKey();

	last = tr;
}:for (int $0 = 0; $0 < size; $0++) {
	org.joda.time.tz.DateTimeZoneBuilder.Transition $1 = transitions.get($0);

	if (!$1.isTransitionFrom(last)) {
		throw new java.lang.IllegalArgumentException(id);
	}

	trans[$0] = $1.getMillis();
	wallOffsets[$0] = $1.getWallOffset();
	standardOffsets[$0] = $1.getStandardOffset();
	nameKeys[$0] = $1.getNameKey();

	last = $1;
}
zoneNameData = set:zoneNameData = set
java.lang.System.out.println("Fixing duplicate name key - " + nextNameKey):java.lang.System.out.println("Fixing duplicate name key - " + nextNameKey)
return appendShortText(org.joda.time.DateTimeFieldType.dayOfWeek()):return appendShortText(org.joda.time.DateTimeFieldType.dayOfWeek())
return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, true))
minutesOffset = hoursInMinutes + minutesOffset:minutesOffset = hoursInMinutes + minutesOffset
return appendFraction(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, maxDigits)
return isParser(getFormatter()):return isParser(getFormatter())
org.joda.time.DateTimeZone.cOffsetFormatter = new org.joda.time.format.DateTimeFormatterBuilder().appendTimeZoneOffset(
null, true, 2, 4).toFormatter():org.joda.time.DateTimeZone.cOffsetFormatter = new org.joda.time.format.DateTimeFormatterBuilder().appendTimeZoneOffset(
null, true, 2, 4).toFormatter()
long[] transitions = iTransitions:long[] $0 = iTransitions
return offsetAdjusted:return offsetAdjusted
java.lang.String nameKey = iNameKeys[i]:java.lang.String $0 = iNameKeys[i]
org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern):org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern)
if (nextAdjusted == (instantLocal - offset)) {
	nextAdjusted = java.lang.Long.MAX_VALUE;
}:if (nextAdjusted == (instantLocal - offset)) {
	nextAdjusted = java.lang.Long.MAX_VALUE;
}
return append0(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE, org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE):return append0(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE, org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.INSTANCE)
map.put("VST", "Asia/Ho_Chi_Minh"):map.put("VST", "Asia/Ho_Chi_Minh")
throw new java.lang.IllegalArgumentException("Millis out of range: " + millisOffset):throw new java.lang.IllegalArgumentException("Millis out of range: " + millisOffset)
throw new java.lang.IllegalArgumentException(("The datetime zone id '" + id) + "' is not recognised"):throw new java.lang.IllegalArgumentException(("The datetime zone id '" + id) + "' is not recognised")
return append0(formatter.getPrinter(), formatter.getParser()):return append0(formatter.getPrinter(), formatter.getParser())
throw new java.lang.RuntimeException(ex):throw new java.lang.RuntimeException(ex)
if (poolSize < 256) {
	out.writeByte(j);
} else {
	out.writeShort(j);
}:if (poolSize < 256) {
	out.writeByte(j);
} else {
	out.writeShort(j);
}
dtz = org.joda.time.DateTimeZone.cProvider.getZone(convId):dtz = org.joda.time.DateTimeZone.cProvider.getZone(convId)
id = org.joda.time.DateTimeZone.printOffset(offset):id = org.joda.time.DateTimeZone.printOffset(offset)
iTailZone.writeTo(out):iTailZone.writeTo(out)
return org.joda.time.DateTimeZone.forOffsetMillis(offset):return org.joda.time.DateTimeZone.forOffsetMillis(offset)
return iTailZone.getNameKey(instant):return iTailZone.getNameKey(instant)
nameProvider = ((org.joda.time.tz.NameProvider) (java.lang.Class.forName(providerClass).newInstance())):nameProvider = ((org.joda.time.tz.NameProvider) (java.lang.Class.forName(providerClass).newInstance()))
if (diff < (((((366L + 365) * 24) * 60) * 60) * 1000)) {
	distances += ((double) (diff));
	count++;
}:if (diff < (((((366L + 365) * 24) * 60) * 60) * 1000)) {
	distances += ((double) (diff));
	count++;
}
throw new java.lang.IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset):throw new java.lang.IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset)
nameProvider = new org.joda.time.tz.DefaultNameProvider():nameProvider = new org.joda.time.tz.DefaultNameProvider()
return ((org.joda.time.format.DateTimePrinter) (f)):return ((org.joda.time.format.DateTimePrinter) (f))
builder.appendLiteral(new java.lang.String(sub)):builder.appendLiteral(new java.lang.String(sub))
return offsetPrev:return offsetPrev
char c = pattern.charAt(i):char $0 = pattern.charAt(i)
return provider:return provider
boolean inLiteral = false:boolean $0 = false
map.put("EAT", "Africa/Addis_Ababa"):map.put("EAT", "Africa/Addis_Ababa")
if (prev < instant) {
	return prev;
}:if (prev < instant) {
	return prev;
}
long instantUTC = instantLocal - offsetOriginal:long $0 = instantLocal - offsetOriginal
int[] standardOffsets = new int[size]:int[] $0 = new int[size]
return 
((((getID().equals(other.getID()) && 
java.util.Arrays.equals(iTransitions, other.iTransitions)) && 
java.util.Arrays.equals(iNameKeys, other.iNameKeys)) && 
java.util.Arrays.equals(iWallOffsets, other.iWallOffsets)) && 
java.util.Arrays.equals(iStandardOffsets, other.iStandardOffsets)) && 
(iTailZone == null ? 
null == other.iTailZone : 
iTailZone.equals(other.iTailZone)):return 
((((getID().equals(other.getID()) && 
java.util.Arrays.equals(iTransitions, other.iTransitions)) && 
java.util.Arrays.equals(iNameKeys, other.iNameKeys)) && 
java.util.Arrays.equals(iWallOffsets, other.iWallOffsets)) && 
java.util.Arrays.equals(iStandardOffsets, other.iStandardOffsets)) && 
(iTailZone == null ? 
null == other.iTailZone : 
iTailZone.equals(other.iTailZone))
map.put("HST", "Pacific/Honolulu"):map.put("HST", "Pacific/Honolulu")
map.put("EST", "America/New_York"):map.put("EST", "America/New_York")
if (i < transitions.length) {
	if (i > 0) {
		return iWallOffsets[i - 1];
	}
	return 0;
}:if (i < transitions.length) {
	if (i > 0) {
		return iWallOffsets[i - 1];
	}
	return 0;
}
maxDigits = tokenLen:maxDigits = tokenLen
return append0(new org.joda.time.format.DateTimeFormatterBuilder.Fraction(fieldType, minDigits, maxDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.Fraction(fieldType, minDigits, maxDigits))
temp = org.joda.time.DateTimeZone.UTC:temp = org.joda.time.DateTimeZone.UTC
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, true))
if (poolSize < 256) {
	index = in.readUnsignedByte();
} else {
	index = in.readUnsignedShort();
}:if (poolSize < 256) {
	index = in.readUnsignedByte();
} else {
	index = in.readUnsignedShort();
}
long nextAdjusted = nextTransition(instantLocal - offset):long $0 = nextTransition(instantLocal - offset)
throw new java.lang.IllegalArgumentException("Offset is too large"):throw new java.lang.IllegalArgumentException("Offset is too large")
return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear):return 
((iSaveMillis == other.iSaveMillis) && 
iNameKey.equals(other.iNameKey)) && 
iOfYear.equals(other.iOfYear)
return new org.joda.time.DateTimeZone.Stub(iID):return new org.joda.time.DateTimeZone.Stub(iID)
map.put("CNT", "America/St_Johns"):map.put("CNT", "America/St_Johns")
tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
tailZone.getID(), 
tailZone.iStandardOffset, 
tailZone.iStartRecurrence, 
tailZone.iEndRecurrence.renameAppend("-Summer")):tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
tailZone.getID(), 
tailZone.iStandardOffset, 
tailZone.iStartRecurrence, 
tailZone.iEndRecurrence.renameAppend("-Summer"))
if (iTailZone != null) {
	return true;
}:if (iTailZone != null) {
	return true;
}
throw new java.lang.IllegalArgumentException("Hours out of range: " + hoursOffset):throw new java.lang.IllegalArgumentException("Hours out of range: " + hoursOffset)
return iSaveMillis:return iSaveMillis
map = new java.util.HashMap<java.lang.String, java.lang.String>():map = new java.util.HashMap<java.lang.String, java.lang.String>()
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, 3):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, 3)
throw new java.lang.IllegalArgumentException("The provider doesn't support UTC"):throw new java.lang.IllegalArgumentException("The provider doesn't support UTC")
map.put("MIT", "Pacific/Apia"):map.put("MIT", "Pacific/Apia")
locale = java.util.Locale.getDefault():locale = java.util.Locale.getDefault()
final int offsetAdjusted = getOffset(instantAdjusted):final int $0 = getOffset(instantAdjusted)
return iOfYear.previous(instant, standardOffset, saveMillis):return iOfYear.previous(instant, standardOffset, saveMillis)
return isPrinter(getFormatter()):return isPrinter(getFormatter())
if (obj instanceof org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone) {
	org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone other = ((org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone) (obj));
	return 
	((((getID().equals(other.getID()) && 
	java.util.Arrays.equals(iTransitions, other.iTransitions)) && 
	java.util.Arrays.equals(iNameKeys, other.iNameKeys)) && 
	java.util.Arrays.equals(iWallOffsets, other.iWallOffsets)) && 
	java.util.Arrays.equals(iStandardOffsets, other.iStandardOffsets)) && 
	(iTailZone == null ? 
	null == other.iTailZone : 
	iTailZone.equals(other.iTailZone));
}:if (obj instanceof org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone) {
	org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone $0 = ((org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone) (obj));
	return 
	((((getID().equals($0.getID()) && 
	java.util.Arrays.equals(iTransitions, $0.iTransitions)) && 
	java.util.Arrays.equals(iNameKeys, $0.iNameKeys)) && 
	java.util.Arrays.equals(iWallOffsets, $0.iWallOffsets)) && 
	java.util.Arrays.equals(iStandardOffsets, $0.iStandardOffsets)) && 
	(iTailZone == null ? 
	null == $0.iTailZone : 
	iTailZone.equals($0.iTailZone));
}
return appendDecimal(org.joda.time.DateTimeFieldType.weekOfWeekyear(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.weekOfWeekyear(), minDigits, 2)
return isFormatter(getFormatter()):return isFormatter(getFormatter())
long prev = iTailZone.previousTransition(instant):long $0 = iTailZone.previousTransition(instant)
org.joda.time.DateTimeZone zone = org.joda.time.DateTimeZone.cProvider.getZone(id):org.joda.time.DateTimeZone $0 = org.joda.time.DateTimeZone.cProvider.getZone(id)
lenientParse = false:lenientParse = false
java.lang.StringBuilder buf = new java.lang.StringBuilder():java.lang.StringBuilder $0 = new java.lang.StringBuilder()
char c = token.charAt(0):char $0 = token.charAt(0)
if (zone == null) {
	throw new java.lang.IllegalArgumentException("The datetime zone must not be null");
}:if (zone == null) {
	throw new java.lang.IllegalArgumentException("The datetime zone must not be null");
}
if (formatter == null) {
	org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder();
	org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern);
	formatter = builder.toFormatter();

	org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
}:if (formatter == null) {
	org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder();
	org.joda.time.format.DateTimeFormat.parsePatternTo($0, pattern);
	formatter = $0.toFormatter();

	org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
}
c = pattern.charAt(i):c = pattern.charAt(i)
for (; i < length; i++) {
	c = pattern.charAt(i);

	if (c == '\'') {
		if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

			i++;
			buf.append(c);
		} else {
			inLiteral = !inLiteral;
		}
	} else { 		if ((!inLiteral) && 
		(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
			i--;
			break;
		} else {
			buf.append(c);
		}}
}:for (; i < length; i++) {
	c = pattern.charAt(i);

	if (c == '\'') {
		if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

			i++;
			buf.append(c);
		} else {
			inLiteral = !inLiteral;
		}
	} else { 		if ((!inLiteral) && 
		(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
			i--;
			break;
		} else {
			buf.append(c);
		}}
}
pool[i] = in.readUTF():pool[i] = in.readUTF()
if ((hoursOffset == 0) && (minutesOffset == 0)) {
	return org.joda.time.DateTimeZone.UTC;
}:if ((hoursOffset == 0) && (minutesOffset == 0)) {
	return org.joda.time.DateTimeZone.UTC;
}
return this:return this
buf.append('-'):buf.append('-')
f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle):f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle)
nameKeys[i] = tr.getNameKey():nameKeys[i] = tr.getNameKey()
java.lang.String[] pool = new java.lang.String[poolSize]:java.lang.String[] $0 = new java.lang.String[poolSize]
if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setLoc = strings;
	break;
}:if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setLoc = strings;
	break;
}
return new org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone(
id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone):return new org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone(
id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone)
return new org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone(
outputID ? id : "", trans, wallOffsets, standardOffsets, nameKeys, tailZone):return new org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone(
outputID ? id : "", trans, wallOffsets, standardOffsets, nameKeys, tailZone)
if (i > 0) {
	return iNameKeys[i - 1];
}:if (i > 0) {
	return iNameKeys[i - 1];
}
if (byNameKeyCache == null) {
	byIdCache.put(id, byNameKeyCache = createCache());

	java.lang.String[][] $0 = org.joda.time.DateTimeUtils.getDateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings();
	java.lang.String[] $1 = null;
	for (java.lang.String[] $2 : $0) {
		if ((($2 != null) && ($2.length == 5)) && id.equals($2[0])) {
			$1 = $2;
			break;
		}
	}
	java.lang.String[][] $3 = org.joda.time.DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
	java.lang.String[] $4 = null;
	for (java.lang.String[] $5 : $3) {
		if ((($5 != null) && ($5.length == 5)) && id.equals($5[0])) {
			$4 = $5;
			break;
		}
	}

	if (($1 != null) && ($4 != null)) {
		byNameKeyCache.put($1[2], new java.lang.String[]{ $4[2], $4[1] });



		if ($1[2].equals($1[4])) {
			byNameKeyCache.put($1[4] + "-Summer", new java.lang.String[]{ $4[4], $4[3] });
		} else {
			byNameKeyCache.put($1[4], new java.lang.String[]{ $4[4], $4[3] });
		}
	}
}:if (byNameKeyCache == null) {
	byIdCache.put(id, byNameKeyCache = createCache());

	java.lang.String[][] $0 = org.joda.time.DateTimeUtils.getDateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings();
	java.lang.String[] $1 = null;
	for (java.lang.String[] $2 : $0) {
		if ((($2 != null) && ($2.length == 5)) && id.equals($2[0])) {
			$1 = $2;
			break;
		}
	}
	java.lang.String[][] $3 = org.joda.time.DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
	java.lang.String[] $4 = null;
	for (java.lang.String[] $5 : $3) {
		if ((($5 != null) && ($5.length == 5)) && id.equals($5[0])) {
			$4 = $5;
			break;
		}
	}

	if (($1 != null) && ($4 != null)) {
		byNameKeyCache.put($1[2], new java.lang.String[]{ $4[2], $4[1] });



		if ($1[2].equals($1[4])) {
			byNameKeyCache.put($1[4] + "-Summer", new java.lang.String[]{ $4[4], $4[3] });
		} else {
			byNameKeyCache.put($1[4], new java.lang.String[]{ $4[4], $4[3] });
		}
	}
}
return getOffset(instant) == getStandardOffset(instant):return getOffset(instant) == getStandardOffset(instant)
java.lang.String convId = org.joda.time.DateTimeZone.getConvertedId(id):java.lang.String $0 = org.joda.time.DateTimeZone.getConvertedId(id)
if (providerClass != null) {
	try {
		nameProvider = ((org.joda.time.tz.NameProvider) (java.lang.Class.forName(providerClass).newInstance()));
	} catch (java.lang.Exception ex) {
		throw new java.lang.RuntimeException(ex);
	}
}:if (providerClass != null) {
	try {
		nameProvider = ((org.joda.time.tz.NameProvider) (java.lang.Class.forName(providerClass).newInstance()));
	} catch (java.lang.Exception ex) {
		throw new java.lang.RuntimeException(ex);
	}
}
if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) {
	convId = convId.substring(3);
	int offset = org.joda.time.DateTimeZone.parseOffset(convId);
	if (offset == 0L) {
		return org.joda.time.DateTimeZone.UTC;
	} else {
		convId = org.joda.time.DateTimeZone.printOffset(offset);
		return org.joda.time.DateTimeZone.fixedOffsetZone(convId, offset);
	}
}:if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) {
	convId = convId.substring(3);
	int $0 = org.joda.time.DateTimeZone.parseOffset(convId);
	if ($0 == 0L) {
		return org.joda.time.DateTimeZone.UTC;
	} else {
		convId = org.joda.time.DateTimeZone.printOffset($0);
		return org.joda.time.DateTimeZone.fixedOffsetZone(convId, $0);
	}
}
return name:return name
long transition = nextTransition(instantBefore):long $0 = nextTransition(instantBefore)
return append0(printer, parser):return append0(printer, parser)
return instant:return instant
if (!ids.contains("UTC")) {
	throw new java.lang.IllegalArgumentException("The provider doesn't support UTC");
}:if (!ids.contains("UTC")) {
	throw new java.lang.IllegalArgumentException("The provider doesn't support UTC");
}
if (org.joda.time.DateTimeZone.cOffsetFormatter == null) {
	org.joda.time.DateTimeZone.cOffsetFormatter = new org.joda.time.format.DateTimeFormatterBuilder().appendTimeZoneOffset(
	null, true, 2, 4).toFormatter();

}:if (org.joda.time.DateTimeZone.cOffsetFormatter == null) {
	org.joda.time.DateTimeZone.cOffsetFormatter = new org.joda.time.format.DateTimeFormatterBuilder().appendTimeZoneOffset(
	null, true, 2, 4).toFormatter();

}
final java.lang.String id = zone.getID():final java.lang.String $0 = zone.getID()
if (convId == null) {
	convId = zone.getID();
	if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) {
		convId = convId.substring(3);
		int offset = org.joda.time.DateTimeZone.parseOffset(convId);
		if (offset == 0L) {
			return org.joda.time.DateTimeZone.UTC;
		} else {
			convId = org.joda.time.DateTimeZone.printOffset(offset);
			return org.joda.time.DateTimeZone.fixedOffsetZone(convId, offset);
		}
	}
}:if (convId == null) {
	convId = zone.getID();
	if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) {
		convId = convId.substring(3);
		int $0 = org.joda.time.DateTimeZone.parseOffset(convId);
		if ($0 == 0L) {
			return org.joda.time.DateTimeZone.UTC;
		} else {
			convId = org.joda.time.DateTimeZone.printOffset($0);
			return org.joda.time.DateTimeZone.fixedOffsetZone(convId, $0);
		}
	}
}
long overlapEnd = transition + diff:long $0 = transition + diff
return appendShortText(org.joda.time.DateTimeFieldType.monthOfYear()):return appendShortText(org.joda.time.DateTimeFieldType.monthOfYear())
java.util.Set<java.lang.String> poolSet = new java.util.HashSet<java.lang.String>():java.util.Set<java.lang.String> $0 = new java.util.HashSet<java.lang.String>()
return formatter:return formatter
map.put("PRT", "America/Puerto_Rico"):map.put("PRT", "America/Puerto_Rico")
org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f:org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f
int diff = offsetPrev - offsetLocal:int $0 = offsetPrev - offsetLocal
return buf.toString():return buf.toString()
minutesOffset = hoursInMinutes - java.lang.Math.abs(minutesOffset):minutesOffset = hoursInMinutes - java.lang.Math.abs(minutesOffset)
type = org.joda.time.format.DateTimeFormat.TIME:type = org.joda.time.format.DateTimeFormat.TIME
return appendSignedDecimal(org.joda.time.DateTimeFieldType.weekyear(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.weekyear(), minDigits, maxDigits)
if (instant < end) {
	instant = end;
}:if (instant < end) {
	instant = end;
}
buf.append('.'):buf.append('.')
return org.joda.time.DateTimeZone.cAvailableIDs:return org.joda.time.DateTimeZone.cAvailableIDs
out.writeByte(j):out.writeByte(j)
if (i < transitions.length) {
	if (i > 0) {
		return iStandardOffsets[i - 1];
	}
	return 0;
}:if (i < transitions.length) {
	if (i > 0) {
		return iStandardOffsets[i - 1];
	}
	return 0;
}
return appendDecimal(org.joda.time.DateTimeFieldType.hourOfHalfday(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.hourOfHalfday(), minDigits, 2)
if (i >= 0) {
	return iNameKeys[i];
}:if (i >= 0) {
	return iNameKeys[i];
}
offset -= minutes * org.joda.time.DateTimeConstants.MILLIS_PER_MINUTE:offset -= minutes * org.joda.time.DateTimeConstants.MILLIS_PER_MINUTE
return f:return f
java.lang.String[] nameKeys = new java.lang.String[size]:java.lang.String[] $0 = new java.lang.String[size]
synchronized(org.joda.time.DateTimeZone.class) {
	org.joda.time.DateTimeZone.cDefault = zone;
}:synchronized(org.joda.time.DateTimeZone.class) {
	org.joda.time.DateTimeZone.cDefault = zone;
}
return getShortName(instant, null):return getShortName(instant, null)
long instantBefore = instant - (3 * org.joda.time.DateTimeConstants.MILLIS_PER_HOUR):long $0 = instant - (3 * org.joda.time.DateTimeConstants.MILLIS_PER_HOUR)
formatter = builder.toFormatter():formatter = builder.toFormatter()
int i = indexRef[0]:int $0 = indexRef[0]
int count = 0:int $0 = 0
if (iTailZone == null) {
	return instant;
}:if (iTailZone == null) {
	return instant;
}
char peek = pattern.charAt(i + 1):char $0 = pattern.charAt(i + 1)
temp = org.joda.time.DateTimeZone.forID(id):temp = org.joda.time.DateTimeZone.forID(id)
if (tailZone.iStartRecurrence.getSaveMillis() > 0) {
	tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
	tailZone.getID(), 
	tailZone.iStandardOffset, 
	tailZone.iStartRecurrence.renameAppend("-Summer"), 
	tailZone.iEndRecurrence);
} else {
	tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
	tailZone.getID(), 
	tailZone.iStandardOffset, 
	tailZone.iStartRecurrence, 
	tailZone.iEndRecurrence.renameAppend("-Summer"));
}:if (tailZone.iStartRecurrence.getSaveMillis() > 0) {
	tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
	tailZone.getID(), 
	tailZone.iStandardOffset, 
	tailZone.iStartRecurrence.renameAppend("-Summer"), 
	tailZone.iEndRecurrence);
} else {
	tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
	tailZone.getID(), 
	tailZone.iStandardOffset, 
	tailZone.iStartRecurrence, 
	tailZone.iEndRecurrence.renameAppend("-Summer"));
}
if (((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) {


	buf.append(c);

	while ((i + 1) < length) {
		char peek = pattern.charAt(i + 1);
		if (peek == c) {
			buf.append(c);
			i++;
		} else {
			break;
		}
	} 
} else {

	buf.append('\'');

	boolean inLiteral = false;

	for (; i < length; i++) {
		c = pattern.charAt(i);

		if (c == '\'') {
			if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

				i++;
				buf.append(c);
			} else {
				inLiteral = !inLiteral;
			}
		} else { 			if ((!inLiteral) && 
			(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
				i--;
				break;
			} else {
				buf.append(c);
			}}
	}
}:if (((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) {


	buf.append(c);

	while ((i + 1) < length) {
		char $0 = pattern.charAt(i + 1);
		if ($0 == c) {
			buf.append(c);
			i++;
		} else {
			break;
		}
	} 
} else {

	buf.append('\'');

	boolean $1 = false;

	for (; i < length; i++) {
		c = pattern.charAt(i);

		if (c == '\'') {
			if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

				i++;
				buf.append(c);
			} else {
				$1 = !$1;
			}
		} else { 			if ((!$1) && 
			(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
				i--;
				break;
			} else {
				buf.append(c);
			}}
	}
}
last = tr:last = tr
return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, false, minDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, false, minDigits))
int length = pattern.length():int $0 = pattern.length()
return iOfYear.next(instant, standardOffset, saveMillis):return iOfYear.next(instant, standardOffset, saveMillis)
java.lang.String curNameKey = nameKeys[i]:java.lang.String $0 = nameKeys[i]
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.SHORT_NAME, null), null):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.SHORT_NAME, null), null)
builder.appendDayOfWeekShortText():builder.appendDayOfWeekShortText()
if (zone == null) {
	return org.joda.time.DateTimeZone.getDefault();
}:if (zone == null) {
	return org.joda.time.DateTimeZone.getDefault();
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral(c)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral(c))
provider = ((org.joda.time.tz.Provider) (java.lang.Class.forName(providerClass).newInstance())):provider = ((org.joda.time.tz.Provider) (java.lang.Class.forName(providerClass).newInstance()))
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.LONG):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.LONG)
if (tokenLen == 2) {
	builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
} else {
	builder.appendTimeZoneId();
}:if (tokenLen == 2) {
	builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
} else {
	builder.appendTimeZoneId();
}
return 0:return 0
long instantUTC = instantLocal - offset:long $0 = instantLocal - offset
return isPrinter(f) || isParser(f):return isPrinter(f) || isParser(f)
index = in.readUnsignedByte():index = in.readUnsignedByte()
java.lang.String name = org.joda.time.DateTimeZone.cNameProvider.getShortName(locale, iID, nameKey):java.lang.String $0 = org.joda.time.DateTimeZone.cNameProvider.getShortName(locale, iID, nameKey)
map.put("EET", "EET"):map.put("EET", "EET")
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfMonth(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfMonth(), minDigits, 2)
if (strict || (offsetLocal < 0)) {

	long nextLocal = nextTransition(instantLocal - offsetLocal);
	if (nextLocal == (instantLocal - offsetLocal)) {
		nextLocal = java.lang.Long.MAX_VALUE;
	}
	long nextAdjusted = nextTransition(instantLocal - offset);
	if (nextAdjusted == (instantLocal - offset)) {
		nextAdjusted = java.lang.Long.MAX_VALUE;
	}
	if (nextLocal != nextAdjusted) {

		if (strict) {

			throw new org.joda.time.IllegalInstantException(instantLocal, getID());
		} else {



			offset = offsetLocal;
		}
	}
}:if (strict || (offsetLocal < 0)) {

	long $0 = nextTransition(instantLocal - offsetLocal);
	if ($0 == (instantLocal - offsetLocal)) {
		$0 = java.lang.Long.MAX_VALUE;
	}
	long $1 = nextTransition(instantLocal - offset);
	if ($1 == (instantLocal - offset)) {
		$1 = java.lang.Long.MAX_VALUE;
	}
	if ($0 != $1) {

		if (strict) {

			throw new org.joda.time.IllegalInstantException(instantLocal, getID());
		} else {



			offset = offsetLocal;
		}
	}
}
if (newZone == this) {
	return oldInstant;
}:if (newZone == this) {
	return oldInstant;
}
return appendDecimal(org.joda.time.DateTimeFieldType.monthOfYear(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.monthOfYear(), minDigits, 2)
int index = ((dateStyle << 2) + dateStyle) + timeStyle:int $0 = ((dateStyle << 2) + dateStyle) + timeStyle
return appendDecimal(org.joda.time.DateTimeFieldType.millisOfSecond(), minDigits, 3):return appendDecimal(org.joda.time.DateTimeFieldType.millisOfSecond(), minDigits, 3)
long[] transitions = new long[size]:long[] $0 = new long[size]
if (iTailZone == null) {
	return iNameKeys[i - 1];
}:if (iTailZone == null) {
	return iNameKeys[i - 1];
}
return getOffset(instant.getMillis()):return getOffset(instant.getMillis())
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.SHORT):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.SHORT)
if (i > 0) {
	return iStandardOffsets[i - 1];
}:if (i > 0) {
	return iStandardOffsets[i - 1];
}
if (instant > java.lang.Long.MIN_VALUE) {
	return instant - 1;
}:if (instant > java.lang.Long.MIN_VALUE) {
	return instant - 1;
}
if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setEn = strings;
	break;
}:if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
	setEn = strings;
	break;
}
if (c == '\'') {
	if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

		i++;
		buf.append(c);
	} else {
		inLiteral = !inLiteral;
	}
} else { 	if ((!inLiteral) && 
	(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
		i--;
		break;
	} else {
		buf.append(c);
	}}:if (c == '\'') {
	if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

		i++;
		buf.append(c);
	} else {
		inLiteral = !inLiteral;
	}
} else { 	if ((!inLiteral) && 
	(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
		i--;
		break;
	} else {
		buf.append(c);
	}}
builder.appendTimeZoneOffset(null, "Z", false, 2, 2):builder.appendTimeZoneOffset(null, "Z", false, 2, 2)
long overlapStart = transition - diff:long $0 = transition - diff
org.joda.time.DateTimeZone dtz = null:org.joda.time.DateTimeZone $0 = null
if (((instantLocal ^ instantUTC) < 0) && ((instantLocal ^ offset) < 0)) {
	throw new java.lang.ArithmeticException("Subtracting time zone offset caused overflow");
}:if (((instantLocal ^ instantUTC) < 0) && ((instantLocal ^ offset) < 0)) {
	throw new java.lang.ArithmeticException("Subtracting time zone offset caused overflow");
}
ex.printStackTrace():ex.printStackTrace()
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.MEDIUM):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.MEDIUM)
return org.joda.time.DateTimeZone.fixedOffsetZone(convId, offset):return org.joda.time.DateTimeZone.fixedOffsetZone(convId, offset)
newZone = org.joda.time.DateTimeZone.getDefault():newZone = org.joda.time.DateTimeZone.getDefault()
transitions[i] = org.joda.time.tz.DateTimeZoneBuilder.readMillis(in):transitions[i] = org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)
if (nameKey == null) {
	return iID;
}:if (nameKey == null) {
	return iID;
}
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.MEDIUM):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.MEDIUM)
indexRef[0]--:indexRef[0]--
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.NONE)
long instantAfter = instant + (3 * org.joda.time.DateTimeConstants.MILLIS_PER_HOUR):long $0 = instant + (3 * org.joda.time.DateTimeConstants.MILLIS_PER_HOUR)
formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern):formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern)
return appendDecimal(org.joda.time.DateTimeFieldType.dayOfWeek(), minDigits, 1):return appendDecimal(org.joda.time.DateTimeFieldType.dayOfWeek(), minDigits, 1)
if ((ids == null) || (ids.size() == 0)) {
	throw new java.lang.IllegalArgumentException(
	"The provider doesn't have any available ids");
}:if ((ids == null) || (ids.size() == 0)) {
	throw new java.lang.IllegalArgumentException(
	"The provider doesn't have any available ids");
}
return org.joda.time.DateTimeZone.getDefault():return org.joda.time.DateTimeZone.getDefault()
if (newZone == null) {
	newZone = org.joda.time.DateTimeZone.getDefault();
}:if (newZone == null) {
	newZone = org.joda.time.DateTimeZone.getDefault();
}
if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
	java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
	tailZone.iStartRecurrence.getNameKey());
}:if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
	java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
	tailZone.iStartRecurrence.getNameKey());
}
for (int i = 0; i < size; i++) {
	poolSet.add(iNameKeys[i]);
}:for (int $0 = 0; $0 < size; $0++) {
	poolSet.add(iNameKeys[$0]);
}
if (peek == c) {
	buf.append(c);
	i++;
} else {
	break;
}:if (peek == c) {
	buf.append(c);
	i++;
} else {
	break;
}
builder.appendLiteral(sub.charAt(0)):builder.appendLiteral(sub.charAt(0))
org.joda.time.DateTimeZone.cNameProvider = nameProvider:org.joda.time.DateTimeZone.cNameProvider = nameProvider
return appendSignedDecimal(org.joda.time.DateTimeFieldType.year(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.year(), minDigits, maxDigits)
java.lang.String name = org.joda.time.DateTimeZone.cNameProvider.getName(locale, iID, nameKey):java.lang.String $0 = org.joda.time.DateTimeZone.cNameProvider.getName(locale, iID, nameKey)
long offsetAfter = getOffset(instantAfter):long $0 = getOffset(instantAfter)
int offset = getOffset(instantLocal - offsetLocal):int $0 = getOffset(instantLocal - offsetLocal)
i = indexRef[0]:i = indexRef[0]
int timeStyle = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(1)):int $0 = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(1))
map.put("ECT", "CET"):map.put("ECT", "CET")
return iOfYear:return iOfYear
return iStandardOffsets[i]:return iStandardOffsets[i]
buf.append(c):buf.append(c)
org.joda.time.DateTimeZone.setNameProvider0(null):org.joda.time.DateTimeZone.setNameProvider0(null)
if (tokenLen > 0) {
	char c = token.charAt(0);
	switch (c) {
		case 'c' :
		case 'C' :
		case 'x' :
		case 'y' :
		case 'Y' :
		case 'd' :
		case 'h' :
		case 'H' :
		case 'm' :
		case 's' :
		case 'S' :
		case 'e' :
		case 'D' :
		case 'F' :
		case 'w' :
		case 'W' :
		case 'k' :
		case 'K' :
			return true;
		case 'M' :
			if (tokenLen <= 2) {
				return true;
			}}

}:if (tokenLen > 0) {
	char $0 = token.charAt(0);
	switch ($0) {
		case 'c' :
		case 'C' :
		case 'x' :
		case 'y' :
		case 'Y' :
		case 'd' :
		case 'h' :
		case 'H' :
		case 'm' :
		case 's' :
		case 'S' :
		case 'e' :
		case 'D' :
		case 'F' :
		case 'w' :
		case 'W' :
		case 'k' :
		case 'K' :
			return true;
		case 'M' :
			if (tokenLen <= 2) {
				return true;
			}}

}
java.util.Iterator<java.lang.String> it = poolSet.iterator():java.util.Iterator<java.lang.String> $0 = poolSet.iterator()
return append0(pp, pp):return append0(pp, pp)
final int offsetLocal = getOffset(instantLocal):final int $0 = getOffset(instantLocal)
convId = org.joda.time.DateTimeZone.printOffset(offset):convId = org.joda.time.DateTimeZone.printOffset(offset)
if (i >= 0) {
	return iStandardOffsets[i];
}:if (i >= 0) {
	return iStandardOffsets[i];
}
if (in.readBoolean()) {
	tailZone = org.joda.time.tz.DateTimeZoneBuilder.DSTZone.readFrom(in, id);
}:if (in.readBoolean()) {
	tailZone = org.joda.time.tz.DateTimeZoneBuilder.DSTZone.readFrom(in, id);
}
break:break
boolean lenientParse = true:boolean $0 = true
return iTailZone.nextTransition(instant):return iTailZone.nextTransition(instant)
return dtz:return dtz
return instant - 1:return instant - 1
distances += ((double) (diff)):distances += ((double) (diff))
temp = org.joda.time.DateTimeZone.forTimeZone(java.util.TimeZone.getDefault()):temp = org.joda.time.DateTimeZone.forTimeZone(java.util.TimeZone.getDefault())
if (providerClass != null) {
	try {
		provider = ((org.joda.time.tz.Provider) (java.lang.Class.forName(providerClass).newInstance()));
	} catch (java.lang.Exception ex) {
		throw new java.lang.RuntimeException(ex);
	}
}:if (providerClass != null) {
	try {
		provider = ((org.joda.time.tz.Provider) (java.lang.Class.forName(providerClass).newInstance()));
	} catch (java.lang.Exception ex) {
		throw new java.lang.RuntimeException(ex);
	}
}
localDateTime.toDateTime(this):localDateTime.toDateTime(this)
return appendDecimal(org.joda.time.DateTimeFieldType.secondOfMinute(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.secondOfMinute(), minDigits, 2)
if ((dateStyle == org.joda.time.format.DateTimeFormat.NONE) && (timeStyle == org.joda.time.format.DateTimeFormat.NONE)) {
	throw new java.lang.IllegalArgumentException("Style '--' is invalid");
}:if ((dateStyle == org.joda.time.format.DateTimeFormat.NONE) && (timeStyle == org.joda.time.format.DateTimeFormat.NONE)) {
	throw new java.lang.IllegalArgumentException("Style '--' is invalid");
}
convId = zone.getID():convId = zone.getID()
if (i > 0) {
	long prev = transitions[i - 1];
	if (prev > java.lang.Long.MIN_VALUE) {
		return prev - 1;
	}
}:if (i > 0) {
	long $0 = transitions[i - 1];
	if ($0 > java.lang.Long.MIN_VALUE) {
		return $0 - 1;
	}
}
if ((((((((curOffset != nextOffset) && 
(curStdOffset == nextStdOffset)) && 
curNameKey.equals(nextNameKey)) && 
(p.getYears() == 0)) && (p.getMonths() > 4)) && (p.getMonths() < 8)) && 
curNameKey.equals(zoneNameData[2])) && 
curNameKey.equals(zoneNameData[4])) {

	if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
		java.lang.System.out.println("Fixing duplicate name key - " + nextNameKey);
		java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[i], chrono)) + 
		" - ") + new org.joda.time.DateTime(trans[i + 1], chrono));
	}
	if (curOffset > nextOffset) {
		nameKeys[i] = (curNameKey + "-Summer").intern();
	} else { 		if (curOffset < nextOffset) {
			nameKeys[i + 1] = (nextNameKey + "-Summer").intern();
			i++;
		}}
}:if ((((((((curOffset != nextOffset) && 
(curStdOffset == nextStdOffset)) && 
curNameKey.equals(nextNameKey)) && 
(p.getYears() == 0)) && (p.getMonths() > 4)) && (p.getMonths() < 8)) && 
curNameKey.equals(zoneNameData[2])) && 
curNameKey.equals(zoneNameData[4])) {

	if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
		java.lang.System.out.println("Fixing duplicate name key - " + nextNameKey);
		java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[i], chrono)) + 
		" - ") + new org.joda.time.DateTime(trans[i + 1], chrono));
	}
	if (curOffset > nextOffset) {
		nameKeys[i] = (curNameKey + "-Summer").intern();
	} else { 		if (curOffset < nextOffset) {
			nameKeys[i + 1] = (nextNameKey + "-Summer").intern();
			i++;
		}}
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.year(), pivot, lenientParse)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.year(), pivot, lenientParse))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, true))
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.LONG_NAME, null), null):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName(org.joda.time.format.DateTimeFormatterBuilder.TimeZoneName.LONG_NAME, null), null)
return appendTwoDigitYear(pivot, false):return appendTwoDigitYear(pivot, false)
if (curOffset > nextOffset) {
	nameKeys[i] = (curNameKey + "-Summer").intern();
} else { 	if (curOffset < nextOffset) {
		nameKeys[i + 1] = (nextNameKey + "-Summer").intern();
		i++;
	}}:if (curOffset > nextOffset) {
	nameKeys[i] = (curNameKey + "-Summer").intern();
} else { 	if (curOffset < nextOffset) {
		nameKeys[i + 1] = (nextNameKey + "-Summer").intern();
		i++;
	}}
return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle):return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle)
indexRef[0] = i:indexRef[0] = i
if (iTailZone == null) {
	return iWallOffsets[i - 1];
}:if (iTailZone == null) {
	return iWallOffsets[i - 1];
}
if (index >= org.joda.time.format.DateTimeFormat.STYLE_CACHE.length) {
	return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
}:if (index >= org.joda.time.format.DateTimeFormat.STYLE_CACHE.length) {
	return org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
}
if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
	java.lang.System.out.println("Fixing duplicate name key - " + nextNameKey);
	java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[i], chrono)) + 
	" - ") + new org.joda.time.DateTime(trans[i + 1], chrono));
}:if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
	java.lang.System.out.println("Fixing duplicate name key - " + nextNameKey);
	java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[i], chrono)) + 
	" - ") + new org.joda.time.DateTime(trans[i + 1], chrono));
}
if (isFixed()) {
	return false;
}:if (isFixed()) {
	return false;
}
buf.append(':'):buf.append(':')
return java.util.TimeZone.getTimeZone(iID):return java.util.TimeZone.getTimeZone(iID)
return true:return true
return iNameKeys[i]:return iNameKeys[i]
long instantLocal = convertUTCToLocal(oldInstant):long $0 = convertUTCToLocal(oldInstant)
return ((org.joda.time.format.DateTimeFormat.StyleFormatter) (formatter.getPrinter())).getPattern(locale):return ((org.joda.time.format.DateTimeFormat.StyleFormatter) (formatter.getPrinter())).getPattern(locale)
return org.joda.time.format.DateTimeFormat.createFormatterForStyle(style):return org.joda.time.format.DateTimeFormat.createFormatterForStyle(style)
throw new java.lang.IllegalArgumentException("Invalid pattern specification"):throw new java.lang.IllegalArgumentException("Invalid pattern specification")
if (locale == null) {
	locale = java.util.Locale.getDefault();
}:if (locale == null) {
	locale = java.util.Locale.getDefault();
}
throw new java.lang.IllegalArgumentException("Style '--' is invalid"):throw new java.lang.IllegalArgumentException("Style '--' is invalid")
int offsetLocalFromOriginal = getOffset(instantUTC):int $0 = getOffset(instantUTC)
throw new java.lang.UnsupportedOperationException("String pool is too large"):throw new java.lang.UnsupportedOperationException("String pool is too large")
if (provider == null) {
	provider = new org.joda.time.tz.UTCProvider();
}:if (provider == null) {
	provider = new org.joda.time.tz.UTCProvider();
}
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.MEDIUM, org.joda.time.format.DateTimeFormat.NONE)
org.joda.time.tz.DateTimeZoneBuilder.Transition last = null:org.joda.time.tz.DateTimeZoneBuilder.Transition $0 = null
return ((org.joda.time.format.DateTimeParser) (f)):return ((org.joda.time.format.DateTimeParser) (f))
if (offset == 0L) {
	return org.joda.time.DateTimeZone.UTC;
} else {
	id = org.joda.time.DateTimeZone.printOffset(offset);
	return org.joda.time.DateTimeZone.fixedOffsetZone(id, offset);
}:if (offset == 0L) {
	return org.joda.time.DateTimeZone.UTC;
} else {
	id = org.joda.time.DateTimeZone.printOffset(offset);
	return org.joda.time.DateTimeZone.fixedOffsetZone(id, offset);
}
out.writeBoolean(iTailZone != null):out.writeBoolean(iTailZone != null)
java.lang.StringBuffer buf = new java.lang.StringBuffer():java.lang.StringBuffer $0 = new java.lang.StringBuffer()
if (((set != null) && (set.length == 5)) && id.equals(set[0])) {
	zoneNameData = set;
}:if (((set != null) && (set.length == 5)) && id.equals(set[0])) {
	zoneNameData = set;
}
return appendDecimal(org.joda.time.DateTimeFieldType.yearOfCentury(), minDigits, maxDigits):return appendDecimal(org.joda.time.DateTimeFieldType.yearOfCentury(), minDigits, maxDigits)
java.lang.String[] zoneNameData = new java.lang.String[5]:java.lang.String[] $0 = new java.lang.String[5]
return appendText(org.joda.time.DateTimeFieldType.monthOfYear()):return appendText(org.joda.time.DateTimeFieldType.monthOfYear())
if (i < transitions.length) {
	return transitions[i];
}:if (i < transitions.length) {
	return transitions[i];
}
while ((i + 1) < length) {
	char peek = pattern.charAt(i + 1);
	if (peek == c) {
		buf.append(c);
		i++;
	} else {
		break;
	}
} :while ((i + 1) < length) {
	char $0 = pattern.charAt(i + 1);
	if ($0 == c) {
		buf.append(c);
		i++;
	} else {
		break;
	}
} 
long curStdOffset = standardOffsets[i]:long $0 = standardOffsets[i]
long nextStdOffset = standardOffsets[i + 1]:long $0 = standardOffsets[i + 1]
if (i < transitions.length) {
	if (i > 0) {
		long prev = transitions[i - 1];
		if (prev > java.lang.Long.MIN_VALUE) {
			return prev - 1;
		}
	}
	return instant;
}:if (i < transitions.length) {
	if (i > 0) {
		long $0 = transitions[i - 1];
		if ($0 > java.lang.Long.MIN_VALUE) {
			return $0 - 1;
		}
	}
	return instant;
}
return org.joda.time.DateTimeZone.cProvider:return org.joda.time.DateTimeZone.cProvider
if (prev > java.lang.Long.MIN_VALUE) {
	return prev - 1;
}:if (prev > java.lang.Long.MIN_VALUE) {
	return prev - 1;
}
for (int j = 0; j < poolSize; j++) {
	if (pool[j].equals(nameKey)) {
		if (poolSize < 256) {
			out.writeByte(j);
		} else {
			out.writeShort(j);
		}
		break;
	}
}:for (int $0 = 0; $0 < poolSize; $0++) {
	if (pool[$0].equals(nameKey)) {
		if (poolSize < 256) {
			out.writeByte($0);
		} else {
			out.writeShort($0);
		}
		break;
	}
}
java.util.Set<java.lang.String> ids = provider.getAvailableIDs():java.util.Set<java.lang.String> $0 = provider.getAvailableIDs()
if (id == null) {
	throw new java.lang.IllegalArgumentException("Id must not be null");
}:if (id == null) {
	throw new java.lang.IllegalArgumentException("Id must not be null");
}
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.SHORT, org.joda.time.format.DateTimeFormat.NONE)
for (int i = 0; it.hasNext(); i++) {
	pool[i] = it.next();
}:for (int $0 = 0; it.hasNext(); $0++) {
	pool[$0] = it.next();
}
builder.appendMonthOfYear(tokenLen):builder.appendMonthOfYear(tokenLen)
if (tailZone != null) {
	if (tailZone.iStartRecurrence.getNameKey().equals(
	tailZone.iEndRecurrence.getNameKey())) {
		if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
			java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
			tailZone.iStartRecurrence.getNameKey());
		}
		if (tailZone.iStartRecurrence.getSaveMillis() > 0) {
			tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
			tailZone.getID(), 
			tailZone.iStandardOffset, 
			tailZone.iStartRecurrence.renameAppend("-Summer"), 
			tailZone.iEndRecurrence);
		} else {
			tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
			tailZone.getID(), 
			tailZone.iStandardOffset, 
			tailZone.iStartRecurrence, 
			tailZone.iEndRecurrence.renameAppend("-Summer"));
		}
	}
}:if (tailZone != null) {
	if (tailZone.iStartRecurrence.getNameKey().equals(
	tailZone.iEndRecurrence.getNameKey())) {
		if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
			java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
			tailZone.iStartRecurrence.getNameKey());
		}
		if (tailZone.iStartRecurrence.getSaveMillis() > 0) {
			tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
			tailZone.getID(), 
			tailZone.iStandardOffset, 
			tailZone.iStartRecurrence.renameAppend("-Summer"), 
			tailZone.iEndRecurrence);
		} else {
			tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
			tailZone.getID(), 
			tailZone.iStandardOffset, 
			tailZone.iStartRecurrence, 
			tailZone.iEndRecurrence.renameAppend("-Summer"));
		}
	}
}
if (dtz == null) {
	dtz = org.joda.time.DateTimeZone.cProvider.getZone(id);
}:if (dtz == null) {
	dtz = org.joda.time.DateTimeZone.cProvider.getZone(id);
}
return org.joda.time.format.DateTimeFormat.createFormatterForPattern(pattern):return org.joda.time.format.DateTimeFormat.createFormatterForPattern(pattern)
org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iWallOffsets[i]):org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iWallOffsets[i])
out.writeUTF(pool[i]):out.writeUTF(pool[i])
iID = id:iID = id
java.lang.String nameKey = getNameKey(instant):java.lang.String $0 = getNameKey(instant)
int[] indexRef = new int[1]:int[] $0 = new int[1]
dtz = org.joda.time.DateTimeZone.cProvider.getZone(id):dtz = org.joda.time.DateTimeZone.cProvider.getZone(id)
builder.appendMonthOfYearShortText():builder.appendMonthOfYearShortText()
if (avg >= 25) {






	return true;
}:if (avg >= 25) {






	return true;
}
if (sm != null) {
	sm.checkPermission(new org.joda.time.JodaTimePermission("DateTimeZone.setProvider"));
}:if (sm != null) {
	sm.checkPermission(new org.joda.time.JodaTimePermission("DateTimeZone.setProvider"));
}
return appendDecimal(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, 5):return appendDecimal(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, 5)
provider = org.joda.time.DateTimeZone.getDefaultProvider():provider = org.joda.time.DateTimeZone.getDefaultProvider()
switch (c) {
	case 'G' :
		builder.appendEraText();
		break;
	case 'C' :
		builder.appendCenturyOfEra(tokenLen, tokenLen);
		break;
	case 'x' :
	case 'y' :
	case 'Y' :
		if (tokenLen == 2) {
			boolean lenientParse = true;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



					lenientParse = false;
				}
				indexRef[0]--;
			}


			switch (c) {
				case 'x' :
					builder.appendTwoDigitWeekyear(
					new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
					break;
				case 'y' :
				case 'Y' :
				default :
					builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
					break;}

		} else {

			int maxDigits = 9;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

					maxDigits = tokenLen;
				}
				indexRef[0]--;
			}

			switch (c) {
				case 'x' :
					builder.appendWeekyear(tokenLen, maxDigits);
					break;
				case 'y' :
					builder.appendYear(tokenLen, maxDigits);
					break;
				case 'Y' :
					builder.appendYearOfEra(tokenLen, maxDigits);
					break;}

		}
		break;
	case 'M' :
		if (tokenLen >= 3) {
			if (tokenLen >= 4) {
				builder.appendMonthOfYearText();
			} else {
				builder.appendMonthOfYearShortText();
			}
		} else {
			builder.appendMonthOfYear(tokenLen);
		}
		break;
	case 'd' :
		builder.appendDayOfMonth(tokenLen);
		break;
	case 'a' :
		builder.appendHalfdayOfDayText();
		break;
	case 'h' :
		builder.appendClockhourOfHalfday(tokenLen);
		break;
	case 'H' :
		builder.appendHourOfDay(tokenLen);
		break;
	case 'k' :
		builder.appendClockhourOfDay(tokenLen);
		break;
	case 'K' :
		builder.appendHourOfHalfday(tokenLen);
		break;
	case 'm' :
		builder.appendMinuteOfHour(tokenLen);
		break;
	case 's' :
		builder.appendSecondOfMinute(tokenLen);
		break;
	case 'S' :
		builder.appendFractionOfSecond(tokenLen, tokenLen);
		break;
	case 'e' :
		builder.appendDayOfWeek(tokenLen);
		break;
	case 'E' :
		if (tokenLen >= 4) {
			builder.appendDayOfWeekText();
		} else {
			builder.appendDayOfWeekShortText();
		}
		break;
	case 'D' :
		builder.appendDayOfYear(tokenLen);
		break;
	case 'w' :
		builder.appendWeekOfWeekyear(tokenLen);
		break;
	case 'z' :
		if (tokenLen >= 4) {
			builder.appendTimeZoneName();
		} else {
			builder.appendTimeZoneShortName(null);
		}
		break;
	case 'Z' :
		if (tokenLen == 1) {
			builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
		} else { 			if (tokenLen == 2) {
				builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
			} else {
				builder.appendTimeZoneId();
			}}
		break;
	case '\'' :
		java.lang.String sub = token.substring(1);
		if (sub.length() == 1) {
			builder.appendLiteral(sub.charAt(0));
		} else {


			builder.appendLiteral(new java.lang.String(sub));
		}
		break;
	default :
		throw new java.lang.IllegalArgumentException(
		"Illegal pattern component: " + token);}:switch (c) {
	case 'G' :
		builder.appendEraText();
		break;
	case 'C' :
		builder.appendCenturyOfEra(tokenLen, tokenLen);
		break;
	case 'x' :
	case 'y' :
	case 'Y' :
		if (tokenLen == 2) {
			boolean $0 = true;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



					$0 = false;
				}
				indexRef[0]--;
			}


			switch (c) {
				case 'x' :
					builder.appendTwoDigitWeekyear(
					new org.joda.time.DateTime().getWeekyear() - 30, $0);
					break;
				case 'y' :
				case 'Y' :
				default :
					builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, $0);
					break;}

		} else {

			int $1 = 9;


			if ((i + 1) < length) {
				indexRef[0]++;
				if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

					$1 = tokenLen;
				}
				indexRef[0]--;
			}

			switch (c) {
				case 'x' :
					builder.appendWeekyear(tokenLen, $1);
					break;
				case 'y' :
					builder.appendYear(tokenLen, $1);
					break;
				case 'Y' :
					builder.appendYearOfEra(tokenLen, $1);
					break;}

		}
		break;
	case 'M' :
		if (tokenLen >= 3) {
			if (tokenLen >= 4) {
				builder.appendMonthOfYearText();
			} else {
				builder.appendMonthOfYearShortText();
			}
		} else {
			builder.appendMonthOfYear(tokenLen);
		}
		break;
	case 'd' :
		builder.appendDayOfMonth(tokenLen);
		break;
	case 'a' :
		builder.appendHalfdayOfDayText();
		break;
	case 'h' :
		builder.appendClockhourOfHalfday(tokenLen);
		break;
	case 'H' :
		builder.appendHourOfDay(tokenLen);
		break;
	case 'k' :
		builder.appendClockhourOfDay(tokenLen);
		break;
	case 'K' :
		builder.appendHourOfHalfday(tokenLen);
		break;
	case 'm' :
		builder.appendMinuteOfHour(tokenLen);
		break;
	case 's' :
		builder.appendSecondOfMinute(tokenLen);
		break;
	case 'S' :
		builder.appendFractionOfSecond(tokenLen, tokenLen);
		break;
	case 'e' :
		builder.appendDayOfWeek(tokenLen);
		break;
	case 'E' :
		if (tokenLen >= 4) {
			builder.appendDayOfWeekText();
		} else {
			builder.appendDayOfWeekShortText();
		}
		break;
	case 'D' :
		builder.appendDayOfYear(tokenLen);
		break;
	case 'w' :
		builder.appendWeekOfWeekyear(tokenLen);
		break;
	case 'z' :
		if (tokenLen >= 4) {
			builder.appendTimeZoneName();
		} else {
			builder.appendTimeZoneShortName(null);
		}
		break;
	case 'Z' :
		if (tokenLen == 1) {
			builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
		} else { 			if (tokenLen == 2) {
				builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
			} else {
				builder.appendTimeZoneId();
			}}
		break;
	case '\'' :
		java.lang.String $2 = token.substring(1);
		if ($2.length() == 1) {
			builder.appendLiteral($2.charAt(0));
		} else {


			builder.appendLiteral(new java.lang.String($2));
		}
		break;
	default :
		throw new java.lang.IllegalArgumentException(
		"Illegal pattern component: " + token);}
out.writeInt(size):out.writeInt(size)
map.put("ART", "Africa/Cairo"):map.put("ART", "Africa/Cairo")
org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder():org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder()
int offset = org.joda.time.DateTimeZone.parseOffset(convId):int $0 = org.joda.time.DateTimeZone.parseOffset(convId)
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.NONE):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.LONG, org.joda.time.format.DateTimeFormat.NONE)
org.joda.time.format.DateTimeFormat.StyleFormatter llf = new org.joda.time.format.DateTimeFormat.StyleFormatter(dateStyle, timeStyle, type):org.joda.time.format.DateTimeFormat.StyleFormatter $0 = new org.joda.time.format.DateTimeFormat.StyleFormatter(dateStyle, timeStyle, type)
for (int i = 0; i < poolSize; i++) {
	pool[i] = in.readUTF();
}:for (int $0 = 0; $0 < poolSize; $0++) {
	pool[$0] = in.readUTF();
}
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.LONG):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.LONG)
nameKeys[i] = (curNameKey + "-Summer").intern():nameKeys[i] = (curNameKey + "-Summer").intern()
zone = new org.joda.time.tz.FixedDateTimeZone(id, null, offset, offset):zone = new org.joda.time.tz.FixedDateTimeZone(id, null, offset, offset)
return iTailZone.getStandardOffset(instant):return iTailZone.getStandardOffset(instant)
indexRef[0]++:indexRef[0]++
if (offsetLocalFromOriginal == offsetOriginal) {
	return instantUTC;
}:if (offsetLocalFromOriginal == offsetOriginal) {
	return instantUTC;
}
int poolSize = poolSet.size():int $0 = poolSet.size()
if ((hoursOffset > 0) && (minutesOffset < 0)) {
	throw new java.lang.IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset);
}:if ((hoursOffset > 0) && (minutesOffset < 0)) {
	throw new java.lang.IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset);
}
if (tokenLen == 0) {
	break;
}:if (tokenLen == 0) {
	break;
}
offset = offsetLocal:offset = offsetLocal
return getID():return getID()
map.put("PNT", "America/Phoenix"):map.put("PNT", "America/Phoenix")
buf.append('+'):buf.append('+')
return appendShortText(org.joda.time.DateTimeFieldType.dayOfWeek()):return appendShortText(org.joda.time.DateTimeFieldType.dayOfWeek())
org.joda.time.DateTimeZone.cZoneIdConversion = map:org.joda.time.DateTimeZone.cZoneIdConversion = map
if (setEn[2].equals(setEn[4])) {
	byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
} else {
	byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
}:if (setEn[2].equals(setEn[4])) {
	byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
} else {
	byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
}
if (strict) {

	throw new org.joda.time.IllegalInstantException(instantLocal, getID());
} else {



	offset = offsetLocal;
}:if (strict) {

	throw new org.joda.time.IllegalInstantException(instantLocal, getID());
} else {



	offset = offsetLocal;
}
long nextOffset = wallOffsets[i + 1]:long $0 = wallOffsets[i + 1]
org.joda.time.format.DateTimeFormatter formatter = org.joda.time.format.DateTimeFormat.createFormatterForStyle(style):org.joda.time.format.DateTimeFormatter $0 = org.joda.time.format.DateTimeFormat.createFormatterForStyle(style)
if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

		maxDigits = tokenLen;
	}
	indexRef[0]--;
}:if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

		maxDigits = tokenLen;
	}
	indexRef[0]--;
}
org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone other = ((org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone) (obj)):org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone $0 = ((org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone) (obj))
org.joda.time.format.DateTimeFormatter formatter = null:org.joda.time.format.DateTimeFormatter $0 = null
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.SHORT):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.SHORT)
org.joda.time.DateTimeZone zone = org.joda.time.DateTimeZone.cDefault:org.joda.time.DateTimeZone $0 = org.joda.time.DateTimeZone.cDefault
throw new java.lang.ArithmeticException("Adding time zone offset caused overflow"):throw new java.lang.ArithmeticException("Adding time zone offset caused overflow")
return offsetLocal:return offsetLocal
java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
tailZone.iStartRecurrence.getNameKey()):java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
tailZone.iStartRecurrence.getNameKey())
return org.joda.time.DateTimeZone.cNameProvider:return org.joda.time.DateTimeZone.cNameProvider
return iNameKeys[i - 1]:return iNameKeys[i - 1]
org.joda.time.DateTimeZone temp = null:org.joda.time.DateTimeZone $0 = null
if (f == null) {
	f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
	org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
}:if (f == null) {
	f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
	org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
}
map.put("MET", "CET"):map.put("MET", "CET")
return transitions[i]:return transitions[i]
return append0(printer, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(copyOfParsers)):return append0(printer, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(copyOfParsers))
for (int i = 0; i < size; i++) {
	org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iTransitions[i]);
	org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iWallOffsets[i]);
	org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iStandardOffsets[i]);


	java.lang.String nameKey = iNameKeys[i];
	for (int j = 0; j < poolSize; j++) {
		if (pool[j].equals(nameKey)) {
			if (poolSize < 256) {
				out.writeByte(j);
			} else {
				out.writeShort(j);
			}
			break;
		}
	}
}:for (int $0 = 0; $0 < size; $0++) {
	org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iTransitions[$0]);
	org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iWallOffsets[$0]);
	org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iStandardOffsets[$0]);


	java.lang.String $1 = iNameKeys[$0];
	for (int $2 = 0; $2 < poolSize; $2++) {
		if (pool[$2].equals($1)) {
			if (poolSize < 256) {
				out.writeByte($2);
			} else {
				out.writeShort($2);
			}
			break;
		}
	}
}
if (offset == 0) {
	return org.joda.time.DateTimeZone.UTC;
}:if (offset == 0) {
	return org.joda.time.DateTimeZone.UTC;
}
return org.joda.time.DateTimeZone.fixedOffsetZone(id, offset):return org.joda.time.DateTimeZone.fixedOffsetZone(id, offset)
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(iOfYear, nameKey, iSaveMillis)
return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfHour(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfHour(), minDigits, 2)
if (tokenLen >= 4) {
	builder.appendMonthOfYearText();
} else {
	builder.appendMonthOfYearShortText();
}:if (tokenLen >= 4) {
	builder.appendMonthOfYearText();
} else {
	builder.appendMonthOfYearShortText();
}
builder.appendTimeZoneOffset(null, "Z", true, 2, 2):builder.appendTimeZoneOffset(null, "Z", true, 2, 2)
return appendSignedDecimal(org.joda.time.DateTimeFieldType.centuryOfEra(), minDigits, maxDigits):return appendSignedDecimal(org.joda.time.DateTimeFieldType.centuryOfEra(), minDigits, maxDigits)
int offset = getOffset(instantUTC):int $0 = getOffset(instantUTC)
if (poolSize > 65535) {
	throw new java.lang.UnsupportedOperationException("String pool is too large");
}:if (poolSize > 65535) {
	throw new java.lang.UnsupportedOperationException("String pool is too large");
}
long prev = previousTransition(instantAdjusted):long $0 = previousTransition(instantAdjusted)
return append0(null, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(parsers)):return append0(null, new org.joda.time.format.DateTimeFormatterBuilder.MatchingParser(parsers))
long diff = transitions[i] - transitions[i - 1]:long $0 = transitions[i] - transitions[i - 1]
builder.appendMonthOfYearText():builder.appendMonthOfYearText()
if (offset == 0L) {
	return org.joda.time.DateTimeZone.UTC;
} else {
	convId = org.joda.time.DateTimeZone.printOffset(offset);
	return org.joda.time.DateTimeZone.fixedOffsetZone(convId, offset);
}:if (offset == 0L) {
	return org.joda.time.DateTimeZone.UTC;
} else {
	convId = org.joda.time.DateTimeZone.printOffset(offset);
	return org.joda.time.DateTimeZone.fixedOffsetZone(convId, offset);
}
if (offset == 0) {
	return buf.toString();
}:if (offset == 0) {
	return buf.toString();
}
return appendDecimal(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, 2)
synchronized(org.joda.time.format.DateTimeFormat.PATTERN_CACHE) {
	formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern);
	if (formatter == null) {
		org.joda.time.format.DateTimeFormatterBuilder builder = new org.joda.time.format.DateTimeFormatterBuilder();
		org.joda.time.format.DateTimeFormat.parsePatternTo(builder, pattern);
		formatter = builder.toFormatter();

		org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
	}
}:synchronized(org.joda.time.format.DateTimeFormat.PATTERN_CACHE) {
	formatter = org.joda.time.format.DateTimeFormat.PATTERN_CACHE.get(pattern);
	if (formatter == null) {
		org.joda.time.format.DateTimeFormatterBuilder $0 = new org.joda.time.format.DateTimeFormatterBuilder();
		org.joda.time.format.DateTimeFormat.parsePatternTo($0, pattern);
		formatter = $0.toFormatter();

		org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter);
	}
}
org.joda.time.Chronology chrono = new org.joda.time.chrono.BaseChronology() {
	private static final long serialVersionUID = -3128740902654445468L;
	public org.joda.time.DateTimeZone getZone() {
		return null;
	}
	public org.joda.time.Chronology withUTC() {
		return this;
	}
	public org.joda.time.Chronology withZone(org.joda.time.DateTimeZone zone) {
		return this;
	}
	public java.lang.String toString() {
		return getClass().getName();
	}
}:org.joda.time.Chronology $0 = new org.joda.time.chrono.BaseChronology() {
	private static final long serialVersionUID = -3128740902654445468L;
	public org.joda.time.DateTimeZone getZone() {
		return null;
	}
	public org.joda.time.Chronology withUTC() {
		return this;
	}
	public org.joda.time.Chronology withZone(org.joda.time.DateTimeZone zone) {
		return this;
	}
	public java.lang.String toString() {
		return getClass().getName();
	}
}
if (nextLocal != nextAdjusted) {

	if (strict) {

		throw new org.joda.time.IllegalInstantException(instantLocal, getID());
	} else {



		offset = offsetLocal;
	}
}:if (nextLocal != nextAdjusted) {

	if (strict) {

		throw new org.joda.time.IllegalInstantException(instantLocal, getID());
	} else {



		offset = offsetLocal;
	}
}
return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfDay(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfDay(), minDigits, 2)
if (nextLocal == (instantLocal - offsetLocal)) {
	nextLocal = java.lang.Long.MAX_VALUE;
}:if (nextLocal == (instantLocal - offsetLocal)) {
	nextLocal = java.lang.Long.MAX_VALUE;
}
return appendText(org.joda.time.DateTimeFieldType.era()):return appendText(org.joda.time.DateTimeFieldType.era())
java.lang.String token = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef):java.lang.String $0 = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef)
map.put("BET", "America/Sao_Paulo"):map.put("BET", "America/Sao_Paulo")
if (nameProvider == null) {
	nameProvider = new org.joda.time.tz.DefaultNameProvider();
}:if (nameProvider == null) {
	nameProvider = new org.joda.time.tz.DefaultNameProvider();
}
return newZone.convertLocalToUTC(instantLocal, false, oldInstant):return newZone.convertLocalToUTC(instantLocal, false, oldInstant)
map.put("AET", "Australia/Sydney"):map.put("AET", "Australia/Sydney")
return getName(instant, null):return getName(instant, null)
offset = -offset:offset = -offset
for (int i = 0; i < poolSize; i++) {
	out.writeUTF(pool[i]);
}:for (int $0 = 0; $0 < poolSize; $0++) {
	out.writeUTF(pool[$0]);
}
org.joda.time.tz.NameProvider nameProvider = null:org.joda.time.tz.NameProvider $0 = null
if (prev < instantAdjusted) {
	int offsetPrev = getOffset(prev);
	int diff = offsetPrev - offsetLocal;
	if ((instantAdjusted - prev) <= diff) {
		return offsetPrev;
	}
}:if (prev < instantAdjusted) {
	int $0 = getOffset(prev);
	int $1 = $0 - offsetLocal;
	if ((instantAdjusted - prev) <= $1) {
		return $0;
	}
}
offset = org.joda.time.field.FieldUtils.safeMultiply(minutesOffset, org.joda.time.DateTimeConstants.MILLIS_PER_MINUTE):offset = org.joda.time.field.FieldUtils.safeMultiply(minutesOffset, org.joda.time.DateTimeConstants.MILLIS_PER_MINUTE)
convId = convId.substring(3):convId = convId.substring(3)
if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



		lenientParse = false;
	}
	indexRef[0]--;
}:if ((i + 1) < length) {
	indexRef[0]++;
	if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



		lenientParse = false;
	}
	indexRef[0]--;
}
long afterStart = instant - overlapStart:long $0 = instant - overlapStart
if (curOffset < nextOffset) {
	nameKeys[i + 1] = (nextNameKey + "-Summer").intern();
	i++;
}:if (curOffset < nextOffset) {
	nameKeys[i + 1] = (nextNameKey + "-Summer").intern();
	i++;
}
return appendFraction(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.secondOfDay(), minDigits, maxDigits)
int[] wallOffsets = new int[size]:int[] $0 = new int[size]
org.joda.time.format.FormatUtils.appendPaddedInteger(buf, offset, 3):org.joda.time.format.FormatUtils.appendPaddedInteger(buf, offset, 3)
iNameKeys = nameKeys:iNameKeys = nameKeys
long instantLocal = instantUTC + offset:long $0 = instantUTC + offset
int maxDigits = 9:int $0 = 9
return appendText(org.joda.time.DateTimeFieldType.dayOfWeek()):return appendText(org.joda.time.DateTimeFieldType.dayOfWeek())
if (((instantUTC ^ instantLocal) < 0) && ((instantUTC ^ offset) >= 0)) {
	throw new java.lang.ArithmeticException("Adding time zone offset caused overflow");
}:if (((instantUTC ^ instantLocal) < 0) && ((instantUTC ^ offset) >= 0)) {
	throw new java.lang.ArithmeticException("Adding time zone offset caused overflow");
}
if (byIdCache == null) {
	iByLocaleCache.put(locale, byIdCache = createCache());
}:if (byIdCache == null) {
	iByLocaleCache.put(locale, byIdCache = createCache());
}
map.put("CAT", "Africa/Harare"):map.put("CAT", "Africa/Harare")
if (nextLocal != nextAdjusted) {
	return offsetLocal;
}:if (nextLocal != nextAdjusted) {
	return offsetLocal;
}
if (offsetLocal != offsetAdjusted) {


	if ((offsetLocal - offsetAdjusted) < 0) {



		long nextLocal = nextTransition(instantAdjusted);
		long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
		if (nextLocal != nextAdjusted) {
			return offsetLocal;
		}
	}
} else { 	if (offsetLocal >= 0) {
		long prev = previousTransition(instantAdjusted);
		if (prev < instantAdjusted) {
			int offsetPrev = getOffset(prev);
			int diff = offsetPrev - offsetLocal;
			if ((instantAdjusted - prev) <= diff) {
				return offsetPrev;
			}
		}
	}}:if (offsetLocal != offsetAdjusted) {


	if ((offsetLocal - offsetAdjusted) < 0) {



		long $0 = nextTransition(instantAdjusted);
		long $1 = nextTransition(instantLocal - offsetAdjusted);
		if ($0 != $1) {
			return offsetLocal;
		}
	}
} else { 	if (offsetLocal >= 0) {
		long $2 = previousTransition(instantAdjusted);
		if ($2 < instantAdjusted) {
			int $3 = getOffset($2);
			int $4 = $3 - offsetLocal;
			if ((instantAdjusted - $2) <= $4) {
				return $3;
			}
		}
	}}
index = in.readUnsignedShort():index = in.readUnsignedShort()
long nextLocal = nextTransition(instantAdjusted):long $0 = nextTransition(instantAdjusted)
iTransitions = transitions:iTransitions = transitions
return new org.joda.time.format.DateTimeFormatter(llf, llf):return new org.joda.time.format.DateTimeFormatter(llf, llf)
tailZone = org.joda.time.tz.DateTimeZoneBuilder.DSTZone.readFrom(in, id):tailZone = org.joda.time.tz.DateTimeZoneBuilder.DSTZone.readFrom(in, id)
map.put("NET", "Asia/Yerevan"):map.put("NET", "Asia/Yerevan")
if (provider == null) {
	provider = org.joda.time.DateTimeZone.getDefaultProvider();
}:if (provider == null) {
	provider = org.joda.time.DateTimeZone.getDefaultProvider();
}
instant = end:instant = end
int minutes = offset / org.joda.time.DateTimeConstants.MILLIS_PER_MINUTE:int $0 = offset / org.joda.time.DateTimeConstants.MILLIS_PER_MINUTE
sm.checkPermission(new org.joda.time.JodaTimePermission("DateTimeZone.setDefault")):sm.checkPermission(new org.joda.time.JodaTimePermission("DateTimeZone.setDefault"))
if (map == null) {

	map = new java.util.HashMap<java.lang.String, java.lang.String>();
	map.put("GMT", "UTC");
	map.put("WET", "WET");
	map.put("CET", "CET");
	map.put("MET", "CET");
	map.put("ECT", "CET");
	map.put("EET", "EET");
	map.put("MIT", "Pacific/Apia");
	map.put("HST", "Pacific/Honolulu");
	map.put("AST", "America/Anchorage");
	map.put("PST", "America/Los_Angeles");
	map.put("MST", "America/Denver");
	map.put("PNT", "America/Phoenix");
	map.put("CST", "America/Chicago");
	map.put("EST", "America/New_York");
	map.put("IET", "America/Indiana/Indianapolis");
	map.put("PRT", "America/Puerto_Rico");
	map.put("CNT", "America/St_Johns");
	map.put("AGT", "America/Argentina/Buenos_Aires");
	map.put("BET", "America/Sao_Paulo");
	map.put("ART", "Africa/Cairo");
	map.put("CAT", "Africa/Harare");
	map.put("EAT", "Africa/Addis_Ababa");
	map.put("NET", "Asia/Yerevan");
	map.put("PLT", "Asia/Karachi");
	map.put("IST", "Asia/Kolkata");
	map.put("BST", "Asia/Dhaka");
	map.put("VST", "Asia/Ho_Chi_Minh");
	map.put("CTT", "Asia/Shanghai");
	map.put("JST", "Asia/Tokyo");
	map.put("ACT", "Australia/Darwin");
	map.put("AET", "Australia/Sydney");
	map.put("SST", "Pacific/Guadalcanal");
	map.put("NST", "Pacific/Auckland");
	org.joda.time.DateTimeZone.cZoneIdConversion = map;
}:if (map == null) {

	map = new java.util.HashMap<java.lang.String, java.lang.String>();
	map.put("GMT", "UTC");
	map.put("WET", "WET");
	map.put("CET", "CET");
	map.put("MET", "CET");
	map.put("ECT", "CET");
	map.put("EET", "EET");
	map.put("MIT", "Pacific/Apia");
	map.put("HST", "Pacific/Honolulu");
	map.put("AST", "America/Anchorage");
	map.put("PST", "America/Los_Angeles");
	map.put("MST", "America/Denver");
	map.put("PNT", "America/Phoenix");
	map.put("CST", "America/Chicago");
	map.put("EST", "America/New_York");
	map.put("IET", "America/Indiana/Indianapolis");
	map.put("PRT", "America/Puerto_Rico");
	map.put("CNT", "America/St_Johns");
	map.put("AGT", "America/Argentina/Buenos_Aires");
	map.put("BET", "America/Sao_Paulo");
	map.put("ART", "Africa/Cairo");
	map.put("CAT", "Africa/Harare");
	map.put("EAT", "Africa/Addis_Ababa");
	map.put("NET", "Asia/Yerevan");
	map.put("PLT", "Asia/Karachi");
	map.put("IST", "Asia/Kolkata");
	map.put("BST", "Asia/Dhaka");
	map.put("VST", "Asia/Ho_Chi_Minh");
	map.put("CTT", "Asia/Shanghai");
	map.put("JST", "Asia/Tokyo");
	map.put("ACT", "Australia/Darwin");
	map.put("AET", "Australia/Sydney");
	map.put("SST", "Pacific/Guadalcanal");
	map.put("NST", "Pacific/Auckland");
	org.joda.time.DateTimeZone.cZoneIdConversion = map;
}
return append0(printer, null):return append0(printer, null)
if (iTailZone != null) {
	iTailZone.writeTo(out);
}:if (iTailZone != null) {
	iTailZone.writeTo(out);
}
avg /= ((24 * 60) * 60) * 1000:avg /= ((24 * 60) * 60) * 1000
if (afterStart >= diff) {

	return earlierOrLater ? instant : instant - diff;
} else {

	return earlierOrLater ? instant + diff : instant;
}:if (afterStart >= diff) {

	return earlierOrLater ? instant : instant - diff;
} else {

	return earlierOrLater ? instant + diff : instant;
}
tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
tailZone.getID(), 
tailZone.iStandardOffset, 
tailZone.iStartRecurrence.renameAppend("-Summer"), 
tailZone.iEndRecurrence):tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
tailZone.getID(), 
tailZone.iStandardOffset, 
tailZone.iStartRecurrence.renameAppend("-Summer"), 
tailZone.iEndRecurrence)
return convertLocalToUTC(instantLocal, strict):return convertLocalToUTC(instantLocal, strict)
synchronized(org.joda.time.DateTimeZone.class) {
	zone = org.joda.time.DateTimeZone.cDefault;
	if (zone == null) {
		org.joda.time.DateTimeZone temp = null;
		try {
			try {
				java.lang.String id = java.lang.System.getProperty("user.timezone");
				if (id != null) {
					temp = org.joda.time.DateTimeZone.forID(id);
				}
			} catch (java.lang.RuntimeException ex) {

			}
			if (temp == null) {
				temp = org.joda.time.DateTimeZone.forTimeZone(java.util.TimeZone.getDefault());
			}
		} catch (java.lang.IllegalArgumentException ex) {

		}
		if (temp == null) {
			temp = org.joda.time.DateTimeZone.UTC;
		}
		org.joda.time.DateTimeZone.cDefault = zone = temp;
	}
}:synchronized(org.joda.time.DateTimeZone.class) {
	zone = org.joda.time.DateTimeZone.cDefault;
	if (zone == null) {
		org.joda.time.DateTimeZone $0 = null;
		try {
			try {
				java.lang.String $1 = java.lang.System.getProperty("user.timezone");
				if ($1 != null) {
					$0 = org.joda.time.DateTimeZone.forID($1);
				}
			} catch (java.lang.RuntimeException ex) {

			}
			if ($0 == null) {
				$0 = org.joda.time.DateTimeZone.forTimeZone(java.util.TimeZone.getDefault());
			}
		} catch (java.lang.IllegalArgumentException ex) {

		}
		if ($0 == null) {
			$0 = org.joda.time.DateTimeZone.UTC;
		}
		org.joda.time.DateTimeZone.cDefault = zone = $0;
	}
}
return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isParser():return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isParser()
int size = iTransitions.length:int $0 = iTransitions.length
if (name != null) {
	return name;
}:if (name != null) {
	return name;
}
org.joda.time.DateTimeZone.cProvider = provider:org.joda.time.DateTimeZone.cProvider = provider
int i = java.util.Arrays.binarySearch(transitions, instant):int $0 = java.util.Arrays.binarySearch(transitions, instant)
builder.appendTimeZoneShortName(null):builder.appendTimeZoneShortName(null)
return append0(null, parser):return append0(null, parser)
org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter):org.joda.time.format.DateTimeFormat.PATTERN_CACHE.put(pattern, formatter)
map.put("CST", "America/Chicago"):map.put("CST", "America/Chicago")
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields))
throw new java.io.IOException("Invalid encoding"):throw new java.io.IOException("Invalid encoding")
return -((int) (org.joda.time.DateTimeZone.offsetFormatter().withChronology(chrono).parseMillis(str))):return -((int) (org.joda.time.DateTimeZone.offsetFormatter().withChronology(chrono).parseMillis(str)))
org.joda.time.DateTimeZone.setProvider0(provider):org.joda.time.DateTimeZone.setProvider0(provider)
builder.appendTimeZoneName():builder.appendTimeZoneName()
java.lang.String providerClass = java.lang.System.getProperty("org.joda.time.DateTimeZone.Provider"):java.lang.String $0 = java.lang.System.getProperty("org.joda.time.DateTimeZone.Provider")
if (id.equals("UTC")) {
	return org.joda.time.DateTimeZone.UTC;
}:if (id.equals("UTC")) {
	return org.joda.time.DateTimeZone.UTC;
}
int size = in.readInt():int $0 = in.readInt()
switch (ch) {
	case 'S' :
		return org.joda.time.format.DateTimeFormat.SHORT;
	case 'M' :
		return org.joda.time.format.DateTimeFormat.MEDIUM;
	case 'L' :
		return org.joda.time.format.DateTimeFormat.LONG;
	case 'F' :
		return org.joda.time.format.DateTimeFormat.FULL;
	case '-' :
		return org.joda.time.format.DateTimeFormat.NONE;
	default :
		throw new java.lang.IllegalArgumentException("Invalid style character: " + ch);}:switch (ch) {
	case 'S' :
		return org.joda.time.format.DateTimeFormat.SHORT;
	case 'M' :
		return org.joda.time.format.DateTimeFormat.MEDIUM;
	case 'L' :
		return org.joda.time.format.DateTimeFormat.LONG;
	case 'F' :
		return org.joda.time.format.DateTimeFormat.FULL;
	case '-' :
		return org.joda.time.format.DateTimeFormat.NONE;
	default :
		throw new java.lang.IllegalArgumentException("Invalid style character: " + ch);}
java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[i], chrono)) + 
" - ") + new org.joda.time.DateTime(trans[i + 1], chrono)):java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[i], chrono)) + 
" - ") + new org.joda.time.DateTime(trans[i + 1], chrono))
return iTailZone.getOffset(instant):return iTailZone.getOffset(instant)
double avg = distances / count:double $0 = distances / count
return org.joda.time.DateTimeZone.cOffsetFormatter:return org.joda.time.DateTimeZone.cOffsetFormatter
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(dateStyle, timeStyle):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(dateStyle, timeStyle)
poolSet.add(iNameKeys[i]):poolSet.add(iNameKeys[i])
map.put("CTT", "Asia/Shanghai"):map.put("CTT", "Asia/Shanghai")
org.joda.time.DateTimeZone.cDefault = zone = temp:org.joda.time.DateTimeZone.cDefault = zone = temp
if ((instant < overlapStart) || (instant >= overlapEnd)) {
	return instant;
}:if ((instant < overlapStart) || (instant >= overlapEnd)) {
	return instant;
}
trans[i] = tr.getMillis():trans[i] = tr.getMillis()
zone = org.joda.time.DateTimeZone.cDefault:zone = org.joda.time.DateTimeZone.cDefault
org.joda.time.format.FormatUtils.appendPaddedInteger(buf, minutes, 2):org.joda.time.format.FormatUtils.appendPaddedInteger(buf, minutes, 2)
if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

	i++;
	buf.append(c);
} else {
	inLiteral = !inLiteral;
}:if (((i + 1) < length) && (pattern.charAt(i + 1) == '\'')) {

	i++;
	buf.append(c);
} else {
	inLiteral = !inLiteral;
}
for (int i = 0; i < size; i++) {
	transitions[i] = org.joda.time.tz.DateTimeZoneBuilder.readMillis(in);
	wallOffsets[i] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)));
	standardOffsets[i] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)));
	try {
		int index;
		if (poolSize < 256) {
			index = in.readUnsignedByte();
		} else {
			index = in.readUnsignedShort();
		}
		nameKeys[i] = pool[index];
	} catch (java.lang.ArrayIndexOutOfBoundsException e) {
		throw new java.io.IOException("Invalid encoding");
	}
}:for (int $0 = 0; $0 < size; $0++) {
	transitions[$0] = org.joda.time.tz.DateTimeZoneBuilder.readMillis(in);
	wallOffsets[$0] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)));
	standardOffsets[$0] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)));
	try {
		int $1;
		if (poolSize < 256) {
			$1 = in.readUnsignedByte();
		} else {
			$1 = in.readUnsignedShort();
		}
		nameKeys[$0] = pool[$1];
	} catch (java.lang.ArrayIndexOutOfBoundsException e) {
		throw new java.io.IOException("Invalid encoding");
	}
}
java.lang.String id = java.lang.System.getProperty("user.timezone"):java.lang.String $0 = java.lang.System.getProperty("user.timezone")
int offset = 0:int $0 = 0
f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index]:f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index]
map.put("IET", "America/Indiana/Indianapolis"):map.put("IET", "America/Indiana/Indianapolis")
return append0(printer, parsers[0]):return append0(printer, parsers[0])
org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iStandardOffsets[i]):org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iStandardOffsets[i])
return org.joda.time.DateTimeZone.fixedOffsetZone(id, millisOffset):return org.joda.time.DateTimeZone.fixedOffsetZone(id, millisOffset)
return org.joda.time.DateTimeZone.forOffsetHoursMinutes(hoursOffset, 0):return org.joda.time.DateTimeZone.forOffsetHoursMinutes(hoursOffset, 0)
long diff = offsetBefore - offsetAfter:long $0 = offsetBefore - offsetAfter
i = ~i:i = ~i
return earlierOrLater ? instant : instant - diff:return earlierOrLater ? instant : instant - diff
if (byNameKeyCache == null) {
	byIdCache.put(id, byNameKeyCache = createCache());

	java.lang.String[][] zoneStringsEn = org.joda.time.DateTimeUtils.getDateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings();
	java.lang.String[] setEn = null;
	for (java.lang.String[] strings : zoneStringsEn) {
		if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
			setEn = strings;
			break;
		}
	}
	java.lang.String[][] zoneStringsLoc = org.joda.time.DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
	java.lang.String[] setLoc = null;
	for (java.lang.String[] strings : zoneStringsLoc) {
		if (((strings != null) && (strings.length == 5)) && id.equals(strings[0])) {
			setLoc = strings;
			break;
		}
	}

	if ((setEn != null) && (setLoc != null)) {
		byNameKeyCache.put(setEn[2], new java.lang.String[]{ setLoc[2], setLoc[1] });



		if (setEn[2].equals(setEn[4])) {
			byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
		} else {
			byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
		}
	}
}:if (byNameKeyCache == null) {
	byIdCache.put(id, byNameKeyCache = createCache());

	java.lang.String[][] $0 = org.joda.time.DateTimeUtils.getDateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings();
	java.lang.String[] $1 = null;
	for (java.lang.String[] $2 : $0) {
		if ((($2 != null) && ($2.length == 5)) && id.equals($2[0])) {
			$1 = $2;
			break;
		}
	}
	java.lang.String[][] $3 = org.joda.time.DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
	java.lang.String[] $4 = null;
	for (java.lang.String[] $5 : $3) {
		if ((($5 != null) && ($5.length == 5)) && id.equals($5[0])) {
			$4 = $5;
			break;
		}
	}

	if (($1 != null) && ($4 != null)) {
		byNameKeyCache.put($1[2], new java.lang.String[]{ $4[2], $4[1] });



		if ($1[2].equals($1[4])) {
			byNameKeyCache.put($1[4] + "-Summer", new java.lang.String[]{ $4[4], $4[3] });
		} else {
			byNameKeyCache.put($1[4], new java.lang.String[]{ $4[4], $4[3] });
		}
	}
}
if (i < transitions.length) {
	if (i > 0) {
		return iNameKeys[i - 1];
	}
	return "UTC";
}:if (i < transitions.length) {
	if (i > 0) {
		return iNameKeys[i - 1];
	}
	return "UTC";
}
return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, false))
standardOffsets[i] = tr.getStandardOffset():standardOffsets[i] = tr.getStandardOffset()
builder.appendTimeZoneId():builder.appendTimeZoneId()
if (id == null) {
	return org.joda.time.DateTimeZone.getDefault();
}:if (id == null) {
	return org.joda.time.DateTimeZone.getDefault();
}
if (temp == null) {
	temp = org.joda.time.DateTimeZone.UTC;
}:if (temp == null) {
	temp = org.joda.time.DateTimeZone.UTC;
}
inLiteral = !inLiteral:inLiteral = !inLiteral
map.put("JST", "Asia/Tokyo"):map.put("JST", "Asia/Tokyo")
org.joda.time.format.DateTimeFormatter f = null:org.joda.time.format.DateTimeFormatter $0 = null
map.put("ACT", "Australia/Darwin"):map.put("ACT", "Australia/Darwin")
int index:int $0
map.put("NST", "Pacific/Auckland"):map.put("NST", "Pacific/Auckland")
org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iTransitions[i]):org.joda.time.tz.DateTimeZoneBuilder.writeMillis(out, iTransitions[i])
if (convId != null) {
	dtz = org.joda.time.DateTimeZone.cProvider.getZone(convId);
}:if (convId != null) {
	dtz = org.joda.time.DateTimeZone.cProvider.getZone(convId);
}
if (offset >= 0) {
	buf.append('+');
} else {
	buf.append('-');
	offset = -offset;
}:if (offset >= 0) {
	buf.append('+');
} else {
	buf.append('-');
	offset = -offset;
}
double distances = 0:double $0 = 0
int tokenLen = token.length():int $0 = token.length()
synchronized(org.joda.time.format.DateTimeFormat.STYLE_CACHE) {
	f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index];
	if (f == null) {
		f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
		org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
	}
}:synchronized(org.joda.time.format.DateTimeFormat.STYLE_CACHE) {
	f = org.joda.time.format.DateTimeFormat.STYLE_CACHE[index];
	if (f == null) {
		f = org.joda.time.format.DateTimeFormat.createDateTimeFormatter(dateStyle, timeStyle);
		org.joda.time.format.DateTimeFormat.STYLE_CACHE[index] = f;
	}
}
for (int i = 1; i < transitions.length; i++) {
	long diff = transitions[i] - transitions[i - 1];
	if (diff < (((((366L + 365) * 24) * 60) * 60) * 1000)) {
		distances += ((double) (diff));
		count++;
	}
}:for (int $0 = 1; $0 < transitions.length; $0++) {
	long $1 = transitions[$0] - transitions[$0 - 1];
	if ($1 < (((((366L + 365) * 24) * 60) * 60) * 1000)) {
		distances += ((double) ($1));
		count++;
	}
}
return "UTC":return "UTC"
return iNameKey:return iNameKey
return appendFraction(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.dayOfYear(), minDigits, maxDigits)
long offsetBefore = getOffset(instantBefore):long $0 = getOffset(instantBefore)
sm.checkPermission(new org.joda.time.JodaTimePermission("DateTimeZone.setNameProvider")):sm.checkPermission(new org.joda.time.JodaTimePermission("DateTimeZone.setNameProvider"))
java.lang.String nextNameKey = nameKeys[i + 1]:java.lang.String $0 = nameKeys[i + 1]
if ((offsetLocal - offsetAdjusted) < 0) {



	long nextLocal = nextTransition(instantAdjusted);
	long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
	if (nextLocal != nextAdjusted) {
		return offsetLocal;
	}
}:if ((offsetLocal - offsetAdjusted) < 0) {



	long $0 = nextTransition(instantAdjusted);
	long $1 = nextTransition(instantLocal - offsetAdjusted);
	if ($0 != $1) {
		return offsetLocal;
	}
}
map.put("MST", "America/Denver"):map.put("MST", "America/Denver")
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TextField(fieldType, false))
if ((!inLiteral) && 
(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
	i--;
	break;
} else {
	buf.append(c);
}:if ((!inLiteral) && 
(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')))) {
	i--;
	break;
} else {
	buf.append(c);
}
sm.checkPermission(new org.joda.time.JodaTimePermission("DateTimeZone.setProvider")):sm.checkPermission(new org.joda.time.JodaTimePermission("DateTimeZone.setProvider"))
int dateStyle = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(0)):int $0 = org.joda.time.format.DateTimeFormat.selectStyle(style.charAt(0))
for (int j = 0; j < zoneStrings.length; j++) {
	java.lang.String[] set = zoneStrings[j];
	if (((set != null) && (set.length == 5)) && id.equals(set[0])) {
		zoneNameData = set;
	}
}:for (int $0 = 0; $0 < zoneStrings.length; $0++) {
	java.lang.String[] $1 = zoneStrings[$0];
	if ((($1 != null) && ($1.length == 5)) && id.equals($1[0])) {
		zoneNameData = $1;
	}
}
map.put("GMT", "UTC"):map.put("GMT", "UTC")
int poolSize = in.readUnsignedShort():int $0 = in.readUnsignedShort()
standardOffsets[i] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in))):standardOffsets[i] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)))
if (sm != null) {
	sm.checkPermission(new org.joda.time.JodaTimePermission("DateTimeZone.setNameProvider"));
}:if (sm != null) {
	sm.checkPermission(new org.joda.time.JodaTimePermission("DateTimeZone.setNameProvider"));
}
return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)))):return new org.joda.time.tz.DateTimeZoneBuilder.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(in), in.readUTF(), ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in))))
switch (c) {
	case 'x' :
		builder.appendTwoDigitWeekyear(
		new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
		break;
	case 'y' :
	case 'Y' :
	default :
		builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
		break;}:switch (c) {
	case 'x' :
		builder.appendTwoDigitWeekyear(
		new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
		break;
	case 'y' :
	case 'Y' :
	default :
		builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
		break;}
java.lang.ref.Reference<org.joda.time.DateTimeZone> ref = org.joda.time.DateTimeZone.iFixedOffsetCache.get(id):java.lang.ref.Reference<org.joda.time.DateTimeZone> $0 = org.joda.time.DateTimeZone.iFixedOffsetCache.get(id)
map.put("PST", "America/Los_Angeles"):map.put("PST", "America/Los_Angeles")
return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isPrinter():return ((org.joda.time.format.DateTimeFormatterBuilder.Composite) (f)).isPrinter()
return iWallOffsets[i]:return iWallOffsets[i]
return org.joda.time.DateTimeZone.UTC:return org.joda.time.DateTimeZone.UTC
return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfHalfday(), minDigits, 2):return appendDecimal(org.joda.time.DateTimeFieldType.clockhourOfHalfday(), minDigits, 2)
int offsetPrev = getOffset(prev):int $0 = getOffset(prev)
if (size == 0) {
	throw new java.lang.IllegalArgumentException();
}:if (size == 0) {
	throw new java.lang.IllegalArgumentException();
}
map.put("IST", "Asia/Kolkata"):map.put("IST", "Asia/Kolkata")
if ((setEn != null) && (setLoc != null)) {
	byNameKeyCache.put(setEn[2], new java.lang.String[]{ setLoc[2], setLoc[1] });



	if (setEn[2].equals(setEn[4])) {
		byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
	} else {
		byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
	}
}:if ((setEn != null) && (setLoc != null)) {
	byNameKeyCache.put(setEn[2], new java.lang.String[]{ setLoc[2], setLoc[1] });



	if (setEn[2].equals(setEn[4])) {
		byNameKeyCache.put(setEn[4] + "-Summer", new java.lang.String[]{ setLoc[4], setLoc[3] });
	} else {
		byNameKeyCache.put(setEn[4], new java.lang.String[]{ setLoc[4], setLoc[3] });
	}
}
return appendDecimal(org.joda.time.DateTimeFieldType.millisOfDay(), minDigits, 8):return appendDecimal(org.joda.time.DateTimeFieldType.millisOfDay(), minDigits, 8)
if (count > 0) {
	double avg = distances / count;
	avg /= ((24 * 60) * 60) * 1000;
	if (avg >= 25) {






		return true;
	}
}:if (count > 0) {
	double $0 = distances / count;
	$0 /= ((24 * 60) * 60) * 1000;
	if ($0 >= 25) {






		return true;
	}
}
throw new java.lang.IllegalArgumentException("The datetime zone must not be null"):throw new java.lang.IllegalArgumentException("The datetime zone must not be null")
if (ref != null) {
	zone = ref.get();
	if (zone != null) {
		return zone;
	}
}:if (ref != null) {
	zone = ref.get();
	if (zone != null) {
		return zone;
	}
}
if (tailZone.iStartRecurrence.getNameKey().equals(
tailZone.iEndRecurrence.getNameKey())) {
	if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
		java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
		tailZone.iStartRecurrence.getNameKey());
	}
	if (tailZone.iStartRecurrence.getSaveMillis() > 0) {
		tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
		tailZone.getID(), 
		tailZone.iStandardOffset, 
		tailZone.iStartRecurrence.renameAppend("-Summer"), 
		tailZone.iEndRecurrence);
	} else {
		tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
		tailZone.getID(), 
		tailZone.iStandardOffset, 
		tailZone.iStartRecurrence, 
		tailZone.iEndRecurrence.renameAppend("-Summer"));
	}
}:if (tailZone.iStartRecurrence.getNameKey().equals(
tailZone.iEndRecurrence.getNameKey())) {
	if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
		java.lang.System.out.println("Fixing duplicate recurrent name key - " + 
		tailZone.iStartRecurrence.getNameKey());
	}
	if (tailZone.iStartRecurrence.getSaveMillis() > 0) {
		tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
		tailZone.getID(), 
		tailZone.iStandardOffset, 
		tailZone.iStartRecurrence.renameAppend("-Summer"), 
		tailZone.iEndRecurrence);
	} else {
		tailZone = new org.joda.time.tz.DateTimeZoneBuilder.DSTZone(
		tailZone.getID(), 
		tailZone.iStandardOffset, 
		tailZone.iStartRecurrence, 
		tailZone.iEndRecurrence.renameAppend("-Summer"));
	}
}
if (zone == null) {
	org.joda.time.DateTimeZone temp = null;
	try {
		try {
			java.lang.String id = java.lang.System.getProperty("user.timezone");
			if (id != null) {
				temp = org.joda.time.DateTimeZone.forID(id);
			}
		} catch (java.lang.RuntimeException ex) {

		}
		if (temp == null) {
			temp = org.joda.time.DateTimeZone.forTimeZone(java.util.TimeZone.getDefault());
		}
	} catch (java.lang.IllegalArgumentException ex) {

	}
	if (temp == null) {
		temp = org.joda.time.DateTimeZone.UTC;
	}
	org.joda.time.DateTimeZone.cDefault = zone = temp;
}:if (zone == null) {
	org.joda.time.DateTimeZone $0 = null;
	try {
		try {
			java.lang.String $1 = java.lang.System.getProperty("user.timezone");
			if ($1 != null) {
				$0 = org.joda.time.DateTimeZone.forID($1);
			}
		} catch (java.lang.RuntimeException ex) {

		}
		if ($0 == null) {
			$0 = org.joda.time.DateTimeZone.forTimeZone(java.util.TimeZone.getDefault());
		}
	} catch (java.lang.IllegalArgumentException ex) {

	}
	if ($0 == null) {
		$0 = org.joda.time.DateTimeZone.UTC;
	}
	org.joda.time.DateTimeZone.cDefault = zone = $0;
}
return 57 + getID().hashCode():return 57 + getID().hashCode()
org.joda.time.tz.DateTimeZoneBuilder.Transition tr = transitions.get(i):org.joda.time.tz.DateTimeZoneBuilder.Transition $0 = transitions.get(i)
nameKeys[i] = pool[index]:nameKeys[i] = pool[index]
int offsetLocal = getOffset(instantLocal):int $0 = getOffset(instantLocal)
if ((instantAdjusted - prev) <= diff) {
	return offsetPrev;
}:if ((instantAdjusted - prev) <= diff) {
	return offsetPrev;
}
if (nameProvider == null) {
	nameProvider = org.joda.time.DateTimeZone.getDefaultNameProvider();
}:if (nameProvider == null) {
	nameProvider = org.joda.time.DateTimeZone.getDefaultNameProvider();
}
return org.joda.time.DateTimeZone.printOffset(getOffset(instant)):return org.joda.time.DateTimeZone.printOffset(getOffset(instant))
java.lang.String[][] zoneStrings = new java.text.DateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings():java.lang.String[][] $0 = new java.text.DateFormatSymbols(java.util.Locale.ENGLISH).getZoneStrings()
offset -= seconds * org.joda.time.DateTimeConstants.MILLIS_PER_SECOND:offset -= seconds * org.joda.time.DateTimeConstants.MILLIS_PER_SECOND
return prev - 1:return prev - 1
org.joda.time.DateTimeZone.setProvider0(null):org.joda.time.DateTimeZone.setProvider0(null)
throw new java.lang.ArithmeticException("Subtracting time zone offset caused overflow"):throw new java.lang.ArithmeticException("Subtracting time zone offset caused overflow")
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.weekyear(), pivot, lenientParse)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TwoDigitYear(org.joda.time.DateTimeFieldType.weekyear(), pivot, lenientParse))
long end = transitions[transitions.length - 1]:long $0 = transitions[transitions.length - 1]
wallOffsets[i] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in))):wallOffsets[i] = ((int) (org.joda.time.tz.DateTimeZoneBuilder.readMillis(in)))
if ((pattern == null) || (pattern.length() == 0)) {
	throw new java.lang.IllegalArgumentException("Invalid pattern specification");
}:if ((pattern == null) || (pattern.length() == 0)) {
	throw new java.lang.IllegalArgumentException("Invalid pattern specification");
}
throw new org.joda.time.IllegalInstantException(instantLocal, getID()):throw new org.joda.time.IllegalInstantException(instantLocal, getID())
org.joda.time.format.FormatUtils.appendPaddedInteger(buf, seconds, 2):org.joda.time.format.FormatUtils.appendPaddedInteger(buf, seconds, 2)
return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, 4):return appendDecimal(org.joda.time.DateTimeFieldType.minuteOfDay(), minDigits, 4)
out.writeShort(poolSize):out.writeShort(poolSize)
return nameProvider:return nameProvider
map.put("CET", "CET"):map.put("CET", "CET")
provider = new org.joda.time.tz.UTCProvider():provider = new org.joda.time.tz.UTCProvider()
throw new java.lang.IllegalArgumentException("Minutes out of range: " + minutesOffset):throw new java.lang.IllegalArgumentException("Minutes out of range: " + minutesOffset)
if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

	maxDigits = tokenLen;
}:if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

	maxDigits = tokenLen;
}
java.lang.String providerClass = java.lang.System.getProperty("org.joda.time.DateTimeZone.NameProvider"):java.lang.String $0 = java.lang.System.getProperty("org.joda.time.DateTimeZone.NameProvider")
if (id.startsWith("+") || id.startsWith("-")) {
	int offset = org.joda.time.DateTimeZone.parseOffset(id);
	if (offset == 0L) {
		return org.joda.time.DateTimeZone.UTC;
	} else {
		id = org.joda.time.DateTimeZone.printOffset(offset);
		return org.joda.time.DateTimeZone.fixedOffsetZone(id, offset);
	}
}:if (id.startsWith("+") || id.startsWith("-")) {
	int $0 = org.joda.time.DateTimeZone.parseOffset(id);
	if ($0 == 0L) {
		return org.joda.time.DateTimeZone.UTC;
	} else {
		id = org.joda.time.DateTimeZone.printOffset($0);
		return org.joda.time.DateTimeZone.fixedOffsetZone(id, $0);
	}
}
org.joda.time.DateTimeZone.cAvailableIDs = ids:org.joda.time.DateTimeZone.cAvailableIDs = ids
if (i > 0) {
	return iWallOffsets[i - 1];
}:if (i > 0) {
	return iWallOffsets[i - 1];
}
if (iTailZone == null) {
	return iStandardOffsets[i - 1];
}:if (iTailZone == null) {
	return iStandardOffsets[i - 1];
}
provider = new org.joda.time.tz.ZoneInfoProvider("org/joda/time/tz/data"):provider = new org.joda.time.tz.ZoneInfoProvider("org/joda/time/tz/data")
int hours = offset / org.joda.time.DateTimeConstants.MILLIS_PER_HOUR:int $0 = offset / org.joda.time.DateTimeConstants.MILLIS_PER_HOUR
return false:return false
long curOffset = wallOffsets[i]:long $0 = wallOffsets[i]
iTailZone = tailZone:iTailZone = tailZone
nameKeys[i + 1] = (nextNameKey + "-Summer").intern():nameKeys[i + 1] = (nextNameKey + "-Summer").intern()
if (transitions.length <= 1) {
	return false;
}:if (transitions.length <= 1) {
	return false;
}
if (zone == null) {
	synchronized(org.joda.time.DateTimeZone.class) {
		zone = org.joda.time.DateTimeZone.cDefault;
		if (zone == null) {
			org.joda.time.DateTimeZone temp = null;
			try {
				try {
					java.lang.String id = java.lang.System.getProperty("user.timezone");
					if (id != null) {
						temp = org.joda.time.DateTimeZone.forID(id);
					}
				} catch (java.lang.RuntimeException ex) {

				}
				if (temp == null) {
					temp = org.joda.time.DateTimeZone.forTimeZone(java.util.TimeZone.getDefault());
				}
			} catch (java.lang.IllegalArgumentException ex) {

			}
			if (temp == null) {
				temp = org.joda.time.DateTimeZone.UTC;
			}
			org.joda.time.DateTimeZone.cDefault = zone = temp;
		}
	}
}:if (zone == null) {
	synchronized(org.joda.time.DateTimeZone.class) {
		zone = org.joda.time.DateTimeZone.cDefault;
		if (zone == null) {
			org.joda.time.DateTimeZone $0 = null;
			try {
				try {
					java.lang.String $1 = java.lang.System.getProperty("user.timezone");
					if ($1 != null) {
						$0 = org.joda.time.DateTimeZone.forID($1);
					}
				} catch (java.lang.RuntimeException ex) {

				}
				if ($0 == null) {
					$0 = org.joda.time.DateTimeZone.forTimeZone(java.util.TimeZone.getDefault());
				}
			} catch (java.lang.IllegalArgumentException ex) {

			}
			if ($0 == null) {
				$0 = org.joda.time.DateTimeZone.UTC;
			}
			org.joda.time.DateTimeZone.cDefault = zone = $0;
		}
	}
}
nextLocal = java.lang.Long.MAX_VALUE:nextLocal = java.lang.Long.MAX_VALUE
if (pool[j].equals(nameKey)) {
	if (poolSize < 256) {
		out.writeByte(j);
	} else {
		out.writeShort(j);
	}
	break;
}:if (pool[j].equals(nameKey)) {
	if (poolSize < 256) {
		out.writeByte(j);
	} else {
		out.writeShort(j);
	}
	break;
}
return getOffset(org.joda.time.DateTimeUtils.currentTimeMillis()):return getOffset(org.joda.time.DateTimeUtils.currentTimeMillis())
i = (i >= 0) ? i + 1 : ~i:i = (i >= 0) ? i + 1 : ~i
int seconds = offset / org.joda.time.DateTimeConstants.MILLIS_PER_SECOND:int $0 = offset / org.joda.time.DateTimeConstants.MILLIS_PER_SECOND
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.FULL):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.FULL, org.joda.time.format.DateTimeFormat.FULL)
org.joda.time.Period p = new org.joda.time.Period(trans[i], trans[i + 1], org.joda.time.PeriodType.yearMonthDay(), chrono):org.joda.time.Period $0 = new org.joda.time.Period(trans[i], trans[i + 1], org.joda.time.PeriodType.yearMonthDay(), chrono)
if (sm != null) {
	sm.checkPermission(new org.joda.time.JodaTimePermission("DateTimeZone.setDefault"));
}:if (sm != null) {
	sm.checkPermission(new org.joda.time.JodaTimePermission("DateTimeZone.setDefault"));
}
org.joda.time.DateTimeZone.iFixedOffsetCache = new java.util.HashMap<java.lang.String, java.lang.ref.SoftReference<org.joda.time.DateTimeZone>>():org.joda.time.DateTimeZone.iFixedOffsetCache = new java.util.HashMap<java.lang.String, java.lang.ref.SoftReference<org.joda.time.DateTimeZone>>()
return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, false)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber(fieldType, maxDigits, false))
return appendText(org.joda.time.DateTimeFieldType.halfdayOfDay()):return appendText(org.joda.time.DateTimeFieldType.halfdayOfDay())
return zone:return zone
map.put("BST", "Asia/Dhaka"):map.put("BST", "Asia/Dhaka")
if (i >= 0) {
	if (instant > java.lang.Long.MIN_VALUE) {
		return instant - 1;
	}
	return instant;
}:if (i >= 0) {
	if (instant > java.lang.Long.MIN_VALUE) {
		return instant - 1;
	}
	return instant;
}
if (org.joda.time.DateTimeZone.iFixedOffsetCache == null) {
	org.joda.time.DateTimeZone.iFixedOffsetCache = new java.util.HashMap<java.lang.String, java.lang.ref.SoftReference<org.joda.time.DateTimeZone>>();
}:if (org.joda.time.DateTimeZone.iFixedOffsetCache == null) {
	org.joda.time.DateTimeZone.iFixedOffsetCache = new java.util.HashMap<java.lang.String, java.lang.ref.SoftReference<org.joda.time.DateTimeZone>>();
}
long nextLocal = nextTransition(instantLocal - offsetLocal):long $0 = nextTransition(instantLocal - offsetLocal)
switch (c) {
	case 'c' :
	case 'C' :
	case 'x' :
	case 'y' :
	case 'Y' :
	case 'd' :
	case 'h' :
	case 'H' :
	case 'm' :
	case 's' :
	case 'S' :
	case 'e' :
	case 'D' :
	case 'F' :
	case 'w' :
	case 'W' :
	case 'k' :
	case 'K' :
		return true;
	case 'M' :
		if (tokenLen <= 2) {
			return true;
		}}:switch (c) {
	case 'c' :
	case 'C' :
	case 'x' :
	case 'y' :
	case 'Y' :
	case 'd' :
	case 'h' :
	case 'H' :
	case 'm' :
	case 's' :
	case 'S' :
	case 'e' :
	case 'D' :
	case 'F' :
	case 'w' :
	case 'W' :
	case 'k' :
	case 'K' :
		return true;
	case 'M' :
		if (tokenLen <= 2) {
			return true;
		}}
return oldInstant:return oldInstant
if (temp == null) {
	temp = org.joda.time.DateTimeZone.forTimeZone(java.util.TimeZone.getDefault());
}:if (temp == null) {
	temp = org.joda.time.DateTimeZone.forTimeZone(java.util.TimeZone.getDefault());
}
if (!org.joda.time.DateTimeZone.UTC.equals(provider.getZone("UTC"))) {
	throw new java.lang.IllegalArgumentException("Invalid UTC zone provided");
}:if (!org.joda.time.DateTimeZone.UTC.equals(provider.getZone("UTC"))) {
	throw new java.lang.IllegalArgumentException("Invalid UTC zone provided");
}
java.lang.String id = org.joda.time.DateTimeZone.printOffset(millisOffset):java.lang.String $0 = org.joda.time.DateTimeZone.printOffset(millisOffset)
org.joda.time.tz.Provider provider = null:org.joda.time.tz.Provider $0 = null
int type = org.joda.time.format.DateTimeFormat.DATETIME:int $0 = org.joda.time.format.DateTimeFormat.DATETIME
throw new java.lang.IllegalArgumentException("Invalid style specification: " + style):throw new java.lang.IllegalArgumentException("Invalid style specification: " + style)
if ((hoursOffset < (-23)) || (hoursOffset > 23)) {
	throw new java.lang.IllegalArgumentException("Hours out of range: " + hoursOffset);
}:if ((hoursOffset < (-23)) || (hoursOffset > 23)) {
	throw new java.lang.IllegalArgumentException("Hours out of range: " + hoursOffset);
}
wallOffsets[i] = tr.getWallOffset():wallOffsets[i] = tr.getWallOffset()
throw new java.lang.IllegalArgumentException(
"The provider doesn't have any available ids"):throw new java.lang.IllegalArgumentException(
"The provider doesn't have any available ids")
long[] trans = new long[size]:long[] $0 = new long[size]
return appendFraction(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, maxDigits):return appendFraction(org.joda.time.DateTimeFieldType.hourOfDay(), minDigits, maxDigits)
i++:i++
org.joda.time.DateTimeZone.setNameProvider0(nameProvider):org.joda.time.DateTimeZone.setNameProvider0(nameProvider)
if (iTailZone != null) {
	long prev = iTailZone.previousTransition(instant);
	if (prev < instant) {
		return prev;
	}
}:if (iTailZone != null) {
	long $0 = iTailZone.previousTransition(instant);
	if ($0 < instant) {
		return $0;
	}
}
if (zone != null) {
	return zone;
}:if (zone != null) {
	return zone;
}
if (offsetLocal >= 0) {
	long prev = previousTransition(instantAdjusted);
	if (prev < instantAdjusted) {
		int offsetPrev = getOffset(prev);
		int diff = offsetPrev - offsetLocal;
		if ((instantAdjusted - prev) <= diff) {
			return offsetPrev;
		}
	}
}:if (offsetLocal >= 0) {
	long $0 = previousTransition(instantAdjusted);
	if ($0 < instantAdjusted) {
		int $1 = getOffset($0);
		int $2 = $1 - offsetLocal;
		if ((instantAdjusted - $0) <= $2) {
			return $1;
		}
	}
}
nameProvider = org.joda.time.DateTimeZone.getDefaultNameProvider():nameProvider = org.joda.time.DateTimeZone.getDefaultNameProvider()
out.writeShort(j):out.writeShort(j)
offset -= hours * ((int) (org.joda.time.DateTimeConstants.MILLIS_PER_HOUR)):offset -= hours * ((int) (org.joda.time.DateTimeConstants.MILLIS_PER_HOUR))
map.put("AST", "America/Anchorage"):map.put("AST", "America/Anchorage")
if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



	lenientParse = false;
}:if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



	lenientParse = false;
}
if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.DATE;
}:if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.DATE;
}
iWallOffsets = wallOffsets:iWallOffsets = wallOffsets
org.joda.time.format.FormatUtils.appendPaddedInteger(buf, hours, 2):org.joda.time.format.FormatUtils.appendPaddedInteger(buf, hours, 2)
type = org.joda.time.format.DateTimeFormat.DATE:type = org.joda.time.format.DateTimeFormat.DATE
java.lang.String[] set = zoneStrings[j]:java.lang.String[] $0 = zoneStrings[j]
int offset = org.joda.time.DateTimeZone.parseOffset(id):int $0 = org.joda.time.DateTimeZone.parseOffset(id)
return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, true, minDigits)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber(fieldType, maxDigits, true, minDigits))
long prev = transitions[i - 1]:long $0 = transitions[i - 1]
for (int i = 0; i < (nameKeys.length - 1); i++) {
	java.lang.String curNameKey = nameKeys[i];
	java.lang.String nextNameKey = nameKeys[i + 1];
	long curOffset = wallOffsets[i];
	long nextOffset = wallOffsets[i + 1];
	long curStdOffset = standardOffsets[i];
	long nextStdOffset = standardOffsets[i + 1];
	org.joda.time.Period p = new org.joda.time.Period(trans[i], trans[i + 1], org.joda.time.PeriodType.yearMonthDay(), chrono);
	if ((((((((curOffset != nextOffset) && 
	(curStdOffset == nextStdOffset)) && 
	curNameKey.equals(nextNameKey)) && 
	(p.getYears() == 0)) && (p.getMonths() > 4)) && (p.getMonths() < 8)) && 
	curNameKey.equals(zoneNameData[2])) && 
	curNameKey.equals(zoneNameData[4])) {

		if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
			java.lang.System.out.println("Fixing duplicate name key - " + nextNameKey);
			java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[i], chrono)) + 
			" - ") + new org.joda.time.DateTime(trans[i + 1], chrono));
		}
		if (curOffset > nextOffset) {
			nameKeys[i] = (curNameKey + "-Summer").intern();
		} else { 			if (curOffset < nextOffset) {
				nameKeys[i + 1] = (nextNameKey + "-Summer").intern();
				i++;
			}}
	}
}:for (int $0 = 0; $0 < (nameKeys.length - 1); $0++) {
	java.lang.String $1 = nameKeys[$0];
	java.lang.String $2 = nameKeys[$0 + 1];
	long $3 = wallOffsets[$0];
	long $4 = wallOffsets[$0 + 1];
	long $5 = standardOffsets[$0];
	long $6 = standardOffsets[$0 + 1];
	org.joda.time.Period $7 = new org.joda.time.Period(trans[$0], trans[$0 + 1], org.joda.time.PeriodType.yearMonthDay(), chrono);
	if (((((((($3 != $4) && 
	($5 == $6)) && 
	$1.equals($2)) && 
	($7.getYears() == 0)) && ($7.getMonths() > 4)) && ($7.getMonths() < 8)) && 
	$1.equals(zoneNameData[2])) && 
	$1.equals(zoneNameData[4])) {

		if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {
			java.lang.System.out.println("Fixing duplicate name key - " + $2);
			java.lang.System.out.println((("     - " + new org.joda.time.DateTime(trans[$0], chrono)) + 
			" - ") + new org.joda.time.DateTime(trans[$0 + 1], chrono));
		}
		if ($3 > $4) {
			nameKeys[$0] = ($1 + "-Summer").intern();
		} else { 			if ($3 < $4) {
				nameKeys[$0 + 1] = ($2 + "-Summer").intern();
				$0++;
			}}
	}
}
switch (c) {
	case 'x' :
		builder.appendWeekyear(tokenLen, maxDigits);
		break;
	case 'y' :
		builder.appendYear(tokenLen, maxDigits);
		break;
	case 'Y' :
		builder.appendYearOfEra(tokenLen, maxDigits);
		break;}:switch (c) {
	case 'x' :
		builder.appendWeekyear(tokenLen, maxDigits);
		break;
	case 'y' :
		builder.appendYear(tokenLen, maxDigits);
		break;
	case 'Y' :
		builder.appendYearOfEra(tokenLen, maxDigits);
		break;}
return new org.joda.time.format.DateTimeFormatter(printer, parser):return new org.joda.time.format.DateTimeFormatter(printer, parser)
throw new java.lang.IllegalArgumentException("Id must not be null"):throw new java.lang.IllegalArgumentException("Id must not be null")
if ((millisOffset < (-org.joda.time.DateTimeZone.MAX_MILLIS)) || (millisOffset > org.joda.time.DateTimeZone.MAX_MILLIS)) {
	throw new java.lang.IllegalArgumentException("Millis out of range: " + millisOffset);
}:if ((millisOffset < (-org.joda.time.DateTimeZone.MAX_MILLIS)) || (millisOffset > org.joda.time.DateTimeZone.MAX_MILLIS)) {
	throw new java.lang.IllegalArgumentException("Millis out of range: " + millisOffset);
}
throw new java.lang.IllegalArgumentException("Invalid UTC zone provided"):throw new java.lang.IllegalArgumentException("Invalid UTC zone provided")
map.put("WET", "WET"):map.put("WET", "WET")
map.put("AGT", "America/Argentina/Buenos_Aires"):map.put("AGT", "America/Argentina/Buenos_Aires")
if (id != null) {
	temp = org.joda.time.DateTimeZone.forID(id);
}:if (id != null) {
	temp = org.joda.time.DateTimeZone.forID(id);
}
return map.get(id):return map.get(id)
builder.appendDayOfWeekText():builder.appendDayOfWeekText()
count++:count++
java.lang.SecurityManager sm = java.lang.System.getSecurityManager():java.lang.SecurityManager $0 = java.lang.System.getSecurityManager()
if (((locale == null) || (id == null)) || (nameKey == null)) {
	return null;
}:if (((locale == null) || (id == null)) || (nameKey == null)) {
	return null;
}
if (dtz != null) {
	return dtz;
}:if (dtz != null) {
	return dtz;
}
if (!tr.isTransitionFrom(last)) {
	throw new java.lang.IllegalArgumentException(id);
}:if (!tr.isTransitionFrom(last)) {
	throw new java.lang.IllegalArgumentException(id);
}
pool[i] = it.next():pool[i] = it.next()
if (provider == null) {
	try {
		provider = new org.joda.time.tz.ZoneInfoProvider("org/joda/time/tz/data");
	} catch (java.lang.Exception ex) {
		ex.printStackTrace();
	}
}:if (provider == null) {
	try {
		provider = new org.joda.time.tz.ZoneInfoProvider("org/joda/time/tz/data");
	} catch (java.lang.Exception ex) {
		ex.printStackTrace();
	}
}
if (dateStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.TIME;
} else { 	if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
		type = org.joda.time.format.DateTimeFormat.DATE;
	}}:if (dateStyle == org.joda.time.format.DateTimeFormat.NONE) {
	type = org.joda.time.format.DateTimeFormat.TIME;
} else { 	if (timeStyle == org.joda.time.format.DateTimeFormat.NONE) {
		type = org.joda.time.format.DateTimeFormat.DATE;
	}}
if (instant == null) {
	return getOffset(org.joda.time.DateTimeUtils.currentTimeMillis());
}:if (instant == null) {
	return getOffset(org.joda.time.DateTimeUtils.currentTimeMillis());
}
i--:i--
return iID:return iID
if (offsetLocal != offset) {



	if (strict || (offsetLocal < 0)) {

		long nextLocal = nextTransition(instantLocal - offsetLocal);
		if (nextLocal == (instantLocal - offsetLocal)) {
			nextLocal = java.lang.Long.MAX_VALUE;
		}
		long nextAdjusted = nextTransition(instantLocal - offset);
		if (nextAdjusted == (instantLocal - offset)) {
			nextAdjusted = java.lang.Long.MAX_VALUE;
		}
		if (nextLocal != nextAdjusted) {

			if (strict) {

				throw new org.joda.time.IllegalInstantException(instantLocal, getID());
			} else {



				offset = offsetLocal;
			}
		}
	}
}:if (offsetLocal != offset) {



	if (strict || (offsetLocal < 0)) {

		long $0 = nextTransition(instantLocal - offsetLocal);
		if ($0 == (instantLocal - offsetLocal)) {
			$0 = java.lang.Long.MAX_VALUE;
		}
		long $1 = nextTransition(instantLocal - offset);
		if ($1 == (instantLocal - offset)) {
			$1 = java.lang.Long.MAX_VALUE;
		}
		if ($0 != $1) {

			if (strict) {

				throw new org.joda.time.IllegalInstantException(instantLocal, getID());
			} else {



				offset = offsetLocal;
			}
		}
	}
}
zone = ref.get():zone = ref.get()
org.joda.time.DateTimeZone.cDefault = zone:org.joda.time.DateTimeZone.cDefault = zone
map.put("SST", "Pacific/Guadalcanal"):map.put("SST", "Pacific/Guadalcanal")
return earlierOrLater ? instant + diff : instant:return earlierOrLater ? instant + diff : instant
return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset(
zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields))
return instantLocal:return instantLocal
for (int i = 0; i < length; i++) {
	indexRef[0] = i;
	java.lang.String token = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef);
	i = indexRef[0];

	int tokenLen = token.length();
	if (tokenLen == 0) {
		break;
	}
	char c = token.charAt(0);

	switch (c) {
		case 'G' :
			builder.appendEraText();
			break;
		case 'C' :
			builder.appendCenturyOfEra(tokenLen, tokenLen);
			break;
		case 'x' :
		case 'y' :
		case 'Y' :
			if (tokenLen == 2) {
				boolean lenientParse = true;


				if ((i + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



						lenientParse = false;
					}
					indexRef[0]--;
				}


				switch (c) {
					case 'x' :
						builder.appendTwoDigitWeekyear(
						new org.joda.time.DateTime().getWeekyear() - 30, lenientParse);
						break;
					case 'y' :
					case 'Y' :
					default :
						builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, lenientParse);
						break;}

			} else {

				int maxDigits = 9;


				if ((i + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

						maxDigits = tokenLen;
					}
					indexRef[0]--;
				}

				switch (c) {
					case 'x' :
						builder.appendWeekyear(tokenLen, maxDigits);
						break;
					case 'y' :
						builder.appendYear(tokenLen, maxDigits);
						break;
					case 'Y' :
						builder.appendYearOfEra(tokenLen, maxDigits);
						break;}

			}
			break;
		case 'M' :
			if (tokenLen >= 3) {
				if (tokenLen >= 4) {
					builder.appendMonthOfYearText();
				} else {
					builder.appendMonthOfYearShortText();
				}
			} else {
				builder.appendMonthOfYear(tokenLen);
			}
			break;
		case 'd' :
			builder.appendDayOfMonth(tokenLen);
			break;
		case 'a' :
			builder.appendHalfdayOfDayText();
			break;
		case 'h' :
			builder.appendClockhourOfHalfday(tokenLen);
			break;
		case 'H' :
			builder.appendHourOfDay(tokenLen);
			break;
		case 'k' :
			builder.appendClockhourOfDay(tokenLen);
			break;
		case 'K' :
			builder.appendHourOfHalfday(tokenLen);
			break;
		case 'm' :
			builder.appendMinuteOfHour(tokenLen);
			break;
		case 's' :
			builder.appendSecondOfMinute(tokenLen);
			break;
		case 'S' :
			builder.appendFractionOfSecond(tokenLen, tokenLen);
			break;
		case 'e' :
			builder.appendDayOfWeek(tokenLen);
			break;
		case 'E' :
			if (tokenLen >= 4) {
				builder.appendDayOfWeekText();
			} else {
				builder.appendDayOfWeekShortText();
			}
			break;
		case 'D' :
			builder.appendDayOfYear(tokenLen);
			break;
		case 'w' :
			builder.appendWeekOfWeekyear(tokenLen);
			break;
		case 'z' :
			if (tokenLen >= 4) {
				builder.appendTimeZoneName();
			} else {
				builder.appendTimeZoneShortName(null);
			}
			break;
		case 'Z' :
			if (tokenLen == 1) {
				builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
			} else { 				if (tokenLen == 2) {
					builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
				} else {
					builder.appendTimeZoneId();
				}}
			break;
		case '\'' :
			java.lang.String sub = token.substring(1);
			if (sub.length() == 1) {
				builder.appendLiteral(sub.charAt(0));
			} else {


				builder.appendLiteral(new java.lang.String(sub));
			}
			break;
		default :
			throw new java.lang.IllegalArgumentException(
			"Illegal pattern component: " + token);}

}:for (int $0 = 0; $0 < length; $0++) {
	indexRef[0] = $0;
	java.lang.String $1 = org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef);
	$0 = indexRef[0];

	int $2 = $1.length();
	if ($2 == 0) {
		break;
	}
	char $3 = $1.charAt(0);

	switch ($3) {
		case 'G' :
			builder.appendEraText();
			break;
		case 'C' :
			builder.appendCenturyOfEra($2, $2);
			break;
		case 'x' :
		case 'y' :
		case 'Y' :
			if ($2 == 2) {
				boolean $4 = true;


				if (($0 + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {



						$4 = false;
					}
					indexRef[0]--;
				}


				switch ($3) {
					case 'x' :
						builder.appendTwoDigitWeekyear(
						new org.joda.time.DateTime().getWeekyear() - 30, $4);
						break;
					case 'y' :
					case 'Y' :
					default :
						builder.appendTwoDigitYear(new org.joda.time.DateTime().getYear() - 30, $4);
						break;}

			} else {

				int $5 = 9;


				if (($0 + 1) < length) {
					indexRef[0]++;
					if (org.joda.time.format.DateTimeFormat.isNumericToken(org.joda.time.format.DateTimeFormat.parseToken(pattern, indexRef))) {

						$5 = $2;
					}
					indexRef[0]--;
				}

				switch ($3) {
					case 'x' :
						builder.appendWeekyear($2, $5);
						break;
					case 'y' :
						builder.appendYear($2, $5);
						break;
					case 'Y' :
						builder.appendYearOfEra($2, $5);
						break;}

			}
			break;
		case 'M' :
			if ($2 >= 3) {
				if ($2 >= 4) {
					builder.appendMonthOfYearText();
				} else {
					builder.appendMonthOfYearShortText();
				}
			} else {
				builder.appendMonthOfYear($2);
			}
			break;
		case 'd' :
			builder.appendDayOfMonth($2);
			break;
		case 'a' :
			builder.appendHalfdayOfDayText();
			break;
		case 'h' :
			builder.appendClockhourOfHalfday($2);
			break;
		case 'H' :
			builder.appendHourOfDay($2);
			break;
		case 'k' :
			builder.appendClockhourOfDay($2);
			break;
		case 'K' :
			builder.appendHourOfHalfday($2);
			break;
		case 'm' :
			builder.appendMinuteOfHour($2);
			break;
		case 's' :
			builder.appendSecondOfMinute($2);
			break;
		case 'S' :
			builder.appendFractionOfSecond($2, $2);
			break;
		case 'e' :
			builder.appendDayOfWeek($2);
			break;
		case 'E' :
			if ($2 >= 4) {
				builder.appendDayOfWeekText();
			} else {
				builder.appendDayOfWeekShortText();
			}
			break;
		case 'D' :
			builder.appendDayOfYear($2);
			break;
		case 'w' :
			builder.appendWeekOfWeekyear($2);
			break;
		case 'z' :
			if ($2 >= 4) {
				builder.appendTimeZoneName();
			} else {
				builder.appendTimeZoneShortName(null);
			}
			break;
		case 'Z' :
			if ($2 == 1) {
				builder.appendTimeZoneOffset(null, "Z", false, 2, 2);
			} else { 				if ($2 == 2) {
					builder.appendTimeZoneOffset(null, "Z", true, 2, 2);
				} else {
					builder.appendTimeZoneId();
				}}
			break;
		case '\'' :
			java.lang.String $6 = $1.substring(1);
			if ($6.length() == 1) {
				builder.appendLiteral($6.charAt(0));
			} else {


				builder.appendLiteral(new java.lang.String($6));
			}
			break;
		default :
			throw new java.lang.IllegalArgumentException(
			"Illegal pattern component: " + $1);}

}
map.put("PLT", "Asia/Karachi"):map.put("PLT", "Asia/Karachi")
return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.FULL):return org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex(org.joda.time.format.DateTimeFormat.NONE, org.joda.time.format.DateTimeFormat.FULL)
if ((style == null) || (style.length() != 2)) {
	throw new java.lang.IllegalArgumentException("Invalid style specification: " + style);
}:if ((style == null) || (style.length() != 2)) {
	throw new java.lang.IllegalArgumentException("Invalid style specification: " + style);
}
if (hoursInMinutes < 0) {
	minutesOffset = hoursInMinutes - java.lang.Math.abs(minutesOffset);
} else {
	minutesOffset = hoursInMinutes + minutesOffset;
}:if (hoursInMinutes < 0) {
	minutesOffset = hoursInMinutes - java.lang.Math.abs(minutesOffset);
} else {
	minutesOffset = hoursInMinutes + minutesOffset;
}
return iWallOffsets[i - 1]:return iWallOffsets[i - 1]
return iStandardOffsets[i - 1]:return iStandardOffsets[i - 1]
if (offsetBefore <= offsetAfter) {
	return instant;
}:if (offsetBefore <= offsetAfter) {
	return instant;
}
iStandardOffsets = standardOffsets:iStandardOffsets = standardOffsets
int hoursInMinutes = hoursOffset * 60:int $0 = hoursOffset * 60
return appendTwoDigitWeekyear(pivot, false):return appendTwoDigitWeekyear(pivot, false)
org.joda.time.DateTimeZone.iFixedOffsetCache.put(id, new java.lang.ref.SoftReference<org.joda.time.DateTimeZone>(zone)):org.joda.time.DateTimeZone.iFixedOffsetCache.put(id, new java.lang.ref.SoftReference<org.joda.time.DateTimeZone>(zone))
throw new java.lang.IllegalArgumentException(id):throw new java.lang.IllegalArgumentException(id)
buf.append('\''):buf.append('\'')
if ((minutesOffset < (-59)) || (minutesOffset > 59)) {
	throw new java.lang.IllegalArgumentException("Minutes out of range: " + minutesOffset);
}:if ((minutesOffset < (-59)) || (minutesOffset > 59)) {
	throw new java.lang.IllegalArgumentException("Minutes out of range: " + minutesOffset);
}
return appendDecimal(org.joda.time.DateTimeFieldType.yearOfEra(), minDigits, maxDigits):return appendDecimal(org.joda.time.DateTimeFieldType.yearOfEra(), minDigits, maxDigits)
if (i >= 0) {
	return iWallOffsets[i];
}:if (i >= 0) {
	return iWallOffsets[i];
}
return rename((iNameKey + appendNameKey).intern()):return rename((iNameKey + appendNameKey).intern())
long nextAdjusted = nextTransition(instantLocal - offsetAdjusted):long $0 = nextTransition(instantLocal - offsetAdjusted)
final long instantAdjusted = instantLocal - offsetLocal:final long $0 = instantLocal - offsetLocal
return instantUTC:return instantUTC
for (int i = 0; i < size; i++) {
	org.joda.time.tz.DateTimeZoneBuilder.Transition tr = transitions.get(i);

	if (!tr.isTransitionFrom(last)) {
		throw new java.lang.IllegalArgumentException(id);
	}

	trans[i] = tr.getMillis();
	wallOffsets[i] = tr.getWallOffset();
	standardOffsets[i] = tr.getStandardOffset();
	nameKeys[i] = tr.getNameKey();

	last = tr;
}:for (int $0 = 0; $0 < size; $0++) {
	org.joda.time.tz.DateTimeZoneBuilder.Transition $1 = transitions.get($0);

	if (!$1.isTransitionFrom(last)) {
		throw new java.lang.IllegalArgumentException(id);
	}

	trans[$0] = $1.getMillis();
	wallOffsets[$0] = $1.getWallOffset();
	standardOffsets[$0] = $1.getStandardOffset();
	nameKeys[$0] = $1.getNameKey();

	last = $1;
}
zoneNameData = set:zoneNameData = set
java.lang.System.out.println("Fixing duplicate name key - " + nextNameKey):java.lang.System.out.println("Fixing duplicate name key - " + nextNameKey)
int offsetOriginal = getOffset(originalInstantUTC):int $0 = getOffset(originalInstantUTC)
org.joda.time.DateTimeZone zone:org.joda.time.DateTimeZone $0
return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, true)):return append0(new org.joda.time.format.DateTimeFormatterBuilder.FixedNumber(fieldType, numDigits, true))
java.util.Map<java.lang.String, java.lang.String> map = org.joda.time.DateTimeZone.cZoneIdConversion:java.util.Map<java.lang.String, java.lang.String> $0 = org.joda.time.DateTimeZone.cZoneIdConversion
nextAdjusted = java.lang.Long.MAX_VALUE:nextAdjusted = java.lang.Long.MAX_VALUE
[ERROR] fr.inria.astor.core.solutionsearch.EvolutionarySearchEngine.startEvolution(EvolutionarySearchEngine.java:84) - Error at generation 6
java.lang.IllegalArgumentException: Comparison method violates its general contract!
java.lang.IllegalArgumentException: Comparison method violates its general contract!
	at java.util.TimSort.mergeHi(TimSort.java:899)
	at java.util.TimSort.mergeAt(TimSort.java:516)
	at java.util.TimSort.mergeCollapse(TimSort.java:441)
	at java.util.TimSort.sort(TimSort.java:245)
	at java.util.Arrays.sort(Arrays.java:1512)
	at java.util.ArrayList.sort(ArrayList.java:1454)
	at java.util.Collections.sort(Collections.java:175)
	at fr.inria.astor.approaches.levenshtein.LevenSearchStrategy.getFixIngredient(LevenSearchStrategy.java:67)
	at fr.inria.astor.core.ingredientbased.IngredientBasedEvolutionaryRepairApproachImpl.createOperatorInstanceForPoint(IngredientBasedEvolutionaryRepairApproachImpl.java:95)
	at fr.inria.astor.core.solutionsearch.EvolutionarySearchEngine.modifyProgramVariant(EvolutionarySearchEngine.java:264)
	at fr.inria.astor.core.solutionsearch.EvolutionarySearchEngine.createNewProgramVariant(EvolutionarySearchEngine.java:198)
	at fr.inria.astor.core.solutionsearch.EvolutionarySearchEngine.processGenerations(EvolutionarySearchEngine.java:146)
	at fr.inria.astor.core.solutionsearch.EvolutionarySearchEngine.startEvolution(EvolutionarySearchEngine.java:68)
	at fr.inria.main.evolution.AstorMain.run(AstorMain.java:203)
	at fr.inria.main.evolution.AstorMain.execute(AstorMain.java:247)
	at fr.inria.main.evolution.AstorMain.main(AstorMain.java:218)
[INFO ] fr.inria.astor.core.solutionsearch.AstorCoreEngine.atEnd(AstorCoreEngine.java:170) - Time Repair Loop (s): 127.644
[INFO ] fr.inria.astor.core.solutionsearch.AstorCoreEngine.atEnd(AstorCoreEngine.java:172) - generationsexecuted: 6
[INFO ] fr.inria.astor.core.solutionsearch.AstorCoreEngine.printFinalStatus(AstorCoreEngine.java:247) - 
----SUMMARY_EXECUTION---
[INFO ] fr.inria.astor.core.solutionsearch.AstorCoreEngine.printFinalStatus(AstorCoreEngine.java:257) - End Repair Search: NOT Found solution
[INFO ] fr.inria.main.evolution.AstorMain.run(AstorMain.java:208) - Time Total(s): 2883.298


Node: ea83bd69f547



Date: Tue Oct 29 05:21:56 EDT 2019

cd /script/jGenProg_Defects4J_Time_3;
export JAVA_TOOL_OPTIONS="-Dfile.encoding=UTF8 -Duser.language=en-US -Duser.country=US -Duser.language=en";
TZ="America/New_York"; export TZ;
export PATH="/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/:$PATH";
export JAVA_HOME="/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/";
java -Xmx4048m -cp /script/libs/jtestex7.jar:/astor/target/astor-0.0.2-SNAPSHOT-jar-with-dependencies.jar fr.inria.main.evolution.AstorMain \
	-mode jgenprog \
	-location . \
	-id Time-3 \
	-failing org.joda.time.TestMutableDateTime_Adds \
	-jvm4testexecution /usr/lib/jvm/java-1.7.0-openjdk-amd64/bin/ \
	-jvm4evosuitetestexecution /usr/lib/jvm/java-1.7.0-openjdk-amd64/bin/ \
	-maxgen 1000000 \
	-maxtime 120 \
	-stopfirst true \
	-seed 0 \
	-scope local \
	-population 1 \
	-javacompliancelevel 5 \
	-srcjavafolder src/main/java/ \
	-srctestfolder src/test/java/ \
	-binjavafolder target/classes/ \
	-bintestfolder target/test-classes/ \
	-parameters mode:leven \
	-dependencies /script/jGenProg_Defects4J_Time_3/target/classes/:/script/jGenProg_Defects4J_Time_3/target/test-classes/:/defects4j/framework/projects/Time/lib/joda-convert-1.2.jar:/defects4j/framework/projects/Time/lib/junit-3.8.2.jar:/defects4j/framework/projects/Time/lib/junit/junit/3.8.2/junit-3.8.2.jar:/defects4j/framework/projects/Time/lib/org/joda/joda-convert/1.2/joda-convert-1.2.jar;
	echo "\n\nNode: `hostname`\n";
	echo "\n\nDate: `date`\n";

